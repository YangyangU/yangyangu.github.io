{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1}],"Cache":[{"_id":"source/about/index.md","hash":"010869f7fa8f886706d27eaa8d9706de628c2fd4","modified":1721648104155},{"_id":"source/_posts/hello-world.md","hash":"bab6048dcc857e72a67ee047a02a4d172db5be63","modified":1721354616792},{"_id":"source/_posts/快速上手TS.md","hash":"d12d468f06ec9349bc15bf1e4a586ad1b7f7e4a6","modified":1721645442869},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1721292086687},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1721292086687},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"c640b57695b7b6002399711f1a7708b0f6c05b84","modified":1721292086210},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"ff9b0e1fb9dba665af2f1e4a577f8cb9e840464b","modified":1721292086210},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1721292086687},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1721292086687},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1721292086687},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1721292086029},{"_id":"node_modules/hexo-theme-fluid/languages/ru.yml","hash":"7dc78f22696649a4c68dc65a9b52d9a992fa82a0","modified":1721292086687},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"2253e1bc61694b3bdc5e434ea2660d13d941b50e","modified":1721292086687},{"_id":"node_modules/hexo-theme-fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1721292086687},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1721292086029},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1721292086696},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"759d78d97cfe364a4bcf0b5cd2d3505967674276","modified":1721292086687},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1721292086035},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1721292086049},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1721292086040},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":1721292086029},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1721292086038},{"_id":"node_modules/hexo-theme-fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1721292086687},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1721292086057},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"9bf0d357a607a282f3b9cb04525a4df0cc2a8b76","modified":1721292086058},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1721292086058},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1721292086058},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"33c3317cdcee062789de2336dd8d0cc7f86d3650","modified":1721292086049},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1721292086050},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1721292086029},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1721292086039},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1721292086042},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1721292086039},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1721292086041},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1721292086051},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1721292086048},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1721292086057},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1721292086078},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/index-generator.js","hash":"9159fc22fa84a7b605dd15fe4104f01fe9c71147","modified":1721292086078},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1721292086058},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"82bb06686158ebe160a631c79f156cd4fde35656","modified":1721292086207},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1721292086075},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/head.ejs","hash":"7b7b1d098726e86687a15fe3d520d178577ffcae","modified":1721292086047},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1721292086088},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"9ac5ddad06e9b0e6015ce531430018182a4bc0fa","modified":1721292086087},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1721292086675},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1721292086675},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d3e75f53c59674d171309e50702954671f31f1a4","modified":1721292086207},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1721292086657},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1721292086058},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1721292086679},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1721292086029},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1721292086068},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1721292086210},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1721292086659},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1721292086069},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1721292086078},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1721292086070},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1721292086086},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"c5939d14065d38c86e16d1642e154dde5a23e830","modified":1721292086071},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"0857aa86db2a711ae5c77218a9e3fa686d0e87b1","modified":1721292086070},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/fold.js","hash":"73e4fd12ce3e47981479391ed354b7d9d3279f70","modified":1721292086077},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1721292086078},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"5891534506b959a2f559f29e122baa3eb9159d93","modified":1721292086076},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1721292086078},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"e3b456a079e5dc0032473b516c865b20f83d2c26","modified":1721292086202},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1721292086088},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1721292086202},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1721292086072},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/crypto.js","hash":"ae4ad8a188ef5b3fa6818b01629fc962b3de8551","modified":1721292086073},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1721292086202},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1721292086210},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1721292086207},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1721292086207},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1721292086074},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1721292086075},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1721292086078},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"8e67b522c47aa250860e3fe2c733f1f958a506c0","modified":1721292086077},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1721292086206},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1721292086078},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1721292086207},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"966689d7c5e4320008285395fbaa2751f6209be5","modified":1721292086210},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1721292086210},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1721292086687},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"4d48c424e47ff9a17a563167ea5f480890267adf","modified":1721292086210},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1721292086210},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1721292086041},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1721292086043},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/discuss.ejs","hash":"98d065b58ce06b7d18bff3c974e96fa0f34ae03a","modified":1721292086043},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1721292086044},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/twikoo.ejs","hash":"d84bcb5ccd78470a60c067fc914ac0ac67ac8777","modified":1721292086058},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1721292086051},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1721292086058},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1721292086046},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1721292086058},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1721292086058},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1721292086036},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/navigation.ejs","hash":"37d750428772d7c71ba36ce0c2540780d90fadea","modified":1721292086056},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1721292086058},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1721292086037},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1721292086029},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1721292086046},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1721292086045},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/encrypt.ejs","hash":"0fff24cf5bf99fbe5c56c292e2eac4a89bf29db4","modified":1721292086044},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1721292086058},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1721292086048},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1721292086052},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/moment.ejs","hash":"4ff3fb1b60ccc95a0af3bbdbd0757fedefc088b5","modified":1721292086052},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/mermaid.ejs","hash":"03ac02762f801970d1c4e73d6ec8d4c503780e50","modified":1721292086052},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1721292086056},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1721292086041},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/typed.ejs","hash":"f345374885cd6a334f09a11f59c443b5d577c06c","modified":1721292086058},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/copyright.ejs","hash":"529f3069742b3d338c769ba2d836e7f3c342a09d","modified":1721292086042},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1721292086058},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1721292086038},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-bottom.ejs","hash":"375974ec017696e294dc12469fb0ae257800dc2d","modified":1721292086052},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1721292086058},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1721292086073},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1721292086052},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"a5fe1deccb73b5f578797dbb11038efc15f63ce8","modified":1721292086078},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"bd8376e1cf7892dc2daa58f2f443574be559fdbf","modified":1721292086078},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"c19ac8050b82c3676b0332a56099ccfcc36d9d52","modified":1721292086078},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1721292086078},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1721292086086},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1721292086202},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1721292086058},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1721292086659},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1721292086667},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1721292086682},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1721292086659},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1721292086045},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1721292086659},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"25fb6fa4c783b847c632584c49a7e1593cdb2f5d","modified":1721292086676},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1721292086667},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1721292086659},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"85492ef64d7e5f70f0f7e46d570bbc911e686d7e","modified":1721292086671},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1721292086677},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1721292086669},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/analytics.ejs","hash":"4f68c80bd1395e2f6d11e373116e54de11cb62e8","modified":1721292086029},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/print.styl","hash":"166afbc596ea4b552bad7290ec372d25ec34db7b","modified":1721292086684},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1721292086678},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1721292086669},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1721292086672},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1721292086670},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-page.styl","hash":"cd432a6411ccac7df47e6a300fb1a872cfc763e7","modified":1721292086683},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1721292086687},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1721292086675},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1721292086680},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1721292086679},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-tag.styl","hash":"c96d36aa8fe20f0c3c1a29ee2473cd8064b10f73","modified":1721292086684},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1721292086668},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1721292086659},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1721292086659},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1721292086671},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1721292086673},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1721292086673},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1721292086673},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1721292086681},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"c4459248c66ea1326feed021179b847ae91d465f","modified":1721292086674},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1721292086685},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1721292086681},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1721292086681},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1721292086683},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1721292086685},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1721292086686},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1721292086687},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1721292086614},{"_id":"public/local-search.xml","hash":"88641af4a8cd1c2825c07d8e21cbb48c51cfa2a3","modified":1725895903429},{"_id":"public/about/index.html","hash":"86efff1a38a77b626d225ceabe442f4ba6ea20e8","modified":1721648131437},{"_id":"public/categories/TypeScript/index.html","hash":"e09f268760a51f9b825488532cf925087cc63fe7","modified":1721647468561},{"_id":"public/index.html","hash":"5d7106fb17850c1b6b3d124655f1398ca01cb39c","modified":1725895903429},{"_id":"public/archives/index.html","hash":"a59d6dd3bc7b862f5a2e5e0bf7285c732d05c0b6","modified":1725895903429},{"_id":"public/archives/2023/index.html","hash":"0bee1b95e5c1141f7a17412dab2b60f5f77991ed","modified":1725895011671},{"_id":"public/archives/2023/07/index.html","hash":"7e174fcf1fe2d3acdf983d8fe4dcac7442c3f203","modified":1721356019216},{"_id":"public/archives/2024/index.html","hash":"018d1090a427f49bb1921fb96610895a051ffb60","modified":1725895903429},{"_id":"public/archives/2024/07/index.html","hash":"0b3cfb73837a9dc06d71be840bfc54c365df8b58","modified":1725895011671},{"_id":"public/tags/TypeScript/index.html","hash":"e7717f508b0bf9391656b4ba7c5f78faa0baabad","modified":1721647468561},{"_id":"public/404.html","hash":"46d9071df4d4807ea9c0094df2c17d02484d3020","modified":1721356019216},{"_id":"public/tags/index.html","hash":"c99a5aa914c673ed0681933cd17f4a0ce37f5287","modified":1725895011671},{"_id":"public/categories/index.html","hash":"61ae570a0dfdef7dd4d2cdb62234967819e2303f","modified":1725895903429},{"_id":"public/links/index.html","hash":"5f55ec224a8364dfb743bebe940c99e0641ef6eb","modified":1721356019216},{"_id":"public/2024/07/17/hello-world/index.html","hash":"6f1998efa64f946c0329708c0f621a54aef515bd","modified":1721356019216},{"_id":"public/2023/07/10/快速上手TS/index.html","hash":"c998632ea151cd6b5da2978fce411b8c760eb8a1","modified":1721356019216},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1721299609713},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1721300588480},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1721299609713},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1721299609713},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1721299609713},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1721299609713},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1721299609713},{"_id":"public/css/highlight-dark.css","hash":"902294bada4323c0f51502d67cba8c3a0298952f","modified":1721299609713},{"_id":"public/js/events.js","hash":"5891534506b959a2f559f29e122baa3eb9159d93","modified":1721299609713},{"_id":"public/css/highlight.css","hash":"04d4ddbb5e1d1007447c2fe293ee05aae9b9563e","modified":1721299609713},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1721299609713},{"_id":"public/js/color-schema.js","hash":"c5939d14065d38c86e16d1642e154dde5a23e830","modified":1721299609713},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1721299609713},{"_id":"public/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1721299609713},{"_id":"public/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1721299609713},{"_id":"public/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1721299609713},{"_id":"public/css/main.css","hash":"7d7590cfe0261084ad357d5f51cb14d13db826d8","modified":1721299609713},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1721299609713},{"_id":"source/_data/languages/zh-CN.yml","hash":"df38c56180ae7255b35ae036ccd883b45f2187ea","modified":1721353733538},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1702719015000},{"_id":"themes/fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1702719015000},{"_id":"themes/fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1702719015000},{"_id":"themes/fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1702719015000},{"_id":"themes/fluid/.gitignore","hash":"ae3bfcb89777657c5dfb5169d91445dcb0e5ab98","modified":1702719015000},{"_id":"themes/fluid/README.md","hash":"ff9b0e1fb9dba665af2f1e4a577f8cb9e840464b","modified":1702719015000},{"_id":"themes/fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1702719015000},{"_id":"themes/fluid/README_en.md","hash":"365184a73af40e7365504c3077f3d80dfee1d80e","modified":1702719015000},{"_id":"themes/fluid/_config.yml","hash":"759d78d97cfe364a4bcf0b5cd2d3505967674276","modified":1702719015000},{"_id":"themes/fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1702719015000},{"_id":"themes/fluid/package.json","hash":"c640b57695b7b6002399711f1a7708b0f6c05b84","modified":1702719015000},{"_id":"themes/fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1702719015000},{"_id":"themes/fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1702719015000},{"_id":"themes/fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1702719015000},{"_id":"themes/fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1702719015000},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"2253e1bc61694b3bdc5e434ea2660d13d941b50e","modified":1702719015000},{"_id":"themes/fluid/languages/ru.yml","hash":"7dc78f22696649a4c68dc65a9b52d9a992fa82a0","modified":1702719015000},{"_id":"themes/fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1702719015000},{"_id":"themes/fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1702719015000},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1702719015000},{"_id":"themes/fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1702719015000},{"_id":"themes/fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1702719015000},{"_id":"themes/fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1702719015000},{"_id":"themes/fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1702719015000},{"_id":"themes/fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1702719015000},{"_id":"themes/fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":1702719015000},{"_id":"themes/fluid/layout/index.ejs","hash":"33c3317cdcee062789de2336dd8d0cc7f86d3650","modified":1702719015000},{"_id":"themes/fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1702719015000},{"_id":"themes/fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1702719015000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"554c0d0e086a0784d83ee71c83f8bceeb60aecc8","modified":1702719015000},{"_id":"themes/fluid/layout/post.ejs","hash":"9bf0d357a607a282f3b9cb04525a4df0cc2a8b76","modified":1702719015000},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1702719015000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":1702719015000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"c8b0d49c49e3c88872fd3b37909345ff5b2b6aa0","modified":1702719015000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":1702719015000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1702719015000},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1702719015000},{"_id":"themes/fluid/.github/workflows/cr.yaml","hash":"19a8a00f5ba9607d82265572fe1202b64a8b0822","modified":1702719015000},{"_id":"themes/fluid/.github/workflows/publish.yaml","hash":"6f02e6440d88629229556e3fd47d0280fe2240db","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1702719015000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"fff07ce0472afc368d388637cb9d438195da9b5b","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/head.ejs","hash":"7b7b1d098726e86687a15fe3d520d178577ffcae","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1702719015000},{"_id":"themes/fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1702719015000},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1702719015000},{"_id":"themes/fluid/scripts/generators/index-generator.js","hash":"9159fc22fa84a7b605dd15fe4104f01fe9c71147","modified":1702719015000},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"82bb06686158ebe160a631c79f156cd4fde35656","modified":1702719015000},{"_id":"themes/fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1702719015000},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"9ac5ddad06e9b0e6015ce531430018182a4bc0fa","modified":1702719015000},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"0857aa86db2a711ae5c77218a9e3fa686d0e87b1","modified":1702719015000},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"d3e75f53c59674d171309e50702954671f31f1a4","modified":1702719015000},{"_id":"themes/fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1702719015000},{"_id":"themes/fluid/scripts/tags/fold.js","hash":"73e4fd12ce3e47981479391ed354b7d9d3279f70","modified":1702719015000},{"_id":"themes/fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1702719015000},{"_id":"themes/fluid/scripts/tags/note.js","hash":"e3b456a079e5dc0032473b516c865b20f83d2c26","modified":1702719015000},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1702719015000},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1702719015000},{"_id":"themes/fluid/scripts/utils/crypto.js","hash":"ae4ad8a188ef5b3fa6818b01629fc962b3de8551","modified":1702719015000},{"_id":"themes/fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1702719015000},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1702719015000},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1702719015000},{"_id":"themes/fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1702719015000},{"_id":"themes/fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1702719015000},{"_id":"themes/fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1702719015000},{"_id":"themes/fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1702719015000},{"_id":"themes/fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1702719015000},{"_id":"themes/fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1702719015000},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"8e67b522c47aa250860e3fe2c733f1f958a506c0","modified":1702719015000},{"_id":"themes/fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1702719015000},{"_id":"themes/fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1702719015000},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1702719015000},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1702719015000},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"966689d7c5e4320008285395fbaa2751f6209be5","modified":1702719015000},{"_id":"themes/fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1702719015000},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"4d48c424e47ff9a17a563167ea5f480890267adf","modified":1702719015000},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1702719015000},{"_id":"themes/fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1702719015000},{"_id":"themes/fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1702719015000},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1702719015000},{"_id":"themes/fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1702719015000},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1702719015000},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1702719015000},{"_id":"themes/fluid/source/js/events.js","hash":"5891534506b959a2f559f29e122baa3eb9159d93","modified":1702719015000},{"_id":"themes/fluid/source/js/color-schema.js","hash":"c5939d14065d38c86e16d1642e154dde5a23e830","modified":1702719015000},{"_id":"themes/fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1702719015000},{"_id":"themes/fluid/source/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1702719015000},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1702719015000},{"_id":"themes/fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1702719015000},{"_id":"themes/fluid/source/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/discuss.ejs","hash":"98d065b58ce06b7d18bff3c974e96fa0f34ae03a","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/twikoo.ejs","hash":"d84bcb5ccd78470a60c067fc914ac0ac67ac8777","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/header/navigation.ejs","hash":"37d750428772d7c71ba36ce0c2540780d90fadea","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/plugins/analytics.ejs","hash":"4f68c80bd1395e2f6d11e373116e54de11cb62e8","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/plugins/encrypt.ejs","hash":"0fff24cf5bf99fbe5c56c292e2eac4a89bf29db4","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/plugins/moment.ejs","hash":"4ff3fb1b60ccc95a0af3bbdbd0757fedefc088b5","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/plugins/mermaid.ejs","hash":"03ac02762f801970d1c4e73d6ec8d4c503780e50","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/plugins/typed.ejs","hash":"f345374885cd6a334f09a11f59c443b5d577c06c","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/post/meta-bottom.ejs","hash":"375974ec017696e294dc12469fb0ae257800dc2d","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/post/copyright.ejs","hash":"529f3069742b3d338c769ba2d836e7f3c342a09d","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1702719015000},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1702719015000},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"a5fe1deccb73b5f578797dbb11038efc15f63ce8","modified":1702719015000},{"_id":"themes/fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1702719015000},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"bd8376e1cf7892dc2daa58f2f443574be559fdbf","modified":1702719015000},{"_id":"themes/fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1702719015000},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"c19ac8050b82c3676b0332a56099ccfcc36d9d52","modified":1702719015000},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1702719015000},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1702719015000},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1702719015000},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1702719015000},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"85492ef64d7e5f70f0f7e46d570bbc911e686d7e","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/print.styl","hash":"166afbc596ea4b552bad7290ec372d25ec34db7b","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"25fb6fa4c783b847c632584c49a7e1593cdb2f5d","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_post/post-page.styl","hash":"cd432a6411ccac7df47e6a300fb1a872cfc763e7","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_post/post-tag.styl","hash":"c96d36aa8fe20f0c3c1a29ee2473cd8064b10f73","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"c4459248c66ea1326feed021179b847ae91d465f","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1702719015000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1702719015000},{"_id":"themes/fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1702719015000},{"_id":"source/_posts/看了一天官方文档，终于搞懂了类型转换机制.md","hash":"f099bf7c8e1a6799654fd85f27112a8672da0b1f","modified":1721645800823},{"_id":"source/_posts/1.md","hash":"0d3671f943fb9793996317067292e6f2583c8b29","modified":1721646063326},{"_id":"source/_posts/如何将提交说明（commit message）导出到指定文件.md","hash":"78e1cc74fc07f696115ebc8cda2489e469e76348","modified":1725895853197},{"_id":"source/_posts/快速上手 TS（基础类型篇）.md","hash":"a2c9a2eed706eedb8141f286f44a6706c015cb31","modified":1725895842776},{"_id":"source/_posts/快速上手TS（进阶类型篇）.md","hash":"a11a0e2251b14495ee6a5ad6984183d6f4b858af","modified":1725895856910},{"_id":"source/_posts/快速上手 TS（环境篇）/md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1721646403563},{"_id":"source/_posts/只会Vue，快速上手React（React Router篇）.md","hash":"0a8e5f47b959fe1376f1f3a05c5a07cbf721985a","modified":1725895858060},{"_id":"source/_posts/只会上班第一天就要我写ReactTS是种.md","hash":"6c641ba1676bd016a65bbfdc90ed81a41e384b08","modified":1725895852201},{"_id":"source/_posts/快速上手 TS（环境篇）.md","hash":"c044b555c031afbbaa61bf4010f01efd3acf4e8f","modified":1725895529603},{"_id":"source/_posts/面试官为什么返回true.md","hash":"8df34c12524b3f49fdb6a215e56f90a01e3d18b1","modified":1725895836516},{"_id":"source/_posts/一文搞懂Webpack和Vite.md","hash":"c8ab3089a337d85f9efd23af61e2a52fe438e276","modified":1725895750736},{"_id":"source/_posts/一文搞懂 HTTP 缓存.md","hash":"15e4c76e87059428019654b2b11df62fc57625cc","modified":1725895854339},{"_id":"source/_posts/面试官：从输入URL到页面渲染，有哪些地方可以优化.md","hash":"a129da3f9643340a9cc56d3113c61d7631529073","modified":1725895835432},{"_id":"public/archives/page/2/index.html","hash":"3d84cfd409f5cccb8f0c8da78a869f2e0a35df7c","modified":1725895011671},{"_id":"public/archives/2023/12/index.html","hash":"9ca55ece7ed39e94f184c834d7e327792bf2a52d","modified":1725895011671},{"_id":"public/categories/JavaScript/index.html","hash":"f8dfafeeaad5cb98b3083bb9ddf4f5242d5dc2b6","modified":1721647468561},{"_id":"public/categories/Git/index.html","hash":"d49889dfeadb97b2ec01b0f58caa1867aa8ae88a","modified":1721647468561},{"_id":"public/categories/React/index.html","hash":"a171c80a565a47436ce93ef0f7e0513536f18daf","modified":1725895903429},{"_id":"public/categories/性能优化/index.html","hash":"9391abb48476bd4e92f6e77e8d678f6248e1d98d","modified":1721647468561},{"_id":"public/categories/工程化/index.html","hash":"1409170e4f1eaeb557298140e942d256a2a29e86","modified":1721647468561},{"_id":"public/categories/HTTP/index.html","hash":"116e07698f67cbc6d4736689d5cf43e3363b71cd","modified":1721647468561},{"_id":"public/page/2/index.html","hash":"f0e6db751bc4c29e7af35f183a76bcf47026bb02","modified":1725895903429},{"_id":"public/tags/JavaScript/index.html","hash":"dbd35d6136b613d11973c4241443216875bbec2c","modified":1721647468561},{"_id":"public/archives/2024/04/index.html","hash":"70539940640062b70881fdab0e868ac1c00e6c55","modified":1725895011671},{"_id":"public/tags/Git/index.html","hash":"22fae86ca694990e8c4b74a66649f154ab7e7cfa","modified":1721647468561},{"_id":"public/tags/性能优化/index.html","hash":"92f8135b7e9c2c9308f5859d150541dcb931bc2d","modified":1721647468561},{"_id":"public/tags/Vite/index.html","hash":"a04f23e29094bb566bd7d38fae22f6aa8dddb13a","modified":1721647468561},{"_id":"public/2024/07/03/快速上手TS（进阶类型篇）/index.html","hash":"e9e675ae8324f1eaaec614b627d9fcf82f858451","modified":1725895903429},{"_id":"public/2024/07/02/快速上手 TS（基础类型篇）/index.html","hash":"d49aeb424fe16138e26801b2cd8d11d83cc9169a","modified":1725895903429},{"_id":"public/2024/06/26/如何将提交说明（commit message）导出到指定文件/index.html","hash":"92a6d67255aa3a1cbe2b526ed9f882e29d9b694f","modified":1725895903429},{"_id":"public/2024/06/24/快速上手 TS（环境篇）/index.html","hash":"25739bc5b0d4171d839084676fe31feba0cca5bd","modified":1725895903429},{"_id":"public/2024/06/12/只会Vue，快速上手React（React Router篇）/index.html","hash":"547ed949db77c952eded8938d853320edb15ee73","modified":1725895903429},{"_id":"public/2024/06/07/只会上班第一天就要我写ReactTS是种/index.html","hash":"3f9f7b91ca68d32984ef5ded0d835d601c970d4d","modified":1725895903429},{"_id":"public/2024/04/27/面试官：从输入URL到页面渲染，有哪些地方可以优化/index.html","hash":"cfdb07f298f83b74179969e876cc48977a3d05d2","modified":1725895903429},{"_id":"public/2024/04/25/一文搞懂Webpack和Vite/index.html","hash":"1597e949556547c2bf8d7eeea4a56827db795eae","modified":1725895903429},{"_id":"public/2024/04/22/一文搞懂 HTTP 缓存/index.html","hash":"c807a21b0cebe727643f9649510e358551ee39ea","modified":1725895903429},{"_id":"public/2023/12/04/面试官为什么返回true/index.html","hash":"462ec6eb1a32d55ac72243e6098e8af9eb45c8ea","modified":1725895903429},{"_id":"public/2023/12/03/看了一天官方文档，终于搞懂了类型转换机制/index.html","hash":"ac4b010c8d73344d3a8fe20dc25682f1485af381","modified":1725895903429},{"_id":"public/tags/HTTP/index.html","hash":"ff1bb9cb3924afbd27b6a763ee6d6f93cc9c4e5d","modified":1721647468561},{"_id":"public/tags/Webpack/index.html","hash":"208bbfdf83f81084a2e59da460cb627598d0cfd2","modified":1721647468561},{"_id":"public/archives/2024/06/index.html","hash":"af4b94b7316743c95cb20cb83a0cd7b745d4cad8","modified":1725895903429},{"_id":"public/tags/React/index.html","hash":"4b06e71828c464cee44275017ebc72532462486e","modified":1725895903429},{"_id":"source/_posts/React对比Vue如何做路由鉴权.md","hash":"ab74358b7f12bb54065b787d6fea60f21935003d","modified":1725895114145},{"_id":"public/2024/06/09/React对比Vue如何做路由鉴权/index.html","hash":"19005c87fc61b89992969ae2662a0a9970ff5300","modified":1725895011671},{"_id":"public/tags/Vue/index.html","hash":"d94a48441e0d9777e619546e8567cd6c3d78c4e3","modified":1725895903429},{"_id":"public/archives/2024/09/index.html","hash":"bf58e6bd9b026be2778a51d0ca602ef9e3fc3d1e","modified":1725895903429},{"_id":"public/2024/09/09/React对比Vue如何做路由鉴权/index.html","hash":"53f18d6c521a773ca977cfead2c9e4b43eb52dd1","modified":1725895903429}],"Category":[{"name":"TypeScript","_id":"clyr5bjsc0003hcv685ih7kuk"},{"name":"JavaScript","_id":"clywvgujf0001z0v65y446g6x"},{"name":"Git","_id":"clywvrgp4000e18v65jx7fn4k"},{"name":"React","_id":"clywvwf7y000acwv60xu15h7h"},{"name":"性能优化","_id":"clyww2n6y000340v62qh6b46d"},{"name":"Webpack","_id":"clyww5tg5000a40v6ekidhj11"},{"name":"Webpack,Vite","_id":"clyww5vs6000g40v6181y6y0o"},{"name":"工程化","_id":"clyww789y000i40v6ehcmg5kl"},{"name":"HTTP","_id":"clyww98s5000n40v68wq93tu0"}],"Data":[],"Page":[{"title":"about","layout":"about","_content":"\n## Hi there 👋\n\n**My Skills:**<a href=\"https://github.com/anuraghazra/convoychat\">\n\n<p align=\"left\">\n  <a href=\"https://skillicons.dev\">\n    <img src=\"https://skillicons.dev/icons?i=vue,react,ts,nodejs,pinia,webpack,vite,tailwind,less,mysql&perline=6\" />\n  </a>\n</p>\n\n**Currently Learning:**\n\n<p align=\"left\">\n  <a href=\"https://skillicons.dev\">\n    <img src=\"https://skillicons.dev/icons?i=py,nextjs,nuxtjs,astro,docker&perline=6\" />\n  </a>\n</p>\n\n**Contact Me:**\n\n<p>\n  <a href=\"https://space.bilibili.com/1769275177\"><img alt=\"Static Badge\" src=\"https://img.shields.io/badge/bilibili-ColourCode?style=flat-square&logo=bilibili&color=%23fb7299\"></a>\n  <a href=\"https://github.com/YangyangU\"><img alt=\"Static Badge\" src=\"https://img.shields.io/badge/GitHub-ColourCode?style=flat-square&logo=GitHub&color=%23555555\"></a>\n</p>\n","source":"about/index.md","raw":"---\ntitle: about\nlayout: about\n---\n\n## Hi there 👋\n\n**My Skills:**<a href=\"https://github.com/anuraghazra/convoychat\">\n\n<p align=\"left\">\n  <a href=\"https://skillicons.dev\">\n    <img src=\"https://skillicons.dev/icons?i=vue,react,ts,nodejs,pinia,webpack,vite,tailwind,less,mysql&perline=6\" />\n  </a>\n</p>\n\n**Currently Learning:**\n\n<p align=\"left\">\n  <a href=\"https://skillicons.dev\">\n    <img src=\"https://skillicons.dev/icons?i=py,nextjs,nuxtjs,astro,docker&perline=6\" />\n  </a>\n</p>\n\n**Contact Me:**\n\n<p>\n  <a href=\"https://space.bilibili.com/1769275177\"><img alt=\"Static Badge\" src=\"https://img.shields.io/badge/bilibili-ColourCode?style=flat-square&logo=bilibili&color=%23fb7299\"></a>\n  <a href=\"https://github.com/YangyangU\"><img alt=\"Static Badge\" src=\"https://img.shields.io/badge/GitHub-ColourCode?style=flat-square&logo=GitHub&color=%23555555\"></a>\n</p>\n","date":"2024-07-22T11:35:04.155Z","updated":"2024-07-22T11:35:04.155Z","path":"about/index.html","_id":"clyr5bjs40000hcv6ge1x3ggp","comments":1,"content":"<h2 id=\"Hi-there-👋\"><a href=\"#Hi-there-👋\" class=\"headerlink\" title=\"Hi there 👋\"></a>Hi there 👋</h2><p><strong>My Skills:</strong><a href=\"https://github.com/anuraghazra/convoychat\"></p>\n<p align=\"left\">\n  <a href=\"https://skillicons.dev\">\n    <img src=\"https://skillicons.dev/icons?i=vue,react,ts,nodejs,pinia,webpack,vite,tailwind,less,mysql&perline=6\" />\n  </a>\n</p>\n\n<p><strong>Currently Learning:</strong></p>\n<p align=\"left\">\n  <a href=\"https://skillicons.dev\">\n    <img src=\"https://skillicons.dev/icons?i=py,nextjs,nuxtjs,astro,docker&perline=6\" />\n  </a>\n</p>\n\n<p><strong>Contact Me:</strong></p>\n<p>\n  <a href=\"https://space.bilibili.com/1769275177\"><img alt=\"Static Badge\" src=\"https://img.shields.io/badge/bilibili-ColourCode?style=flat-square&logo=bilibili&color=%23fb7299\"></a>\n  <a href=\"https://github.com/YangyangU\"><img alt=\"Static Badge\" src=\"https://img.shields.io/badge/GitHub-ColourCode?style=flat-square&logo=GitHub&color=%23555555\"></a>\n</p>\n","excerpt":"","more":"<h2 id=\"Hi-there-👋\"><a href=\"#Hi-there-👋\" class=\"headerlink\" title=\"Hi there 👋\"></a>Hi there 👋</h2><p><strong>My Skills:</strong><a href=\"https://github.com/anuraghazra/convoychat\"></p>\n<p align=\"left\">\n  <a href=\"https://skillicons.dev\">\n    <img src=\"https://skillicons.dev/icons?i=vue,react,ts,nodejs,pinia,webpack,vite,tailwind,less,mysql&perline=6\" />\n  </a>\n</p>\n\n<p><strong>Currently Learning:</strong></p>\n<p align=\"left\">\n  <a href=\"https://skillicons.dev\">\n    <img src=\"https://skillicons.dev/icons?i=py,nextjs,nuxtjs,astro,docker&perline=6\" />\n  </a>\n</p>\n\n<p><strong>Contact Me:</strong></p>\n<p>\n  <a href=\"https://space.bilibili.com/1769275177\"><img alt=\"Static Badge\" src=\"https://img.shields.io/badge/bilibili-ColourCode?style=flat-square&logo=bilibili&color=%23fb7299\"></a>\n  <a href=\"https://github.com/YangyangU\"><img alt=\"Static Badge\" src=\"https://img.shields.io/badge/GitHub-ColourCode?style=flat-square&logo=GitHub&color=%23555555\"></a>\n</p>\n"}],"Post":[{"title":"看了一天官方文档，终于搞懂了类型转换机制","date":"2023-12-03T08:00:00.000Z","index_img":"/img/default.png","banner_img":"/img/default.png","_content":"\n> JS 数据类型的转换机制是是学习 JS 过程中的一大难点，一度成为初学者面临的巨大挑战，这一复杂性往往源于 JS 的灵活性和动态性，使得在不同的上下文中，同一个值可能被解释为不同的数据类型。\n\n本文将针从底层出发，借助官方文档，深度剖析 JS 类型转换机制。\n\n## JS 中的数据类型\n\n首先我们回忆一下 JS 中的数据类型。\n\n```js\n//基本数据类型\nlet num = 123; //数字\nlet str = \"hello world\"; //字符串\nlet flag = true; //布尔\nlet un = undefined; //未定义\nlet nu = null; //空值\nlet bigint = 9007199254740991n; //大整数\nlet sy = Symbol(\"symbol\"); //符号\n\n//引用数据类型\nvar person = {\n  //对象\n  name: \"John\",\n  age: 30,\n  isStudent: false,\n  hobbies: [\"reading\", \"coding\"],\n};\nvar numbers = [1, 2, 3, 4, 5]; //数组\nfunction foo() {\n  //函数\n  return \"你好！掘友\";\n}\n//等等\n```\n\n## 类型转换\n\nJS 类型转换主要分为两种：**隐式类型转换**和**显式类型转换**。\n\n> **1. 隐式类型转换**：在隐式类型转换中，JS 引擎自动地将一种数据类型转换为另一种类型，通常发生在运算或比较的过程中。这种转换是隐式的，开发者不需要明确地进行操作，而是由 JS 引擎在必要的时候自动完成。\n>\n> **2. 显式类型转换**：显式类型转换是由开发者明确指定的类型转换，通过调用相应的转换函数或使用一些特定的语法进行。这种转换是开发者有意识地进行的，用于确保数据在特定上下文中具有期望的类型。\n\n看到这你可能还是一头雾水，举个例子：\n\n```js\nvar a = 12;\nvar b = a + \"\"; //隐式类型转换\nvar c = String(a); //显式类型转换\n```\n\n在这里，隐式强制类型转换发生在变量 `a` 被赋值给变量 `b` 的过程中。通过将 `a` 与一个空字符串 `\"\"` 相加，JS 引擎会自动将 `a` 的值转换为字符串，然后与空字符串拼接在一起。这是一种常见的将数字转换为字符串的方式，是隐式的，因为你并没有明确指示进行类型转换。\n\n而显式强制类型转换通过调用 `String()` 函数来实现。你明确告诉 JS 引擎将变量 `a` 的值转换为字符串。这种方式更加明显，开发者有意识地进行了类型转换。\n\n总体而言，这两种方式都能将数字 `12` 转换为字符串，但发生的时机和方式略有不同。隐式转换是在某些操作中自动进行的，而显式转换是由开发者明确调用的。\n\n下面我们分别对这两种类型转换展开分析。\n\n## 显示转换\n\n我们通常使用官方定义的 `Number()`、`String()`、`Boolean()` 等函数进行显示转换，这些函数提供了明确的方式将值转换为特定的数据类型。\n\n### 原始值转其他类型\n\n#### 1. 原始值转换成布尔值\n\n```js\nconsole.log(Boolean()); // false\nconsole.log(Boolean(1)); // true\nconsole.log(Boolean(0)); // false\nconsole.log(Boolean(-1)); // true\nconsole.log(Boolean(undefined)); // false\nconsole.log(Boolean(null)); // false\nconsole.log(Boolean(\"123\")); // true\nconsole.log(Boolean(\"\")); // false\nconsole.log(Boolean(\" \")); // true\n```\n\n见官方文档 9.2：[Annotated ES5 9.2](https://es5.github.io/#x9.2)\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0af248dc983341429de2033138eaa78b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=961&h=426&s=35352&e=png&b=fafafa)\n\n简而言之：\n\n> - `false`、`0`、`''`、`null`、`undefined`以及`NaN`转换为`false`\n> - 其他所有值转换为`true`\n\n#### 2. 原始值转换成数字\n\n```js\nconsole.log(Number(\"123\")); //123\nconsole.log(Number(\"abc\")); //NaN\nconsole.log(Number()); //0\nconsole.log(Number(true)); //1\nconsole.log(Number(false)); //0\nconsole.log(Number(null)); //0\nconsole.log(Number(undefined)); //NaN\n```\n\n见官方文档 9.3：[Annotated ES5 9.3](https://es5.github.io/#x9.3)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fbe5f577d424fd38e3f14ccb2d4e72c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=945&h=518&s=35867&e=png&b=fbfbfb)\n\n大概的意思就是：\n\n> - 如果是数字字符串，则转换为对应的数字。\n> - 如果是非数字字符串或无法解析为数字的字符串，则转换为 `NaN`。\n> - 布尔值 `true` 被转换为 `1`，`false` 被转换为 `0`。\n> - `null` 被转换为 `0`。\n> - `undefined` 被转换为 `NaN`。\n\n其中，对象转数字规则没有罗列，我们将在后文对 对象类型（Object）转数字类型进行着重分析。\n\n#### 3. 原始值转换成字符串\n\n```js\nconsole.log(String()); //''\nconsole.log(String(123)); //'123'\nconsole.log(String(NaN)); //'NaN'\nconsole.log(String(undefined)); //'undefined'\nconsole.log(String(null)); //'null'\nconsole.log(String(true)); //'true'\n```\n\n- 空值或没有提供参数时，返回空字符串。\n- 数字转字符串：直接将数字转换为对应的字符串形式。\n- `NaN` 被转换为字符串 `'NaN'`。\n- 布尔值转字符串：`true` 转换为 `\"true\"`，`false` 转换为 `\"false\"`。\n- `null` 转换为字符串 `\"null\"`。\n- `undefined` 转换为 `\"undefined\"`。\n\n见官方文档 9.8：[Annotated ES5 9.8](https://es5.github.io/#x9.8)\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdbfe41b559f47029bdc769028fbee4a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=920&h=447&s=32790&e=png&b=f9f9f9)\n\n#### 4. 原始值转对象\n\n原始数据类型可以通过其对应的包装对象来实现转换，例如：\n\n```js\nconsole.log(Object(true)); //[Boolean: true]\nconsole.log(Object(123)); //[Number: 123]\nconsole.log(Object(\"123\")); //[String: '123']\nconsole.log(Object(undefined)); //{}\nconsole.log(Object(null)); //{}\n```\n\n见官方文档 9.9：[Annotated ES5 9.9](https://es5.github.io/#x9.9)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdc53305afb2424cb0e7a0e841465472~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=996&h=548&s=49999&e=png&b=fbfbfb)\n\n> - 布尔值、数字、字符串分别被转换为对应的 Boolean、Number、String 对象。\n> - 对于 `undefined`，使用 `Object()` 转换为一个空对象 `{}`。\n> - 对于 `null`，同样使用 `Object()` 转换为一个空对象 `{}`。\n\n以上就是原始值转换数据类型的官方解释，我们不用过多考虑，只需要无脑接受就好。\n\n当我们要用到的时候，查下这个表就行了。\n\n![67fab372c578caf931014f18b425317.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3feba050341e49e6bba8861a728f1e09~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1080&h=1017&s=508208&e=png&b=f9f9f9)\n\n因为官方没有给`Null`和`Undefined`定义显示转换的方法，所以我们暂且不聊。\n\n然而以上这些内容都不是本文的重点，我们的重点是**对象转换成原始值的过程**，好戏才刚刚开始。\n\n### 对象转原始值\n\n对象转`Null`与`Undefined`没有意义，所以我们只聊对象转字符串、数字和布尔值。\n\n#### 1. 对象转数字\n\n这时候我们再打开官方文档，回到之前铺垫的位置，如果转换的对象为对象类型的话，会进行红框中的操作。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10958fa5d33f4b7b8557883c5176f978~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=960&h=534&s=49735&e=png&b=fafafa)\n\n大概意思是，你传入一个值，经过`ToPrimitive`这样一个函数的调用并返回一个值，这个值会被转换成数字类型，我们可以通过文档（[Annotated ES5 9.3](https://es5.github.io/#x9.3)）进入到`ToPrimitive`这个函数内部。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55bb6b70e0bb4147a00488b3060777ad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=969&h=492&s=65356&e=png&b=faf9f9)\n\n看不懂，出国留学一下······\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff31030419fb4575b899dd3522e72015~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=914&h=917&s=99856&e=png&b=faf9f9)\n\n意思很明了，当你传入的是基本数据类型的时候，不会进行转换。唯独传入的是对象（Object）的时候才会有进行转换，它会调用对象的 \\[\\[DefaultValue\\]\\] 内部方法，于是我们跟随文档，跳到 8.12.8 。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b33ac07060264691b7c788826ed93ea1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1321&h=877&s=127585&e=png&b=ffffff)\n\n翻译就不给大家看了，直接告诉大家它什么意思吧。\n\n`ToPrimitive(obj, Number)` 是 ECMAScript 规范中描述的一种抽象操作，用于将给定对象 `obj` 转换为一个原始值，在进行数据转换的时候才会触发。这里我们目标是要将对象转换成数字，所以第二个参数是`Number`，字符串则是`String`。\n\n下面是 `ToPrimitive(obj, Number)` 的执行步骤：\n\n1.  **如果 `obj` 是基本类型：**\n\n    - 如果 `obj` 已经是基本类型（例如数字、字符串、布尔值等），那么直接返回 `obj`。\n\n1.  **否则，调用 `valueOf` 方法：**\n\n    - 如果 `obj` 不是基本类型，即它是一个对象，首先会尝试调用 `valueOf` 方法。\n    - 如果 `valueOf` 方法存在并返回一个原始值，那么返回这个原始值。\n\n1.  **否则，调用 `toString` 方法：**\n\n    - 如果 `valueOf` 方法不存在，或者它返回的仍然是一个对象，那么接下来会调用 `toString` 方法。\n    - 如果 `toString` 方法存在并返回一个原始值，那么返回这个原始值。\n\n1.  **否则，报错：**\n\n    - 如果 `toString` 方法也不存在，或者它返回的仍然是一个对象，那么就无法将对象转换为原始值，此时会抛出一个错误。\n\n简化一下：\n\n> ToPrimitive(obj, Number) ==> Number({})\n>\n> 1. 如果 obj 是基本类型，直接返回\n> 2. 否则，调用 valueOf 方法，如果得到原始值，则返回\n> 3. 否则，调用 toString 方法，如果得到原始值，则返回\n> 4. 否则，报错\n\n这就相当于一个公式，当我们在将一个对象转换成数字类型的时候，直接套就行。\n\n举个例子：\n\n```js\na = {};\nconsole.log(Number(a)); //NaN\n```\n\n开始套公式：\n\n1.  **如果 `a` 是基本类型：**\n\n    - `a` 是一个对象，不是基本类型。\n\n1.  **调用 `valueOf` 方法：**\n\n    - 尝试调用 `valueOf` 方法，看是否可以获取到原始值。\n    - 由于 `a` 是一个空对象 `{}`，而普通的对象（没有重写 `valueOf` 方法的情况下）的 `valueOf` 方法会返回对象本身，而不是一个原始值。\n\n1.  **调用 `toString` 方法：**\n\n    - 由于 `valueOf` 方法没有返回原始值，接下来调用 `toString` 方法。\n    - 对于普通的空对象 `{}`，`toString` 方法通常会返回 `\"[object Object]\"` 字符串。\n\n调用`toString`方法的时候得到了原始值字符串`\"[object Object]\"`，于是`ToPrimitive`这个函数将其返回，最后就相当于 `Number(\"[object Object]\")` 执行了这段代码。在 JS 引擎内部，`ToPrimitive`这个函数相当于进行了将 `Number(a)` 转化成了 `Number(\"[object Object]\")` ，相当于将字符串转换成数字，所以最终打印结果为 `NaN`。\n\n#### 2. 对象转字符串\n\n与对象转数字类似，唯一的区别就是转字符串时在`ToPrimitive`函数中是先调用 `toString` 方法，后调用 `typeOf` 方法。\n\n> ToPrimitive(obj, String) ==> String({})\n>\n> 1. 如果 obj 是基本类型，直接返回\n> 2. 否则，调用 toString 方法，如果得到原始值，则返回\n> 3. 否则，调用 valueOf 方法，如果得到原始值，则返回\n> 4. 否则，报错\n\n与对象转数字用法一致，区别在于调用 `toString` 方法和 `valueOf` 方法的顺序，区分这一点就行了。\n\n#### 3. 对象转布尔\n\n```js\nconsole.log(Boolean({})); // true\nconsole.log(Boolean([])); // true\n```\n\n对象转换为布尔值时，结果总是 `true`。\n\n---\n\n## 隐式转换\n\n隐式转换通常发生在一些运算符操作中，其中一些运算符会触发 JS 引擎自动进行类型转换以满足操作的要求。下面我们简单聊一下 `+` 这个运算符。\n\n### 一元运算 `+ a`\n\n官方文档（[Annotated ES5 11.4.6](https://es5.github.io/#x11.4.6)）这样描述：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29819bbe7e4740fcb2dfa3bfa015d5c5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=800&h=216&s=23157&e=png&b=ffffff)\n\n如果遇到 `+` 号，且它是当作一元运算符来使用，那么 `+` 号后面的数据一定要被强制转化为 `Number` 类型。\n\n举个例子：\n\n```js\nconsole.log(+\"1\"); //1\n```\n\n这个例子中， `+` 后面接的是数字字符串，则转换成对应数字，所以打印结果为`1`，没问题。\n\n那么 `+` 后面接的是对象类型呢，我们再举个例子：\n\n```js\nconsole.log(+{}); //NaN\n```\n\n这个例子中， `+` 后面接的是一个空对象，那么对象怎么转换成`Number`呢，是不是要走`ToPrimitive`函数那一套哇，直接套公式就行了。\n\n我直接搬过来：\n\n> ToPrimitive(obj, Number) ==> Number({})\n>\n> 1. 如果 obj 是基本类型，直接返回\n> 2. 否则，调用 valueOf 方法，如果得到原始值，则返回\n> 3. 否则，调用 toString 方法，如果得到原始值，则返回\n> 4. 否则，报错\n\n我们前面已经走过一遍流程了，这个`ToPrimitive`函数最后会返回一个`\"[object Object]\"`字符串，所以最终就相当于 `+` 后面接的是一个字符串，则转换成 `NaN` ，打印结果也为 `NaN`，没问题。\n\n我们也可以试着模拟一下整个过程：\n\n```js\n// +{} 的过程模拟\nconsole.log(+{}); //0\nconsole.log({}.valueOf()); //{}\nconsole.log({}.toString()); //\"[object Object]\"\n//返回\"[object Object]\"字符串\nconsole.log(Number(\"[object Object]\")); //NaN\n```\n\n### 二元运算 `a + b`\n\n官方文档（[Annotated ES5 11.6.1](https://es5.github.io/#x11.6.1)）这样描述：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ba8415ad2d24e2e8d5d150360b2a7e8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1399&h=622&s=85403&e=png&b=ffffff)\n\n二元运算符 `+` 可以执行字符串连接，也可以执行数字加法。简而言之，将 `+` 左右两边的数据分别用`ToPrimitive`函数调用一遍，如果返回值中有一个是字符串，则进行字符串拼接；否则进行加法运算。\n\n即：\n\n> lprim + rprim == ToPrimitive(v1) + ToPrimitive(v2)\n>\n> 1. 当 + 两边有一个是字符串，则按字符串进行拼接\n> 2. 否则，转到 number 进行计算\n\n举个例子：\n\n```js\nconsole.log(1 + \"1\"); //'11'\n```\n\n我们分别让数字`1`和字符串`'1'`走一遍`ToPrimitive`，分别观察它们的返回值，发现`'1'`是数字字符串，在 `valueOf` 和 `toString` 方法后返回的还是`'1'`本身，即进行字符串拼接，得到打印结果`'11'`。\n\n当你理解透彻后很容易得到：\n\n```js\nconsole.log(1 + null); //1\nconsole.log([] + []); //''\nconsole.log([] + {}); //'[object Object]'\nconsole.log({} + {}); //'[object Object][object Object]'\n```\n\n# 最后\n\n**当你读到这段话时，你已经跨过了 JS 类型转换这一座大山！**\n\n希望这篇文章能够为你提供帮助，如果你还有不懂之处，可以反复阅读，或者在评论区留言，学习是一个循序渐进，敢于试错的过程，我们顶峰相见！\n","source":"_posts/看了一天官方文档，终于搞懂了类型转换机制.md","raw":"---\ntitle: 看了一天官方文档，终于搞懂了类型转换机制\ndate: 2023-12-03 16:00:00\ntags: [JavaScript]\ncategories: JavaScript\nindex_img: /img/default.png\nbanner_img: /img/default.png\n---\n\n> JS 数据类型的转换机制是是学习 JS 过程中的一大难点，一度成为初学者面临的巨大挑战，这一复杂性往往源于 JS 的灵活性和动态性，使得在不同的上下文中，同一个值可能被解释为不同的数据类型。\n\n本文将针从底层出发，借助官方文档，深度剖析 JS 类型转换机制。\n\n## JS 中的数据类型\n\n首先我们回忆一下 JS 中的数据类型。\n\n```js\n//基本数据类型\nlet num = 123; //数字\nlet str = \"hello world\"; //字符串\nlet flag = true; //布尔\nlet un = undefined; //未定义\nlet nu = null; //空值\nlet bigint = 9007199254740991n; //大整数\nlet sy = Symbol(\"symbol\"); //符号\n\n//引用数据类型\nvar person = {\n  //对象\n  name: \"John\",\n  age: 30,\n  isStudent: false,\n  hobbies: [\"reading\", \"coding\"],\n};\nvar numbers = [1, 2, 3, 4, 5]; //数组\nfunction foo() {\n  //函数\n  return \"你好！掘友\";\n}\n//等等\n```\n\n## 类型转换\n\nJS 类型转换主要分为两种：**隐式类型转换**和**显式类型转换**。\n\n> **1. 隐式类型转换**：在隐式类型转换中，JS 引擎自动地将一种数据类型转换为另一种类型，通常发生在运算或比较的过程中。这种转换是隐式的，开发者不需要明确地进行操作，而是由 JS 引擎在必要的时候自动完成。\n>\n> **2. 显式类型转换**：显式类型转换是由开发者明确指定的类型转换，通过调用相应的转换函数或使用一些特定的语法进行。这种转换是开发者有意识地进行的，用于确保数据在特定上下文中具有期望的类型。\n\n看到这你可能还是一头雾水，举个例子：\n\n```js\nvar a = 12;\nvar b = a + \"\"; //隐式类型转换\nvar c = String(a); //显式类型转换\n```\n\n在这里，隐式强制类型转换发生在变量 `a` 被赋值给变量 `b` 的过程中。通过将 `a` 与一个空字符串 `\"\"` 相加，JS 引擎会自动将 `a` 的值转换为字符串，然后与空字符串拼接在一起。这是一种常见的将数字转换为字符串的方式，是隐式的，因为你并没有明确指示进行类型转换。\n\n而显式强制类型转换通过调用 `String()` 函数来实现。你明确告诉 JS 引擎将变量 `a` 的值转换为字符串。这种方式更加明显，开发者有意识地进行了类型转换。\n\n总体而言，这两种方式都能将数字 `12` 转换为字符串，但发生的时机和方式略有不同。隐式转换是在某些操作中自动进行的，而显式转换是由开发者明确调用的。\n\n下面我们分别对这两种类型转换展开分析。\n\n## 显示转换\n\n我们通常使用官方定义的 `Number()`、`String()`、`Boolean()` 等函数进行显示转换，这些函数提供了明确的方式将值转换为特定的数据类型。\n\n### 原始值转其他类型\n\n#### 1. 原始值转换成布尔值\n\n```js\nconsole.log(Boolean()); // false\nconsole.log(Boolean(1)); // true\nconsole.log(Boolean(0)); // false\nconsole.log(Boolean(-1)); // true\nconsole.log(Boolean(undefined)); // false\nconsole.log(Boolean(null)); // false\nconsole.log(Boolean(\"123\")); // true\nconsole.log(Boolean(\"\")); // false\nconsole.log(Boolean(\" \")); // true\n```\n\n见官方文档 9.2：[Annotated ES5 9.2](https://es5.github.io/#x9.2)\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0af248dc983341429de2033138eaa78b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=961&h=426&s=35352&e=png&b=fafafa)\n\n简而言之：\n\n> - `false`、`0`、`''`、`null`、`undefined`以及`NaN`转换为`false`\n> - 其他所有值转换为`true`\n\n#### 2. 原始值转换成数字\n\n```js\nconsole.log(Number(\"123\")); //123\nconsole.log(Number(\"abc\")); //NaN\nconsole.log(Number()); //0\nconsole.log(Number(true)); //1\nconsole.log(Number(false)); //0\nconsole.log(Number(null)); //0\nconsole.log(Number(undefined)); //NaN\n```\n\n见官方文档 9.3：[Annotated ES5 9.3](https://es5.github.io/#x9.3)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fbe5f577d424fd38e3f14ccb2d4e72c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=945&h=518&s=35867&e=png&b=fbfbfb)\n\n大概的意思就是：\n\n> - 如果是数字字符串，则转换为对应的数字。\n> - 如果是非数字字符串或无法解析为数字的字符串，则转换为 `NaN`。\n> - 布尔值 `true` 被转换为 `1`，`false` 被转换为 `0`。\n> - `null` 被转换为 `0`。\n> - `undefined` 被转换为 `NaN`。\n\n其中，对象转数字规则没有罗列，我们将在后文对 对象类型（Object）转数字类型进行着重分析。\n\n#### 3. 原始值转换成字符串\n\n```js\nconsole.log(String()); //''\nconsole.log(String(123)); //'123'\nconsole.log(String(NaN)); //'NaN'\nconsole.log(String(undefined)); //'undefined'\nconsole.log(String(null)); //'null'\nconsole.log(String(true)); //'true'\n```\n\n- 空值或没有提供参数时，返回空字符串。\n- 数字转字符串：直接将数字转换为对应的字符串形式。\n- `NaN` 被转换为字符串 `'NaN'`。\n- 布尔值转字符串：`true` 转换为 `\"true\"`，`false` 转换为 `\"false\"`。\n- `null` 转换为字符串 `\"null\"`。\n- `undefined` 转换为 `\"undefined\"`。\n\n见官方文档 9.8：[Annotated ES5 9.8](https://es5.github.io/#x9.8)\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdbfe41b559f47029bdc769028fbee4a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=920&h=447&s=32790&e=png&b=f9f9f9)\n\n#### 4. 原始值转对象\n\n原始数据类型可以通过其对应的包装对象来实现转换，例如：\n\n```js\nconsole.log(Object(true)); //[Boolean: true]\nconsole.log(Object(123)); //[Number: 123]\nconsole.log(Object(\"123\")); //[String: '123']\nconsole.log(Object(undefined)); //{}\nconsole.log(Object(null)); //{}\n```\n\n见官方文档 9.9：[Annotated ES5 9.9](https://es5.github.io/#x9.9)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdc53305afb2424cb0e7a0e841465472~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=996&h=548&s=49999&e=png&b=fbfbfb)\n\n> - 布尔值、数字、字符串分别被转换为对应的 Boolean、Number、String 对象。\n> - 对于 `undefined`，使用 `Object()` 转换为一个空对象 `{}`。\n> - 对于 `null`，同样使用 `Object()` 转换为一个空对象 `{}`。\n\n以上就是原始值转换数据类型的官方解释，我们不用过多考虑，只需要无脑接受就好。\n\n当我们要用到的时候，查下这个表就行了。\n\n![67fab372c578caf931014f18b425317.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3feba050341e49e6bba8861a728f1e09~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1080&h=1017&s=508208&e=png&b=f9f9f9)\n\n因为官方没有给`Null`和`Undefined`定义显示转换的方法，所以我们暂且不聊。\n\n然而以上这些内容都不是本文的重点，我们的重点是**对象转换成原始值的过程**，好戏才刚刚开始。\n\n### 对象转原始值\n\n对象转`Null`与`Undefined`没有意义，所以我们只聊对象转字符串、数字和布尔值。\n\n#### 1. 对象转数字\n\n这时候我们再打开官方文档，回到之前铺垫的位置，如果转换的对象为对象类型的话，会进行红框中的操作。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10958fa5d33f4b7b8557883c5176f978~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=960&h=534&s=49735&e=png&b=fafafa)\n\n大概意思是，你传入一个值，经过`ToPrimitive`这样一个函数的调用并返回一个值，这个值会被转换成数字类型，我们可以通过文档（[Annotated ES5 9.3](https://es5.github.io/#x9.3)）进入到`ToPrimitive`这个函数内部。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55bb6b70e0bb4147a00488b3060777ad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=969&h=492&s=65356&e=png&b=faf9f9)\n\n看不懂，出国留学一下······\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff31030419fb4575b899dd3522e72015~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=914&h=917&s=99856&e=png&b=faf9f9)\n\n意思很明了，当你传入的是基本数据类型的时候，不会进行转换。唯独传入的是对象（Object）的时候才会有进行转换，它会调用对象的 \\[\\[DefaultValue\\]\\] 内部方法，于是我们跟随文档，跳到 8.12.8 。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b33ac07060264691b7c788826ed93ea1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1321&h=877&s=127585&e=png&b=ffffff)\n\n翻译就不给大家看了，直接告诉大家它什么意思吧。\n\n`ToPrimitive(obj, Number)` 是 ECMAScript 规范中描述的一种抽象操作，用于将给定对象 `obj` 转换为一个原始值，在进行数据转换的时候才会触发。这里我们目标是要将对象转换成数字，所以第二个参数是`Number`，字符串则是`String`。\n\n下面是 `ToPrimitive(obj, Number)` 的执行步骤：\n\n1.  **如果 `obj` 是基本类型：**\n\n    - 如果 `obj` 已经是基本类型（例如数字、字符串、布尔值等），那么直接返回 `obj`。\n\n1.  **否则，调用 `valueOf` 方法：**\n\n    - 如果 `obj` 不是基本类型，即它是一个对象，首先会尝试调用 `valueOf` 方法。\n    - 如果 `valueOf` 方法存在并返回一个原始值，那么返回这个原始值。\n\n1.  **否则，调用 `toString` 方法：**\n\n    - 如果 `valueOf` 方法不存在，或者它返回的仍然是一个对象，那么接下来会调用 `toString` 方法。\n    - 如果 `toString` 方法存在并返回一个原始值，那么返回这个原始值。\n\n1.  **否则，报错：**\n\n    - 如果 `toString` 方法也不存在，或者它返回的仍然是一个对象，那么就无法将对象转换为原始值，此时会抛出一个错误。\n\n简化一下：\n\n> ToPrimitive(obj, Number) ==> Number({})\n>\n> 1. 如果 obj 是基本类型，直接返回\n> 2. 否则，调用 valueOf 方法，如果得到原始值，则返回\n> 3. 否则，调用 toString 方法，如果得到原始值，则返回\n> 4. 否则，报错\n\n这就相当于一个公式，当我们在将一个对象转换成数字类型的时候，直接套就行。\n\n举个例子：\n\n```js\na = {};\nconsole.log(Number(a)); //NaN\n```\n\n开始套公式：\n\n1.  **如果 `a` 是基本类型：**\n\n    - `a` 是一个对象，不是基本类型。\n\n1.  **调用 `valueOf` 方法：**\n\n    - 尝试调用 `valueOf` 方法，看是否可以获取到原始值。\n    - 由于 `a` 是一个空对象 `{}`，而普通的对象（没有重写 `valueOf` 方法的情况下）的 `valueOf` 方法会返回对象本身，而不是一个原始值。\n\n1.  **调用 `toString` 方法：**\n\n    - 由于 `valueOf` 方法没有返回原始值，接下来调用 `toString` 方法。\n    - 对于普通的空对象 `{}`，`toString` 方法通常会返回 `\"[object Object]\"` 字符串。\n\n调用`toString`方法的时候得到了原始值字符串`\"[object Object]\"`，于是`ToPrimitive`这个函数将其返回，最后就相当于 `Number(\"[object Object]\")` 执行了这段代码。在 JS 引擎内部，`ToPrimitive`这个函数相当于进行了将 `Number(a)` 转化成了 `Number(\"[object Object]\")` ，相当于将字符串转换成数字，所以最终打印结果为 `NaN`。\n\n#### 2. 对象转字符串\n\n与对象转数字类似，唯一的区别就是转字符串时在`ToPrimitive`函数中是先调用 `toString` 方法，后调用 `typeOf` 方法。\n\n> ToPrimitive(obj, String) ==> String({})\n>\n> 1. 如果 obj 是基本类型，直接返回\n> 2. 否则，调用 toString 方法，如果得到原始值，则返回\n> 3. 否则，调用 valueOf 方法，如果得到原始值，则返回\n> 4. 否则，报错\n\n与对象转数字用法一致，区别在于调用 `toString` 方法和 `valueOf` 方法的顺序，区分这一点就行了。\n\n#### 3. 对象转布尔\n\n```js\nconsole.log(Boolean({})); // true\nconsole.log(Boolean([])); // true\n```\n\n对象转换为布尔值时，结果总是 `true`。\n\n---\n\n## 隐式转换\n\n隐式转换通常发生在一些运算符操作中，其中一些运算符会触发 JS 引擎自动进行类型转换以满足操作的要求。下面我们简单聊一下 `+` 这个运算符。\n\n### 一元运算 `+ a`\n\n官方文档（[Annotated ES5 11.4.6](https://es5.github.io/#x11.4.6)）这样描述：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29819bbe7e4740fcb2dfa3bfa015d5c5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=800&h=216&s=23157&e=png&b=ffffff)\n\n如果遇到 `+` 号，且它是当作一元运算符来使用，那么 `+` 号后面的数据一定要被强制转化为 `Number` 类型。\n\n举个例子：\n\n```js\nconsole.log(+\"1\"); //1\n```\n\n这个例子中， `+` 后面接的是数字字符串，则转换成对应数字，所以打印结果为`1`，没问题。\n\n那么 `+` 后面接的是对象类型呢，我们再举个例子：\n\n```js\nconsole.log(+{}); //NaN\n```\n\n这个例子中， `+` 后面接的是一个空对象，那么对象怎么转换成`Number`呢，是不是要走`ToPrimitive`函数那一套哇，直接套公式就行了。\n\n我直接搬过来：\n\n> ToPrimitive(obj, Number) ==> Number({})\n>\n> 1. 如果 obj 是基本类型，直接返回\n> 2. 否则，调用 valueOf 方法，如果得到原始值，则返回\n> 3. 否则，调用 toString 方法，如果得到原始值，则返回\n> 4. 否则，报错\n\n我们前面已经走过一遍流程了，这个`ToPrimitive`函数最后会返回一个`\"[object Object]\"`字符串，所以最终就相当于 `+` 后面接的是一个字符串，则转换成 `NaN` ，打印结果也为 `NaN`，没问题。\n\n我们也可以试着模拟一下整个过程：\n\n```js\n// +{} 的过程模拟\nconsole.log(+{}); //0\nconsole.log({}.valueOf()); //{}\nconsole.log({}.toString()); //\"[object Object]\"\n//返回\"[object Object]\"字符串\nconsole.log(Number(\"[object Object]\")); //NaN\n```\n\n### 二元运算 `a + b`\n\n官方文档（[Annotated ES5 11.6.1](https://es5.github.io/#x11.6.1)）这样描述：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ba8415ad2d24e2e8d5d150360b2a7e8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1399&h=622&s=85403&e=png&b=ffffff)\n\n二元运算符 `+` 可以执行字符串连接，也可以执行数字加法。简而言之，将 `+` 左右两边的数据分别用`ToPrimitive`函数调用一遍，如果返回值中有一个是字符串，则进行字符串拼接；否则进行加法运算。\n\n即：\n\n> lprim + rprim == ToPrimitive(v1) + ToPrimitive(v2)\n>\n> 1. 当 + 两边有一个是字符串，则按字符串进行拼接\n> 2. 否则，转到 number 进行计算\n\n举个例子：\n\n```js\nconsole.log(1 + \"1\"); //'11'\n```\n\n我们分别让数字`1`和字符串`'1'`走一遍`ToPrimitive`，分别观察它们的返回值，发现`'1'`是数字字符串，在 `valueOf` 和 `toString` 方法后返回的还是`'1'`本身，即进行字符串拼接，得到打印结果`'11'`。\n\n当你理解透彻后很容易得到：\n\n```js\nconsole.log(1 + null); //1\nconsole.log([] + []); //''\nconsole.log([] + {}); //'[object Object]'\nconsole.log({} + {}); //'[object Object][object Object]'\n```\n\n# 最后\n\n**当你读到这段话时，你已经跨过了 JS 类型转换这一座大山！**\n\n希望这篇文章能够为你提供帮助，如果你还有不懂之处，可以反复阅读，或者在评论区留言，学习是一个循序渐进，敢于试错的过程，我们顶峰相见！\n","slug":"看了一天官方文档，终于搞懂了类型转换机制","published":1,"updated":"2024-09-09T15:30:47.184Z","_id":"clywvguj90000z0v63aky8kck","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p>JS 数据类型的转换机制是是学习 JS 过程中的一大难点，一度成为初学者面临的巨大挑战，这一复杂性往往源于 JS 的灵活性和动态性，使得在不同的上下文中，同一个值可能被解释为不同的数据类型。</p>\n</blockquote>\n<p>本文将针从底层出发，借助官方文档，深度剖析 JS 类型转换机制。</p>\n<h2 id=\"JS-中的数据类型\"><a href=\"#JS-中的数据类型\" class=\"headerlink\" title=\"JS 中的数据类型\"></a>JS 中的数据类型</h2><p>首先我们回忆一下 JS 中的数据类型。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//基本数据类型</span><br><span class=\"hljs-keyword\">let</span> num = <span class=\"hljs-number\">123</span>; <span class=\"hljs-comment\">//数字</span><br><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&quot;hello world&quot;</span>; <span class=\"hljs-comment\">//字符串</span><br><span class=\"hljs-keyword\">let</span> flag = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">//布尔</span><br><span class=\"hljs-keyword\">let</span> un = <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">//未定义</span><br><span class=\"hljs-keyword\">let</span> nu = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">//空值</span><br><span class=\"hljs-keyword\">let</span> bigint = <span class=\"hljs-number\">9007199254740991n</span>; <span class=\"hljs-comment\">//大整数</span><br><span class=\"hljs-keyword\">let</span> sy = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&quot;symbol&quot;</span>); <span class=\"hljs-comment\">//符号</span><br><br><span class=\"hljs-comment\">//引用数据类型</span><br><span class=\"hljs-keyword\">var</span> person = &#123;<br>  <span class=\"hljs-comment\">//对象</span><br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;John&quot;</span>,<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">30</span>,<br>  <span class=\"hljs-attr\">isStudent</span>: <span class=\"hljs-literal\">false</span>,<br>  <span class=\"hljs-attr\">hobbies</span>: [<span class=\"hljs-string\">&quot;reading&quot;</span>, <span class=\"hljs-string\">&quot;coding&quot;</span>],<br>&#125;;<br><span class=\"hljs-keyword\">var</span> numbers = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]; <span class=\"hljs-comment\">//数组</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-comment\">//函数</span><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;你好！掘友&quot;</span>;<br>&#125;<br><span class=\"hljs-comment\">//等等</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><p>JS 类型转换主要分为两种：<strong>隐式类型转换</strong>和<strong>显式类型转换</strong>。</p>\n<blockquote>\n<p><strong>1. 隐式类型转换</strong>：在隐式类型转换中，JS 引擎自动地将一种数据类型转换为另一种类型，通常发生在运算或比较的过程中。这种转换是隐式的，开发者不需要明确地进行操作，而是由 JS 引擎在必要的时候自动完成。</p>\n<p><strong>2. 显式类型转换</strong>：显式类型转换是由开发者明确指定的类型转换，通过调用相应的转换函数或使用一些特定的语法进行。这种转换是开发者有意识地进行的，用于确保数据在特定上下文中具有期望的类型。</p>\n</blockquote>\n<p>看到这你可能还是一头雾水，举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">12</span>;<br><span class=\"hljs-keyword\">var</span> b = a + <span class=\"hljs-string\">&quot;&quot;</span>; <span class=\"hljs-comment\">//隐式类型转换</span><br><span class=\"hljs-keyword\">var</span> c = <span class=\"hljs-title class_\">String</span>(a); <span class=\"hljs-comment\">//显式类型转换</span><br></code></pre></td></tr></table></figure>\n\n<p>在这里，隐式强制类型转换发生在变量 <code>a</code> 被赋值给变量 <code>b</code> 的过程中。通过将 <code>a</code> 与一个空字符串 <code>&quot;&quot;</code> 相加，JS 引擎会自动将 <code>a</code> 的值转换为字符串，然后与空字符串拼接在一起。这是一种常见的将数字转换为字符串的方式，是隐式的，因为你并没有明确指示进行类型转换。</p>\n<p>而显式强制类型转换通过调用 <code>String()</code> 函数来实现。你明确告诉 JS 引擎将变量 <code>a</code> 的值转换为字符串。这种方式更加明显，开发者有意识地进行了类型转换。</p>\n<p>总体而言，这两种方式都能将数字 <code>12</code> 转换为字符串，但发生的时机和方式略有不同。隐式转换是在某些操作中自动进行的，而显式转换是由开发者明确调用的。</p>\n<p>下面我们分别对这两种类型转换展开分析。</p>\n<h2 id=\"显示转换\"><a href=\"#显示转换\" class=\"headerlink\" title=\"显示转换\"></a>显示转换</h2><p>我们通常使用官方定义的 <code>Number()</code>、<code>String()</code>、<code>Boolean()</code> 等函数进行显示转换，这些函数提供了明确的方式将值转换为特定的数据类型。</p>\n<h3 id=\"原始值转其他类型\"><a href=\"#原始值转其他类型\" class=\"headerlink\" title=\"原始值转其他类型\"></a>原始值转其他类型</h3><h4 id=\"1-原始值转换成布尔值\"><a href=\"#1-原始值转换成布尔值\" class=\"headerlink\" title=\"1. 原始值转换成布尔值\"></a>1. 原始值转换成布尔值</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Boolean</span>()); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Boolean</span>(<span class=\"hljs-number\">1</span>)); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Boolean</span>(<span class=\"hljs-number\">0</span>)); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Boolean</span>(-<span class=\"hljs-number\">1</span>)); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Boolean</span>(<span class=\"hljs-literal\">undefined</span>)); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Boolean</span>(<span class=\"hljs-literal\">null</span>)); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Boolean</span>(<span class=\"hljs-string\">&quot;123&quot;</span>)); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Boolean</span>(<span class=\"hljs-string\">&quot;&quot;</span>)); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Boolean</span>(<span class=\"hljs-string\">&quot; &quot;</span>)); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<p>见官方文档 9.2：<a href=\"https://es5.github.io/#x9.2\">Annotated ES5 9.2</a></p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0af248dc983341429de2033138eaa78b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=961&h=426&s=35352&e=png&b=fafafa\" alt=\"image.png\"></p>\n<p>简而言之：</p>\n<blockquote>\n<ul>\n<li><code>false</code>、<code>0</code>、<code>&#39;&#39;</code>、<code>null</code>、<code>undefined</code>以及<code>NaN</code>转换为<code>false</code></li>\n<li>其他所有值转换为<code>true</code></li>\n</ul>\n</blockquote>\n<h4 id=\"2-原始值转换成数字\"><a href=\"#2-原始值转换成数字\" class=\"headerlink\" title=\"2. 原始值转换成数字\"></a>2. 原始值转换成数字</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Number</span>(<span class=\"hljs-string\">&quot;123&quot;</span>)); <span class=\"hljs-comment\">//123</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Number</span>(<span class=\"hljs-string\">&quot;abc&quot;</span>)); <span class=\"hljs-comment\">//NaN</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Number</span>()); <span class=\"hljs-comment\">//0</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Number</span>(<span class=\"hljs-literal\">true</span>)); <span class=\"hljs-comment\">//1</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Number</span>(<span class=\"hljs-literal\">false</span>)); <span class=\"hljs-comment\">//0</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Number</span>(<span class=\"hljs-literal\">null</span>)); <span class=\"hljs-comment\">//0</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Number</span>(<span class=\"hljs-literal\">undefined</span>)); <span class=\"hljs-comment\">//NaN</span><br></code></pre></td></tr></table></figure>\n\n<p>见官方文档 9.3：<a href=\"https://es5.github.io/#x9.3\">Annotated ES5 9.3</a></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fbe5f577d424fd38e3f14ccb2d4e72c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=945&h=518&s=35867&e=png&b=fbfbfb\" alt=\"image.png\"></p>\n<p>大概的意思就是：</p>\n<blockquote>\n<ul>\n<li>如果是数字字符串，则转换为对应的数字。</li>\n<li>如果是非数字字符串或无法解析为数字的字符串，则转换为 <code>NaN</code>。</li>\n<li>布尔值 <code>true</code> 被转换为 <code>1</code>，<code>false</code> 被转换为 <code>0</code>。</li>\n<li><code>null</code> 被转换为 <code>0</code>。</li>\n<li><code>undefined</code> 被转换为 <code>NaN</code>。</li>\n</ul>\n</blockquote>\n<p>其中，对象转数字规则没有罗列，我们将在后文对 对象类型（Object）转数字类型进行着重分析。</p>\n<h4 id=\"3-原始值转换成字符串\"><a href=\"#3-原始值转换成字符串\" class=\"headerlink\" title=\"3. 原始值转换成字符串\"></a>3. 原始值转换成字符串</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">String</span>()); <span class=\"hljs-comment\">//&#x27;&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">String</span>(<span class=\"hljs-number\">123</span>)); <span class=\"hljs-comment\">//&#x27;123&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">String</span>(<span class=\"hljs-title class_\">NaN</span>)); <span class=\"hljs-comment\">//&#x27;NaN&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">String</span>(<span class=\"hljs-literal\">undefined</span>)); <span class=\"hljs-comment\">//&#x27;undefined&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">String</span>(<span class=\"hljs-literal\">null</span>)); <span class=\"hljs-comment\">//&#x27;null&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">String</span>(<span class=\"hljs-literal\">true</span>)); <span class=\"hljs-comment\">//&#x27;true&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>空值或没有提供参数时，返回空字符串。</li>\n<li>数字转字符串：直接将数字转换为对应的字符串形式。</li>\n<li><code>NaN</code> 被转换为字符串 <code>&#39;NaN&#39;</code>。</li>\n<li>布尔值转字符串：<code>true</code> 转换为 <code>&quot;true&quot;</code>，<code>false</code> 转换为 <code>&quot;false&quot;</code>。</li>\n<li><code>null</code> 转换为字符串 <code>&quot;null&quot;</code>。</li>\n<li><code>undefined</code> 转换为 <code>&quot;undefined&quot;</code>。</li>\n</ul>\n<p>见官方文档 9.8：<a href=\"https://es5.github.io/#x9.8\">Annotated ES5 9.8</a></p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdbfe41b559f47029bdc769028fbee4a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=920&h=447&s=32790&e=png&b=f9f9f9\" alt=\"image.png\"></p>\n<h4 id=\"4-原始值转对象\"><a href=\"#4-原始值转对象\" class=\"headerlink\" title=\"4. 原始值转对象\"></a>4. 原始值转对象</h4><p>原始数据类型可以通过其对应的包装对象来实现转换，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>(<span class=\"hljs-literal\">true</span>)); <span class=\"hljs-comment\">//[Boolean: true]</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>(<span class=\"hljs-number\">123</span>)); <span class=\"hljs-comment\">//[Number: 123]</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>(<span class=\"hljs-string\">&quot;123&quot;</span>)); <span class=\"hljs-comment\">//[String: &#x27;123&#x27;]</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>(<span class=\"hljs-literal\">undefined</span>)); <span class=\"hljs-comment\">//&#123;&#125;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>(<span class=\"hljs-literal\">null</span>)); <span class=\"hljs-comment\">//&#123;&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>见官方文档 9.9：<a href=\"https://es5.github.io/#x9.9\">Annotated ES5 9.9</a></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdc53305afb2424cb0e7a0e841465472~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=996&h=548&s=49999&e=png&b=fbfbfb\" alt=\"image.png\"></p>\n<blockquote>\n<ul>\n<li>布尔值、数字、字符串分别被转换为对应的 Boolean、Number、String 对象。</li>\n<li>对于 <code>undefined</code>，使用 <code>Object()</code> 转换为一个空对象 <code>&#123;&#125;</code>。</li>\n<li>对于 <code>null</code>，同样使用 <code>Object()</code> 转换为一个空对象 <code>&#123;&#125;</code>。</li>\n</ul>\n</blockquote>\n<p>以上就是原始值转换数据类型的官方解释，我们不用过多考虑，只需要无脑接受就好。</p>\n<p>当我们要用到的时候，查下这个表就行了。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3feba050341e49e6bba8861a728f1e09~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1080&h=1017&s=508208&e=png&b=f9f9f9\" alt=\"67fab372c578caf931014f18b425317.png\"></p>\n<p>因为官方没有给<code>Null</code>和<code>Undefined</code>定义显示转换的方法，所以我们暂且不聊。</p>\n<p>然而以上这些内容都不是本文的重点，我们的重点是<strong>对象转换成原始值的过程</strong>，好戏才刚刚开始。</p>\n<h3 id=\"对象转原始值\"><a href=\"#对象转原始值\" class=\"headerlink\" title=\"对象转原始值\"></a>对象转原始值</h3><p>对象转<code>Null</code>与<code>Undefined</code>没有意义，所以我们只聊对象转字符串、数字和布尔值。</p>\n<h4 id=\"1-对象转数字\"><a href=\"#1-对象转数字\" class=\"headerlink\" title=\"1. 对象转数字\"></a>1. 对象转数字</h4><p>这时候我们再打开官方文档，回到之前铺垫的位置，如果转换的对象为对象类型的话，会进行红框中的操作。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10958fa5d33f4b7b8557883c5176f978~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=960&h=534&s=49735&e=png&b=fafafa\" alt=\"image.png\"></p>\n<p>大概意思是，你传入一个值，经过<code>ToPrimitive</code>这样一个函数的调用并返回一个值，这个值会被转换成数字类型，我们可以通过文档（<a href=\"https://es5.github.io/#x9.3\">Annotated ES5 9.3</a>）进入到<code>ToPrimitive</code>这个函数内部。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55bb6b70e0bb4147a00488b3060777ad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=969&h=492&s=65356&e=png&b=faf9f9\" alt=\"image.png\"></p>\n<p>看不懂，出国留学一下······</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff31030419fb4575b899dd3522e72015~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=914&h=917&s=99856&e=png&b=faf9f9\" alt=\"image.png\"></p>\n<p>意思很明了，当你传入的是基本数据类型的时候，不会进行转换。唯独传入的是对象（Object）的时候才会有进行转换，它会调用对象的 [[DefaultValue]] 内部方法，于是我们跟随文档，跳到 8.12.8 。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b33ac07060264691b7c788826ed93ea1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1321&h=877&s=127585&e=png&b=ffffff\" alt=\"image.png\"></p>\n<p>翻译就不给大家看了，直接告诉大家它什么意思吧。</p>\n<p><code>ToPrimitive(obj, Number)</code> 是 ECMAScript 规范中描述的一种抽象操作，用于将给定对象 <code>obj</code> 转换为一个原始值，在进行数据转换的时候才会触发。这里我们目标是要将对象转换成数字，所以第二个参数是<code>Number</code>，字符串则是<code>String</code>。</p>\n<p>下面是 <code>ToPrimitive(obj, Number)</code> 的执行步骤：</p>\n<ol>\n<li><p><strong>如果 <code>obj</code> 是基本类型：</strong></p>\n<ul>\n<li>如果 <code>obj</code> 已经是基本类型（例如数字、字符串、布尔值等），那么直接返回 <code>obj</code>。</li>\n</ul>\n</li>\n<li><p><strong>否则，调用 <code>valueOf</code> 方法：</strong></p>\n<ul>\n<li>如果 <code>obj</code> 不是基本类型，即它是一个对象，首先会尝试调用 <code>valueOf</code> 方法。</li>\n<li>如果 <code>valueOf</code> 方法存在并返回一个原始值，那么返回这个原始值。</li>\n</ul>\n</li>\n<li><p><strong>否则，调用 <code>toString</code> 方法：</strong></p>\n<ul>\n<li>如果 <code>valueOf</code> 方法不存在，或者它返回的仍然是一个对象，那么接下来会调用 <code>toString</code> 方法。</li>\n<li>如果 <code>toString</code> 方法存在并返回一个原始值，那么返回这个原始值。</li>\n</ul>\n</li>\n<li><p><strong>否则，报错：</strong></p>\n<ul>\n<li>如果 <code>toString</code> 方法也不存在，或者它返回的仍然是一个对象，那么就无法将对象转换为原始值，此时会抛出一个错误。</li>\n</ul>\n</li>\n</ol>\n<p>简化一下：</p>\n<blockquote>\n<p>ToPrimitive(obj, Number) &#x3D;&#x3D;&gt; Number({})</p>\n<ol>\n<li>如果 obj 是基本类型，直接返回</li>\n<li>否则，调用 valueOf 方法，如果得到原始值，则返回</li>\n<li>否则，调用 toString 方法，如果得到原始值，则返回</li>\n<li>否则，报错</li>\n</ol>\n</blockquote>\n<p>这就相当于一个公式，当我们在将一个对象转换成数字类型的时候，直接套就行。</p>\n<p>举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">a = &#123;&#125;;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Number</span>(a)); <span class=\"hljs-comment\">//NaN</span><br></code></pre></td></tr></table></figure>\n\n<p>开始套公式：</p>\n<ol>\n<li><p><strong>如果 <code>a</code> 是基本类型：</strong></p>\n<ul>\n<li><code>a</code> 是一个对象，不是基本类型。</li>\n</ul>\n</li>\n<li><p><strong>调用 <code>valueOf</code> 方法：</strong></p>\n<ul>\n<li>尝试调用 <code>valueOf</code> 方法，看是否可以获取到原始值。</li>\n<li>由于 <code>a</code> 是一个空对象 <code>&#123;&#125;</code>，而普通的对象（没有重写 <code>valueOf</code> 方法的情况下）的 <code>valueOf</code> 方法会返回对象本身，而不是一个原始值。</li>\n</ul>\n</li>\n<li><p><strong>调用 <code>toString</code> 方法：</strong></p>\n<ul>\n<li>由于 <code>valueOf</code> 方法没有返回原始值，接下来调用 <code>toString</code> 方法。</li>\n<li>对于普通的空对象 <code>&#123;&#125;</code>，<code>toString</code> 方法通常会返回 <code>&quot;[object Object]&quot;</code> 字符串。</li>\n</ul>\n</li>\n</ol>\n<p>调用<code>toString</code>方法的时候得到了原始值字符串<code>&quot;[object Object]&quot;</code>，于是<code>ToPrimitive</code>这个函数将其返回，最后就相当于 <code>Number(&quot;[object Object]&quot;)</code> 执行了这段代码。在 JS 引擎内部，<code>ToPrimitive</code>这个函数相当于进行了将 <code>Number(a)</code> 转化成了 <code>Number(&quot;[object Object]&quot;)</code> ，相当于将字符串转换成数字，所以最终打印结果为 <code>NaN</code>。</p>\n<h4 id=\"2-对象转字符串\"><a href=\"#2-对象转字符串\" class=\"headerlink\" title=\"2. 对象转字符串\"></a>2. 对象转字符串</h4><p>与对象转数字类似，唯一的区别就是转字符串时在<code>ToPrimitive</code>函数中是先调用 <code>toString</code> 方法，后调用 <code>typeOf</code> 方法。</p>\n<blockquote>\n<p>ToPrimitive(obj, String) &#x3D;&#x3D;&gt; String({})</p>\n<ol>\n<li>如果 obj 是基本类型，直接返回</li>\n<li>否则，调用 toString 方法，如果得到原始值，则返回</li>\n<li>否则，调用 valueOf 方法，如果得到原始值，则返回</li>\n<li>否则，报错</li>\n</ol>\n</blockquote>\n<p>与对象转数字用法一致，区别在于调用 <code>toString</code> 方法和 <code>valueOf</code> 方法的顺序，区分这一点就行了。</p>\n<h4 id=\"3-对象转布尔\"><a href=\"#3-对象转布尔\" class=\"headerlink\" title=\"3. 对象转布尔\"></a>3. 对象转布尔</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Boolean</span>(&#123;&#125;)); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Boolean</span>([])); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<p>对象转换为布尔值时，结果总是 <code>true</code>。</p>\n<hr>\n<h2 id=\"隐式转换\"><a href=\"#隐式转换\" class=\"headerlink\" title=\"隐式转换\"></a>隐式转换</h2><p>隐式转换通常发生在一些运算符操作中，其中一些运算符会触发 JS 引擎自动进行类型转换以满足操作的要求。下面我们简单聊一下 <code>+</code> 这个运算符。</p>\n<h3 id=\"一元运算-a\"><a href=\"#一元运算-a\" class=\"headerlink\" title=\"一元运算 + a\"></a>一元运算 <code>+ a</code></h3><p>官方文档（<a href=\"https://es5.github.io/#x11.4.6\">Annotated ES5 11.4.6</a>）这样描述：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29819bbe7e4740fcb2dfa3bfa015d5c5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=800&h=216&s=23157&e=png&b=ffffff\" alt=\"image.png\"></p>\n<p>如果遇到 <code>+</code> 号，且它是当作一元运算符来使用，那么 <code>+</code> 号后面的数据一定要被强制转化为 <code>Number</code> 类型。</p>\n<p>举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(+<span class=\"hljs-string\">&quot;1&quot;</span>); <span class=\"hljs-comment\">//1</span><br></code></pre></td></tr></table></figure>\n\n<p>这个例子中， <code>+</code> 后面接的是数字字符串，则转换成对应数字，所以打印结果为<code>1</code>，没问题。</p>\n<p>那么 <code>+</code> 后面接的是对象类型呢，我们再举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(+&#123;&#125;); <span class=\"hljs-comment\">//NaN</span><br></code></pre></td></tr></table></figure>\n\n<p>这个例子中， <code>+</code> 后面接的是一个空对象，那么对象怎么转换成<code>Number</code>呢，是不是要走<code>ToPrimitive</code>函数那一套哇，直接套公式就行了。</p>\n<p>我直接搬过来：</p>\n<blockquote>\n<p>ToPrimitive(obj, Number) &#x3D;&#x3D;&gt; Number({})</p>\n<ol>\n<li>如果 obj 是基本类型，直接返回</li>\n<li>否则，调用 valueOf 方法，如果得到原始值，则返回</li>\n<li>否则，调用 toString 方法，如果得到原始值，则返回</li>\n<li>否则，报错</li>\n</ol>\n</blockquote>\n<p>我们前面已经走过一遍流程了，这个<code>ToPrimitive</code>函数最后会返回一个<code>&quot;[object Object]&quot;</code>字符串，所以最终就相当于 <code>+</code> 后面接的是一个字符串，则转换成 <code>NaN</code> ，打印结果也为 <code>NaN</code>，没问题。</p>\n<p>我们也可以试着模拟一下整个过程：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// +&#123;&#125; 的过程模拟</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(+&#123;&#125;); <span class=\"hljs-comment\">//0</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(&#123;&#125;.<span class=\"hljs-title function_\">valueOf</span>()); <span class=\"hljs-comment\">//&#123;&#125;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(&#123;&#125;.<span class=\"hljs-title function_\">toString</span>()); <span class=\"hljs-comment\">//&quot;[object Object]&quot;</span><br><span class=\"hljs-comment\">//返回&quot;[object Object]&quot;字符串</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Number</span>(<span class=\"hljs-string\">&quot;[object Object]&quot;</span>)); <span class=\"hljs-comment\">//NaN</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"二元运算-a-b\"><a href=\"#二元运算-a-b\" class=\"headerlink\" title=\"二元运算 a + b\"></a>二元运算 <code>a + b</code></h3><p>官方文档（<a href=\"https://es5.github.io/#x11.6.1\">Annotated ES5 11.6.1</a>）这样描述：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ba8415ad2d24e2e8d5d150360b2a7e8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1399&h=622&s=85403&e=png&b=ffffff\" alt=\"image.png\"></p>\n<p>二元运算符 <code>+</code> 可以执行字符串连接，也可以执行数字加法。简而言之，将 <code>+</code> 左右两边的数据分别用<code>ToPrimitive</code>函数调用一遍，如果返回值中有一个是字符串，则进行字符串拼接；否则进行加法运算。</p>\n<p>即：</p>\n<blockquote>\n<p>lprim + rprim &#x3D;&#x3D; ToPrimitive(v1) + ToPrimitive(v2)</p>\n<ol>\n<li>当 + 两边有一个是字符串，则按字符串进行拼接</li>\n<li>否则，转到 number 进行计算</li>\n</ol>\n</blockquote>\n<p>举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">1</span> + <span class=\"hljs-string\">&quot;1&quot;</span>); <span class=\"hljs-comment\">//&#x27;11&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>我们分别让数字<code>1</code>和字符串<code>&#39;1&#39;</code>走一遍<code>ToPrimitive</code>，分别观察它们的返回值，发现<code>&#39;1&#39;</code>是数字字符串，在 <code>valueOf</code> 和 <code>toString</code> 方法后返回的还是<code>&#39;1&#39;</code>本身，即进行字符串拼接，得到打印结果<code>&#39;11&#39;</code>。</p>\n<p>当你理解透彻后很容易得到：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">1</span> + <span class=\"hljs-literal\">null</span>); <span class=\"hljs-comment\">//1</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>([] + []); <span class=\"hljs-comment\">//&#x27;&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>([] + &#123;&#125;); <span class=\"hljs-comment\">//&#x27;[object Object]&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(&#123;&#125; + &#123;&#125;); <span class=\"hljs-comment\">//&#x27;[object Object][object Object]&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p><strong>当你读到这段话时，你已经跨过了 JS 类型转换这一座大山！</strong></p>\n<p>希望这篇文章能够为你提供帮助，如果你还有不懂之处，可以反复阅读，或者在评论区留言，学习是一个循序渐进，敢于试错的过程，我们顶峰相见！</p>\n","excerpt":"","more":"<blockquote>\n<p>JS 数据类型的转换机制是是学习 JS 过程中的一大难点，一度成为初学者面临的巨大挑战，这一复杂性往往源于 JS 的灵活性和动态性，使得在不同的上下文中，同一个值可能被解释为不同的数据类型。</p>\n</blockquote>\n<p>本文将针从底层出发，借助官方文档，深度剖析 JS 类型转换机制。</p>\n<h2 id=\"JS-中的数据类型\"><a href=\"#JS-中的数据类型\" class=\"headerlink\" title=\"JS 中的数据类型\"></a>JS 中的数据类型</h2><p>首先我们回忆一下 JS 中的数据类型。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//基本数据类型</span><br><span class=\"hljs-keyword\">let</span> num = <span class=\"hljs-number\">123</span>; <span class=\"hljs-comment\">//数字</span><br><span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">&quot;hello world&quot;</span>; <span class=\"hljs-comment\">//字符串</span><br><span class=\"hljs-keyword\">let</span> flag = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">//布尔</span><br><span class=\"hljs-keyword\">let</span> un = <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">//未定义</span><br><span class=\"hljs-keyword\">let</span> nu = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">//空值</span><br><span class=\"hljs-keyword\">let</span> bigint = <span class=\"hljs-number\">9007199254740991n</span>; <span class=\"hljs-comment\">//大整数</span><br><span class=\"hljs-keyword\">let</span> sy = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&quot;symbol&quot;</span>); <span class=\"hljs-comment\">//符号</span><br><br><span class=\"hljs-comment\">//引用数据类型</span><br><span class=\"hljs-keyword\">var</span> person = &#123;<br>  <span class=\"hljs-comment\">//对象</span><br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;John&quot;</span>,<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">30</span>,<br>  <span class=\"hljs-attr\">isStudent</span>: <span class=\"hljs-literal\">false</span>,<br>  <span class=\"hljs-attr\">hobbies</span>: [<span class=\"hljs-string\">&quot;reading&quot;</span>, <span class=\"hljs-string\">&quot;coding&quot;</span>],<br>&#125;;<br><span class=\"hljs-keyword\">var</span> numbers = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]; <span class=\"hljs-comment\">//数组</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-comment\">//函数</span><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;你好！掘友&quot;</span>;<br>&#125;<br><span class=\"hljs-comment\">//等等</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><p>JS 类型转换主要分为两种：<strong>隐式类型转换</strong>和<strong>显式类型转换</strong>。</p>\n<blockquote>\n<p><strong>1. 隐式类型转换</strong>：在隐式类型转换中，JS 引擎自动地将一种数据类型转换为另一种类型，通常发生在运算或比较的过程中。这种转换是隐式的，开发者不需要明确地进行操作，而是由 JS 引擎在必要的时候自动完成。</p>\n<p><strong>2. 显式类型转换</strong>：显式类型转换是由开发者明确指定的类型转换，通过调用相应的转换函数或使用一些特定的语法进行。这种转换是开发者有意识地进行的，用于确保数据在特定上下文中具有期望的类型。</p>\n</blockquote>\n<p>看到这你可能还是一头雾水，举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">12</span>;<br><span class=\"hljs-keyword\">var</span> b = a + <span class=\"hljs-string\">&quot;&quot;</span>; <span class=\"hljs-comment\">//隐式类型转换</span><br><span class=\"hljs-keyword\">var</span> c = <span class=\"hljs-title class_\">String</span>(a); <span class=\"hljs-comment\">//显式类型转换</span><br></code></pre></td></tr></table></figure>\n\n<p>在这里，隐式强制类型转换发生在变量 <code>a</code> 被赋值给变量 <code>b</code> 的过程中。通过将 <code>a</code> 与一个空字符串 <code>&quot;&quot;</code> 相加，JS 引擎会自动将 <code>a</code> 的值转换为字符串，然后与空字符串拼接在一起。这是一种常见的将数字转换为字符串的方式，是隐式的，因为你并没有明确指示进行类型转换。</p>\n<p>而显式强制类型转换通过调用 <code>String()</code> 函数来实现。你明确告诉 JS 引擎将变量 <code>a</code> 的值转换为字符串。这种方式更加明显，开发者有意识地进行了类型转换。</p>\n<p>总体而言，这两种方式都能将数字 <code>12</code> 转换为字符串，但发生的时机和方式略有不同。隐式转换是在某些操作中自动进行的，而显式转换是由开发者明确调用的。</p>\n<p>下面我们分别对这两种类型转换展开分析。</p>\n<h2 id=\"显示转换\"><a href=\"#显示转换\" class=\"headerlink\" title=\"显示转换\"></a>显示转换</h2><p>我们通常使用官方定义的 <code>Number()</code>、<code>String()</code>、<code>Boolean()</code> 等函数进行显示转换，这些函数提供了明确的方式将值转换为特定的数据类型。</p>\n<h3 id=\"原始值转其他类型\"><a href=\"#原始值转其他类型\" class=\"headerlink\" title=\"原始值转其他类型\"></a>原始值转其他类型</h3><h4 id=\"1-原始值转换成布尔值\"><a href=\"#1-原始值转换成布尔值\" class=\"headerlink\" title=\"1. 原始值转换成布尔值\"></a>1. 原始值转换成布尔值</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Boolean</span>()); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Boolean</span>(<span class=\"hljs-number\">1</span>)); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Boolean</span>(<span class=\"hljs-number\">0</span>)); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Boolean</span>(-<span class=\"hljs-number\">1</span>)); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Boolean</span>(<span class=\"hljs-literal\">undefined</span>)); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Boolean</span>(<span class=\"hljs-literal\">null</span>)); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Boolean</span>(<span class=\"hljs-string\">&quot;123&quot;</span>)); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Boolean</span>(<span class=\"hljs-string\">&quot;&quot;</span>)); <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Boolean</span>(<span class=\"hljs-string\">&quot; &quot;</span>)); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<p>见官方文档 9.2：<a href=\"https://es5.github.io/#x9.2\">Annotated ES5 9.2</a></p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0af248dc983341429de2033138eaa78b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=961&h=426&s=35352&e=png&b=fafafa\" alt=\"image.png\"></p>\n<p>简而言之：</p>\n<blockquote>\n<ul>\n<li><code>false</code>、<code>0</code>、<code>&#39;&#39;</code>、<code>null</code>、<code>undefined</code>以及<code>NaN</code>转换为<code>false</code></li>\n<li>其他所有值转换为<code>true</code></li>\n</ul>\n</blockquote>\n<h4 id=\"2-原始值转换成数字\"><a href=\"#2-原始值转换成数字\" class=\"headerlink\" title=\"2. 原始值转换成数字\"></a>2. 原始值转换成数字</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Number</span>(<span class=\"hljs-string\">&quot;123&quot;</span>)); <span class=\"hljs-comment\">//123</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Number</span>(<span class=\"hljs-string\">&quot;abc&quot;</span>)); <span class=\"hljs-comment\">//NaN</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Number</span>()); <span class=\"hljs-comment\">//0</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Number</span>(<span class=\"hljs-literal\">true</span>)); <span class=\"hljs-comment\">//1</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Number</span>(<span class=\"hljs-literal\">false</span>)); <span class=\"hljs-comment\">//0</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Number</span>(<span class=\"hljs-literal\">null</span>)); <span class=\"hljs-comment\">//0</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Number</span>(<span class=\"hljs-literal\">undefined</span>)); <span class=\"hljs-comment\">//NaN</span><br></code></pre></td></tr></table></figure>\n\n<p>见官方文档 9.3：<a href=\"https://es5.github.io/#x9.3\">Annotated ES5 9.3</a></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fbe5f577d424fd38e3f14ccb2d4e72c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=945&h=518&s=35867&e=png&b=fbfbfb\" alt=\"image.png\"></p>\n<p>大概的意思就是：</p>\n<blockquote>\n<ul>\n<li>如果是数字字符串，则转换为对应的数字。</li>\n<li>如果是非数字字符串或无法解析为数字的字符串，则转换为 <code>NaN</code>。</li>\n<li>布尔值 <code>true</code> 被转换为 <code>1</code>，<code>false</code> 被转换为 <code>0</code>。</li>\n<li><code>null</code> 被转换为 <code>0</code>。</li>\n<li><code>undefined</code> 被转换为 <code>NaN</code>。</li>\n</ul>\n</blockquote>\n<p>其中，对象转数字规则没有罗列，我们将在后文对 对象类型（Object）转数字类型进行着重分析。</p>\n<h4 id=\"3-原始值转换成字符串\"><a href=\"#3-原始值转换成字符串\" class=\"headerlink\" title=\"3. 原始值转换成字符串\"></a>3. 原始值转换成字符串</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">String</span>()); <span class=\"hljs-comment\">//&#x27;&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">String</span>(<span class=\"hljs-number\">123</span>)); <span class=\"hljs-comment\">//&#x27;123&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">String</span>(<span class=\"hljs-title class_\">NaN</span>)); <span class=\"hljs-comment\">//&#x27;NaN&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">String</span>(<span class=\"hljs-literal\">undefined</span>)); <span class=\"hljs-comment\">//&#x27;undefined&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">String</span>(<span class=\"hljs-literal\">null</span>)); <span class=\"hljs-comment\">//&#x27;null&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">String</span>(<span class=\"hljs-literal\">true</span>)); <span class=\"hljs-comment\">//&#x27;true&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>空值或没有提供参数时，返回空字符串。</li>\n<li>数字转字符串：直接将数字转换为对应的字符串形式。</li>\n<li><code>NaN</code> 被转换为字符串 <code>&#39;NaN&#39;</code>。</li>\n<li>布尔值转字符串：<code>true</code> 转换为 <code>&quot;true&quot;</code>，<code>false</code> 转换为 <code>&quot;false&quot;</code>。</li>\n<li><code>null</code> 转换为字符串 <code>&quot;null&quot;</code>。</li>\n<li><code>undefined</code> 转换为 <code>&quot;undefined&quot;</code>。</li>\n</ul>\n<p>见官方文档 9.8：<a href=\"https://es5.github.io/#x9.8\">Annotated ES5 9.8</a></p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdbfe41b559f47029bdc769028fbee4a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=920&h=447&s=32790&e=png&b=f9f9f9\" alt=\"image.png\"></p>\n<h4 id=\"4-原始值转对象\"><a href=\"#4-原始值转对象\" class=\"headerlink\" title=\"4. 原始值转对象\"></a>4. 原始值转对象</h4><p>原始数据类型可以通过其对应的包装对象来实现转换，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>(<span class=\"hljs-literal\">true</span>)); <span class=\"hljs-comment\">//[Boolean: true]</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>(<span class=\"hljs-number\">123</span>)); <span class=\"hljs-comment\">//[Number: 123]</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>(<span class=\"hljs-string\">&quot;123&quot;</span>)); <span class=\"hljs-comment\">//[String: &#x27;123&#x27;]</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>(<span class=\"hljs-literal\">undefined</span>)); <span class=\"hljs-comment\">//&#123;&#125;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>(<span class=\"hljs-literal\">null</span>)); <span class=\"hljs-comment\">//&#123;&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>见官方文档 9.9：<a href=\"https://es5.github.io/#x9.9\">Annotated ES5 9.9</a></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdc53305afb2424cb0e7a0e841465472~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=996&h=548&s=49999&e=png&b=fbfbfb\" alt=\"image.png\"></p>\n<blockquote>\n<ul>\n<li>布尔值、数字、字符串分别被转换为对应的 Boolean、Number、String 对象。</li>\n<li>对于 <code>undefined</code>，使用 <code>Object()</code> 转换为一个空对象 <code>&#123;&#125;</code>。</li>\n<li>对于 <code>null</code>，同样使用 <code>Object()</code> 转换为一个空对象 <code>&#123;&#125;</code>。</li>\n</ul>\n</blockquote>\n<p>以上就是原始值转换数据类型的官方解释，我们不用过多考虑，只需要无脑接受就好。</p>\n<p>当我们要用到的时候，查下这个表就行了。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3feba050341e49e6bba8861a728f1e09~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1080&h=1017&s=508208&e=png&b=f9f9f9\" alt=\"67fab372c578caf931014f18b425317.png\"></p>\n<p>因为官方没有给<code>Null</code>和<code>Undefined</code>定义显示转换的方法，所以我们暂且不聊。</p>\n<p>然而以上这些内容都不是本文的重点，我们的重点是<strong>对象转换成原始值的过程</strong>，好戏才刚刚开始。</p>\n<h3 id=\"对象转原始值\"><a href=\"#对象转原始值\" class=\"headerlink\" title=\"对象转原始值\"></a>对象转原始值</h3><p>对象转<code>Null</code>与<code>Undefined</code>没有意义，所以我们只聊对象转字符串、数字和布尔值。</p>\n<h4 id=\"1-对象转数字\"><a href=\"#1-对象转数字\" class=\"headerlink\" title=\"1. 对象转数字\"></a>1. 对象转数字</h4><p>这时候我们再打开官方文档，回到之前铺垫的位置，如果转换的对象为对象类型的话，会进行红框中的操作。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10958fa5d33f4b7b8557883c5176f978~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=960&h=534&s=49735&e=png&b=fafafa\" alt=\"image.png\"></p>\n<p>大概意思是，你传入一个值，经过<code>ToPrimitive</code>这样一个函数的调用并返回一个值，这个值会被转换成数字类型，我们可以通过文档（<a href=\"https://es5.github.io/#x9.3\">Annotated ES5 9.3</a>）进入到<code>ToPrimitive</code>这个函数内部。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55bb6b70e0bb4147a00488b3060777ad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=969&h=492&s=65356&e=png&b=faf9f9\" alt=\"image.png\"></p>\n<p>看不懂，出国留学一下······</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff31030419fb4575b899dd3522e72015~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=914&h=917&s=99856&e=png&b=faf9f9\" alt=\"image.png\"></p>\n<p>意思很明了，当你传入的是基本数据类型的时候，不会进行转换。唯独传入的是对象（Object）的时候才会有进行转换，它会调用对象的 [[DefaultValue]] 内部方法，于是我们跟随文档，跳到 8.12.8 。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b33ac07060264691b7c788826ed93ea1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1321&h=877&s=127585&e=png&b=ffffff\" alt=\"image.png\"></p>\n<p>翻译就不给大家看了，直接告诉大家它什么意思吧。</p>\n<p><code>ToPrimitive(obj, Number)</code> 是 ECMAScript 规范中描述的一种抽象操作，用于将给定对象 <code>obj</code> 转换为一个原始值，在进行数据转换的时候才会触发。这里我们目标是要将对象转换成数字，所以第二个参数是<code>Number</code>，字符串则是<code>String</code>。</p>\n<p>下面是 <code>ToPrimitive(obj, Number)</code> 的执行步骤：</p>\n<ol>\n<li><p><strong>如果 <code>obj</code> 是基本类型：</strong></p>\n<ul>\n<li>如果 <code>obj</code> 已经是基本类型（例如数字、字符串、布尔值等），那么直接返回 <code>obj</code>。</li>\n</ul>\n</li>\n<li><p><strong>否则，调用 <code>valueOf</code> 方法：</strong></p>\n<ul>\n<li>如果 <code>obj</code> 不是基本类型，即它是一个对象，首先会尝试调用 <code>valueOf</code> 方法。</li>\n<li>如果 <code>valueOf</code> 方法存在并返回一个原始值，那么返回这个原始值。</li>\n</ul>\n</li>\n<li><p><strong>否则，调用 <code>toString</code> 方法：</strong></p>\n<ul>\n<li>如果 <code>valueOf</code> 方法不存在，或者它返回的仍然是一个对象，那么接下来会调用 <code>toString</code> 方法。</li>\n<li>如果 <code>toString</code> 方法存在并返回一个原始值，那么返回这个原始值。</li>\n</ul>\n</li>\n<li><p><strong>否则，报错：</strong></p>\n<ul>\n<li>如果 <code>toString</code> 方法也不存在，或者它返回的仍然是一个对象，那么就无法将对象转换为原始值，此时会抛出一个错误。</li>\n</ul>\n</li>\n</ol>\n<p>简化一下：</p>\n<blockquote>\n<p>ToPrimitive(obj, Number) &#x3D;&#x3D;&gt; Number({})</p>\n<ol>\n<li>如果 obj 是基本类型，直接返回</li>\n<li>否则，调用 valueOf 方法，如果得到原始值，则返回</li>\n<li>否则，调用 toString 方法，如果得到原始值，则返回</li>\n<li>否则，报错</li>\n</ol>\n</blockquote>\n<p>这就相当于一个公式，当我们在将一个对象转换成数字类型的时候，直接套就行。</p>\n<p>举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">a = &#123;&#125;;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Number</span>(a)); <span class=\"hljs-comment\">//NaN</span><br></code></pre></td></tr></table></figure>\n\n<p>开始套公式：</p>\n<ol>\n<li><p><strong>如果 <code>a</code> 是基本类型：</strong></p>\n<ul>\n<li><code>a</code> 是一个对象，不是基本类型。</li>\n</ul>\n</li>\n<li><p><strong>调用 <code>valueOf</code> 方法：</strong></p>\n<ul>\n<li>尝试调用 <code>valueOf</code> 方法，看是否可以获取到原始值。</li>\n<li>由于 <code>a</code> 是一个空对象 <code>&#123;&#125;</code>，而普通的对象（没有重写 <code>valueOf</code> 方法的情况下）的 <code>valueOf</code> 方法会返回对象本身，而不是一个原始值。</li>\n</ul>\n</li>\n<li><p><strong>调用 <code>toString</code> 方法：</strong></p>\n<ul>\n<li>由于 <code>valueOf</code> 方法没有返回原始值，接下来调用 <code>toString</code> 方法。</li>\n<li>对于普通的空对象 <code>&#123;&#125;</code>，<code>toString</code> 方法通常会返回 <code>&quot;[object Object]&quot;</code> 字符串。</li>\n</ul>\n</li>\n</ol>\n<p>调用<code>toString</code>方法的时候得到了原始值字符串<code>&quot;[object Object]&quot;</code>，于是<code>ToPrimitive</code>这个函数将其返回，最后就相当于 <code>Number(&quot;[object Object]&quot;)</code> 执行了这段代码。在 JS 引擎内部，<code>ToPrimitive</code>这个函数相当于进行了将 <code>Number(a)</code> 转化成了 <code>Number(&quot;[object Object]&quot;)</code> ，相当于将字符串转换成数字，所以最终打印结果为 <code>NaN</code>。</p>\n<h4 id=\"2-对象转字符串\"><a href=\"#2-对象转字符串\" class=\"headerlink\" title=\"2. 对象转字符串\"></a>2. 对象转字符串</h4><p>与对象转数字类似，唯一的区别就是转字符串时在<code>ToPrimitive</code>函数中是先调用 <code>toString</code> 方法，后调用 <code>typeOf</code> 方法。</p>\n<blockquote>\n<p>ToPrimitive(obj, String) &#x3D;&#x3D;&gt; String({})</p>\n<ol>\n<li>如果 obj 是基本类型，直接返回</li>\n<li>否则，调用 toString 方法，如果得到原始值，则返回</li>\n<li>否则，调用 valueOf 方法，如果得到原始值，则返回</li>\n<li>否则，报错</li>\n</ol>\n</blockquote>\n<p>与对象转数字用法一致，区别在于调用 <code>toString</code> 方法和 <code>valueOf</code> 方法的顺序，区分这一点就行了。</p>\n<h4 id=\"3-对象转布尔\"><a href=\"#3-对象转布尔\" class=\"headerlink\" title=\"3. 对象转布尔\"></a>3. 对象转布尔</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Boolean</span>(&#123;&#125;)); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Boolean</span>([])); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<p>对象转换为布尔值时，结果总是 <code>true</code>。</p>\n<hr>\n<h2 id=\"隐式转换\"><a href=\"#隐式转换\" class=\"headerlink\" title=\"隐式转换\"></a>隐式转换</h2><p>隐式转换通常发生在一些运算符操作中，其中一些运算符会触发 JS 引擎自动进行类型转换以满足操作的要求。下面我们简单聊一下 <code>+</code> 这个运算符。</p>\n<h3 id=\"一元运算-a\"><a href=\"#一元运算-a\" class=\"headerlink\" title=\"一元运算 + a\"></a>一元运算 <code>+ a</code></h3><p>官方文档（<a href=\"https://es5.github.io/#x11.4.6\">Annotated ES5 11.4.6</a>）这样描述：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29819bbe7e4740fcb2dfa3bfa015d5c5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=800&h=216&s=23157&e=png&b=ffffff\" alt=\"image.png\"></p>\n<p>如果遇到 <code>+</code> 号，且它是当作一元运算符来使用，那么 <code>+</code> 号后面的数据一定要被强制转化为 <code>Number</code> 类型。</p>\n<p>举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(+<span class=\"hljs-string\">&quot;1&quot;</span>); <span class=\"hljs-comment\">//1</span><br></code></pre></td></tr></table></figure>\n\n<p>这个例子中， <code>+</code> 后面接的是数字字符串，则转换成对应数字，所以打印结果为<code>1</code>，没问题。</p>\n<p>那么 <code>+</code> 后面接的是对象类型呢，我们再举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(+&#123;&#125;); <span class=\"hljs-comment\">//NaN</span><br></code></pre></td></tr></table></figure>\n\n<p>这个例子中， <code>+</code> 后面接的是一个空对象，那么对象怎么转换成<code>Number</code>呢，是不是要走<code>ToPrimitive</code>函数那一套哇，直接套公式就行了。</p>\n<p>我直接搬过来：</p>\n<blockquote>\n<p>ToPrimitive(obj, Number) &#x3D;&#x3D;&gt; Number({})</p>\n<ol>\n<li>如果 obj 是基本类型，直接返回</li>\n<li>否则，调用 valueOf 方法，如果得到原始值，则返回</li>\n<li>否则，调用 toString 方法，如果得到原始值，则返回</li>\n<li>否则，报错</li>\n</ol>\n</blockquote>\n<p>我们前面已经走过一遍流程了，这个<code>ToPrimitive</code>函数最后会返回一个<code>&quot;[object Object]&quot;</code>字符串，所以最终就相当于 <code>+</code> 后面接的是一个字符串，则转换成 <code>NaN</code> ，打印结果也为 <code>NaN</code>，没问题。</p>\n<p>我们也可以试着模拟一下整个过程：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// +&#123;&#125; 的过程模拟</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(+&#123;&#125;); <span class=\"hljs-comment\">//0</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(&#123;&#125;.<span class=\"hljs-title function_\">valueOf</span>()); <span class=\"hljs-comment\">//&#123;&#125;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(&#123;&#125;.<span class=\"hljs-title function_\">toString</span>()); <span class=\"hljs-comment\">//&quot;[object Object]&quot;</span><br><span class=\"hljs-comment\">//返回&quot;[object Object]&quot;字符串</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Number</span>(<span class=\"hljs-string\">&quot;[object Object]&quot;</span>)); <span class=\"hljs-comment\">//NaN</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"二元运算-a-b\"><a href=\"#二元运算-a-b\" class=\"headerlink\" title=\"二元运算 a + b\"></a>二元运算 <code>a + b</code></h3><p>官方文档（<a href=\"https://es5.github.io/#x11.6.1\">Annotated ES5 11.6.1</a>）这样描述：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ba8415ad2d24e2e8d5d150360b2a7e8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1399&h=622&s=85403&e=png&b=ffffff\" alt=\"image.png\"></p>\n<p>二元运算符 <code>+</code> 可以执行字符串连接，也可以执行数字加法。简而言之，将 <code>+</code> 左右两边的数据分别用<code>ToPrimitive</code>函数调用一遍，如果返回值中有一个是字符串，则进行字符串拼接；否则进行加法运算。</p>\n<p>即：</p>\n<blockquote>\n<p>lprim + rprim &#x3D;&#x3D; ToPrimitive(v1) + ToPrimitive(v2)</p>\n<ol>\n<li>当 + 两边有一个是字符串，则按字符串进行拼接</li>\n<li>否则，转到 number 进行计算</li>\n</ol>\n</blockquote>\n<p>举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">1</span> + <span class=\"hljs-string\">&quot;1&quot;</span>); <span class=\"hljs-comment\">//&#x27;11&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>我们分别让数字<code>1</code>和字符串<code>&#39;1&#39;</code>走一遍<code>ToPrimitive</code>，分别观察它们的返回值，发现<code>&#39;1&#39;</code>是数字字符串，在 <code>valueOf</code> 和 <code>toString</code> 方法后返回的还是<code>&#39;1&#39;</code>本身，即进行字符串拼接，得到打印结果<code>&#39;11&#39;</code>。</p>\n<p>当你理解透彻后很容易得到：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">1</span> + <span class=\"hljs-literal\">null</span>); <span class=\"hljs-comment\">//1</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>([] + []); <span class=\"hljs-comment\">//&#x27;&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>([] + &#123;&#125;); <span class=\"hljs-comment\">//&#x27;[object Object]&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(&#123;&#125; + &#123;&#125;); <span class=\"hljs-comment\">//&#x27;[object Object][object Object]&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p><strong>当你读到这段话时，你已经跨过了 JS 类型转换这一座大山！</strong></p>\n<p>希望这篇文章能够为你提供帮助，如果你还有不懂之处，可以反复阅读，或者在评论区留言，学习是一个循序渐进，敢于试错的过程，我们顶峰相见！</p>\n"},{"title":"快速上手 TS（进阶类型篇）","date":"2024-07-03T08:00:00.000Z","index_img":"/img/ts.png","banner_img":"/img/default.png","_content":"\n\n## 前言\n\n- [快速上手 TS（环境篇）- 掘金 (juejin.cn)](https://juejin.cn/post/7383643463532953619)\n- [快速上手 TS（基础类型篇）- 掘金 (juejin.cn)](https://juejin.cn/post/7386701961808904204)\n\n前两篇中我介绍了 TS 从安装到运行的环境配置，以及 TS 的基础类型介绍，希望能够对你带来帮助。今天我们来学习一下 TS 的进阶知识，数组、元组、函数、接口等等，具体可以参考目录，还是那句话希望我能坚持更新，更希望你能坚持看下去！\n\n## 数组\n\n在 JS 中数组就是数组，但 TS 中的数组被分为了数组和元组\n\n### 数组\n\nTS 数组有一个根本的特征，所有的成员类型必须相同，成员数量可以不确定。\n\n数组有两种声明方式，类型后面加`[]`或者使用内置`Array`接口（下面会详细介绍接口 interface）\n\n```ts\nlet arr: number[] = [1, 2, 3];\nlet arr2: Array<number> = [1, 2, 3];\n```\n\n如果成员类型有不同类型，可以使用联合类型\n\n```ts\nlet arr: (number | string)[] = [1, \"阳阳羊\", 3];\nlet arr2: Array<number | string> = [1, 2, \"阳阳羊\"];\n```\n\n#### 类型推断\n\n数组的类型推断与前文讲的有所不同，它会根据每个成员的类型而变化\n\n如果没有声明数组类型，TS 会自动进行类型推断，当数组为空时，会推断为`any`类型的数组\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89c40b0e3b3c48e1ba5fb62597e78793~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=295&h=86&s=4591&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n当我们修改成员时，会自动进行更新。\n\n这里我们`push`一个数字，会自动推断为`number`数组\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e381d85cb3742d282c8e2c8385aac75~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=302&h=143&s=7453&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n我们再`push`一个字符串，自动推断成联合类型`string | number`的数组\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ed3af34f1a943718984afa42f7d5525~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=405&h=164&s=11903&e=png&b=1e1e1e\" alt=\"image.png\" width=\"50%\" />\n\n### 元组\n\n元组是 TS 新增的数据类型，它表示成员类型可以自由设置的数组。\n\n```ts\nconst tuple: [string, number, boolean] = [\"阳阳羊\", 123, true];\n```\n\n写法上与数组有所不同，数组的类型是写在`[]`的左边，而元组的类型是写在`[]`内部。\n\n使用元组时必须给出类型声明，不然会被 TS 自动推断为数组\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd3c5599c3b04805a490f0d506373b24~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=578&h=87&s=9894&e=png&b=1f1f1f\" alt=\"image.png\" width=\"50%\" />\n\n#### `?`可选符\n\n元组成员的类型可以添加问号后缀（`?`），表示该成员是可选的。\n\n```ts\nconst tuple: [string, number, boolean?] = [\"阳阳羊\", 123];\n```\n\n需要注意的是可选成员要放在尾部，即所有可选成员必须在必选成员之后\n\n如果放在前面会报错\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a91064aa2774f42ab530ec2ef5cee14~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=740&h=150&s=22684&e=png&b=1f1f1f\" alt=\"image.png\" width=\"70%\" />\n\n#### `...`扩展运算符\n\n一般情况下，元组的成员数量是固定的，有多少个类型声明就有多少个成员，但是`...`扩展运算符允许我们表示不定成员数量的元组。\n\n```ts\nconst tuple: [string, ...number[]] = [\"阳阳羊\", 123, 456];\n```\n\n扩展运算符用在元组的任意位置都可以，但是只能扩展数组或元组。\n\n## 函数\n\n函数的类型声明，需要给出参数和返回值的类型\n\n```ts\nfunction fn(a: number, b: number): number {\n  return a + b;\n}\n```\n\n这里两个参数`a`、`b`类型都为`number`，以及返回值的类型`number`，返回值类型写在参数列表的圆括号后面。\n\n我们也可以使用函数表达式进行声明\n\n```ts\n//方式一\nconst fn = function (a: number, b: number): number {\n  return a + b;\n};\n//方式二\nconst fn: (a: number, b: number) => number = function (a, b) {\n  return a + b;\n};\n```\n\n这里的两种方式都可以实现，第一种是通过等号右边来推断`fn`的类型，第二种则是直接指明了`fn`的类型。\n\n返回值类型通常可以不写，TS 会自己推断出来，如果没写`return`语句，会推断为没有返回值\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d54abea603554da3a2b998bbf727de04~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=494&h=138&s=13079&e=png&b=1f1f1f\" alt=\"image.png\" width=\"50%\" />\n\n### void 类型\n\nvoid 类型表示函数没有返回值。如果你学过 c 语言，那你一定不会陌生。\n\n在 TS 中`void`并不代表不能写`return`语句，它允许返回`undefined`或`null`（`null`需要关闭严格模式），因为它俩在 TS 看来也是相当于没有返回值。\n\n```ts\nfunction fn3(a: number, b: number): void {\n  return undefined;\n}\n```\n\n但是如果你返回其它类型就会报错\n\n```ts\nfunction fn(a: number, b: number): void {\n  return a + b; //报错\n}\n```\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76765d6f43fc4fabb8edf79d0ebc8efa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=569&h=162&s=18617&e=png&b=272728\" alt=\"image.png\" width=\"70%\" />\n\n### 函数重载\n\n有些函数可以接受不同类型或不同个数的参数，并且根据参数的不同，会有不同的函数行为。这种根据参数类型不同，执行不同逻辑的行为，称为函数重载。\n\n这里我们想实现一个函数，不管你传入的是数组还是字符串，我都希望它返回一个反转后的结果\n\n```ts\nreverse(\"abc\"); // 'cba'\nreverse([1, 2, 3]); // [3, 2, 1]\n```\n\n首先我们逐一定义每一种情况的类型\n\n```ts\nfunction reverse(str: string): string;\nfunction reverse(arr: any[]): any[];\n```\n\n然后给予函数完整的类型声明\n\n```ts\nfunction reverse(stringOrArray: string | any[]): string | any[] {\n  if (typeof stringOrArray === \"string\")\n    return stringOrArray.split(\"\").reverse().join(\"\");\n  else {\n    return stringOrArray.slice().reverse();\n  }\n}\n```\n\n效果如下\n\n```ts\nconsole.log(reverse([\"🐂\", \"🐑\", \"🐎\", \"🐒\"])); //[ '🐒', '🐎', '🐑', '🐂' ]\nconsole.log(reverse(\"牛羊马猴\")); //猴马羊牛\n```\n\n## type 命令\n\nTS 允许我们用 type 来定义一个类型别名，我们习惯使用大驼峰命名方式进行命名。\n\n```ts\ntype Name = string;\nlet name: Name = \"阳阳羊\";\n```\n\n这样`Age`就能像使用`number`一样作为类型来使用\n\n别名不允许重名，拿值类型来举例\n\n```ts\ntype Color = \"红\";\ntype Color = \"绿\"; //报错\n```\n\n如果一些类型定义很冗长，我们往往会用 type 命令为函数类型定义一个别名。\n\n```ts\ntype MyFunc = (a: string) => void;\n\nconst fn: MyFunc = function (a) {\n  console.log(\"hello \" + a);\n};\n```\n\n## interface 接口\n\ninterface 是对象的模板，可以看作是一种类型约定，中文译为“接口”。使用了某个模板的对象，就拥有了指定的类型结构。\n\n### 属性\n\n```ts\ninterface Person {\n  name: string;\n  age: number;\n}\n```\n\n这里我们定义了一个接口`Person`，两个属性`name`和`age`，任何实现这个接口的对象都必须具有这两个属性，并符合规定类型。\n\n```ts\nconst me: Person = {\n  name: \"阳阳羊\",\n  age: 21,\n};\n```\n\n如果属性和类型有一个不符就会报错。\n\n如果你希望属性是可选的，则可以使用`?`可选操作符，只读可以使用`readonly`修饰符\n\n```ts\ninterface Person {\n  name?: \"阳阳羊\";\n  readonly age: 21;\n}\n```\n\n### 方法\n\n除了属性外，接口还允许我们定义对象的方法\n\n```ts\ninterface Person {\n  say(x: string): string;\n}\n```\n\n### 函数\n\n接口也可以用来声明独立的函数\n\n```ts\ninterface Add {\n  (x: number, y: number): number;\n}\nconst myAdd: Add = (x, y) => x + y;\n```\n\n### 继承\n\n接口可以使用`extends`关键字实现继承\n\n```ts\ninterface Animal {\n  name: string;\n  age: number;\n}\n\ninterface Dog extends Animal {\n  color: string;\n}\n```\n\n`extends`关键字会从继承的接口里面拷贝属性类型，这样就不必书写重复的属性\n\n如果子接口与父接口存在同名属性，那么子接口的属性会覆盖父接口的属性。前提是不能有冲突，属性方法他们的类型得是一致的，不然会报错\n\n```ts\ninterface Animal {\n  name: string;\n  age: number;\n}\n\ninterface Dog extends Animal {\n  color: string;\n  age: bigint;\n}\n```\n\n这里存在同名属性，但是类型不一致\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3634c66ca59942e287f2cde4ae39687c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=519&h=226&s=30080&e=png&b=272728)\n\n### 合并\n\n多个同名接口会合并成一个接口\n\n```ts\ninterface Box {\n  height: number;\n  width: number;\n}\n\ninterface Box {\n  length: number;\n}\n```\n\n两个`Box`接口会合并成一个接口，同时有`height`、`width`和`length`三个属性。前提仍然是不能有冲突。\n\n### 和 type 的区别\n\n（1）`type`能够表示非对象类型，而`interface`只能表示对象类型（包括数组、函数等）。\n\n（2）`interface`可以继承其他类型，`type`不支持继承。\n\n（3）同名`interface`会自动合并，同名`type`则会报错。也就是说，TypeScript 不允许使用`type`多次定义同一个类型。\n\n## 参考\n\n- [阮一峰 TypeScript 教程](https://typescript.p6p.net/typescript-tutorial/types.html)\n- [TypeScript 官方文档](https://www.typescriptlang.org/)\n\n## 最后\n\n以上是对 TS 进阶类型的基本介绍，内容相对于基础，对于新同学来说比较友好，后面我会继续更新进阶知识，关于类、泛型、Enum 类型等等，可以收藏本站，我会持续更新。\n\n已将学习代码上传至 [github](https://github.com/YangyangU/CodeSpace)，欢迎大家学习指正！\n","source":"_posts/快速上手TS（进阶类型篇）.md","raw":"---\ntitle: 快速上手 TS（进阶类型篇）\ndate: 2024-07-03 16:00:00\ntags: [TypeScript]\ncategories: TypeScript\nindex_img: /img/ts.png\nbanner_img: /img/default.png\n---\n\n\n## 前言\n\n- [快速上手 TS（环境篇）- 掘金 (juejin.cn)](https://juejin.cn/post/7383643463532953619)\n- [快速上手 TS（基础类型篇）- 掘金 (juejin.cn)](https://juejin.cn/post/7386701961808904204)\n\n前两篇中我介绍了 TS 从安装到运行的环境配置，以及 TS 的基础类型介绍，希望能够对你带来帮助。今天我们来学习一下 TS 的进阶知识，数组、元组、函数、接口等等，具体可以参考目录，还是那句话希望我能坚持更新，更希望你能坚持看下去！\n\n## 数组\n\n在 JS 中数组就是数组，但 TS 中的数组被分为了数组和元组\n\n### 数组\n\nTS 数组有一个根本的特征，所有的成员类型必须相同，成员数量可以不确定。\n\n数组有两种声明方式，类型后面加`[]`或者使用内置`Array`接口（下面会详细介绍接口 interface）\n\n```ts\nlet arr: number[] = [1, 2, 3];\nlet arr2: Array<number> = [1, 2, 3];\n```\n\n如果成员类型有不同类型，可以使用联合类型\n\n```ts\nlet arr: (number | string)[] = [1, \"阳阳羊\", 3];\nlet arr2: Array<number | string> = [1, 2, \"阳阳羊\"];\n```\n\n#### 类型推断\n\n数组的类型推断与前文讲的有所不同，它会根据每个成员的类型而变化\n\n如果没有声明数组类型，TS 会自动进行类型推断，当数组为空时，会推断为`any`类型的数组\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89c40b0e3b3c48e1ba5fb62597e78793~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=295&h=86&s=4591&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n当我们修改成员时，会自动进行更新。\n\n这里我们`push`一个数字，会自动推断为`number`数组\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e381d85cb3742d282c8e2c8385aac75~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=302&h=143&s=7453&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n我们再`push`一个字符串，自动推断成联合类型`string | number`的数组\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ed3af34f1a943718984afa42f7d5525~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=405&h=164&s=11903&e=png&b=1e1e1e\" alt=\"image.png\" width=\"50%\" />\n\n### 元组\n\n元组是 TS 新增的数据类型，它表示成员类型可以自由设置的数组。\n\n```ts\nconst tuple: [string, number, boolean] = [\"阳阳羊\", 123, true];\n```\n\n写法上与数组有所不同，数组的类型是写在`[]`的左边，而元组的类型是写在`[]`内部。\n\n使用元组时必须给出类型声明，不然会被 TS 自动推断为数组\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd3c5599c3b04805a490f0d506373b24~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=578&h=87&s=9894&e=png&b=1f1f1f\" alt=\"image.png\" width=\"50%\" />\n\n#### `?`可选符\n\n元组成员的类型可以添加问号后缀（`?`），表示该成员是可选的。\n\n```ts\nconst tuple: [string, number, boolean?] = [\"阳阳羊\", 123];\n```\n\n需要注意的是可选成员要放在尾部，即所有可选成员必须在必选成员之后\n\n如果放在前面会报错\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a91064aa2774f42ab530ec2ef5cee14~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=740&h=150&s=22684&e=png&b=1f1f1f\" alt=\"image.png\" width=\"70%\" />\n\n#### `...`扩展运算符\n\n一般情况下，元组的成员数量是固定的，有多少个类型声明就有多少个成员，但是`...`扩展运算符允许我们表示不定成员数量的元组。\n\n```ts\nconst tuple: [string, ...number[]] = [\"阳阳羊\", 123, 456];\n```\n\n扩展运算符用在元组的任意位置都可以，但是只能扩展数组或元组。\n\n## 函数\n\n函数的类型声明，需要给出参数和返回值的类型\n\n```ts\nfunction fn(a: number, b: number): number {\n  return a + b;\n}\n```\n\n这里两个参数`a`、`b`类型都为`number`，以及返回值的类型`number`，返回值类型写在参数列表的圆括号后面。\n\n我们也可以使用函数表达式进行声明\n\n```ts\n//方式一\nconst fn = function (a: number, b: number): number {\n  return a + b;\n};\n//方式二\nconst fn: (a: number, b: number) => number = function (a, b) {\n  return a + b;\n};\n```\n\n这里的两种方式都可以实现，第一种是通过等号右边来推断`fn`的类型，第二种则是直接指明了`fn`的类型。\n\n返回值类型通常可以不写，TS 会自己推断出来，如果没写`return`语句，会推断为没有返回值\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d54abea603554da3a2b998bbf727de04~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=494&h=138&s=13079&e=png&b=1f1f1f\" alt=\"image.png\" width=\"50%\" />\n\n### void 类型\n\nvoid 类型表示函数没有返回值。如果你学过 c 语言，那你一定不会陌生。\n\n在 TS 中`void`并不代表不能写`return`语句，它允许返回`undefined`或`null`（`null`需要关闭严格模式），因为它俩在 TS 看来也是相当于没有返回值。\n\n```ts\nfunction fn3(a: number, b: number): void {\n  return undefined;\n}\n```\n\n但是如果你返回其它类型就会报错\n\n```ts\nfunction fn(a: number, b: number): void {\n  return a + b; //报错\n}\n```\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76765d6f43fc4fabb8edf79d0ebc8efa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=569&h=162&s=18617&e=png&b=272728\" alt=\"image.png\" width=\"70%\" />\n\n### 函数重载\n\n有些函数可以接受不同类型或不同个数的参数，并且根据参数的不同，会有不同的函数行为。这种根据参数类型不同，执行不同逻辑的行为，称为函数重载。\n\n这里我们想实现一个函数，不管你传入的是数组还是字符串，我都希望它返回一个反转后的结果\n\n```ts\nreverse(\"abc\"); // 'cba'\nreverse([1, 2, 3]); // [3, 2, 1]\n```\n\n首先我们逐一定义每一种情况的类型\n\n```ts\nfunction reverse(str: string): string;\nfunction reverse(arr: any[]): any[];\n```\n\n然后给予函数完整的类型声明\n\n```ts\nfunction reverse(stringOrArray: string | any[]): string | any[] {\n  if (typeof stringOrArray === \"string\")\n    return stringOrArray.split(\"\").reverse().join(\"\");\n  else {\n    return stringOrArray.slice().reverse();\n  }\n}\n```\n\n效果如下\n\n```ts\nconsole.log(reverse([\"🐂\", \"🐑\", \"🐎\", \"🐒\"])); //[ '🐒', '🐎', '🐑', '🐂' ]\nconsole.log(reverse(\"牛羊马猴\")); //猴马羊牛\n```\n\n## type 命令\n\nTS 允许我们用 type 来定义一个类型别名，我们习惯使用大驼峰命名方式进行命名。\n\n```ts\ntype Name = string;\nlet name: Name = \"阳阳羊\";\n```\n\n这样`Age`就能像使用`number`一样作为类型来使用\n\n别名不允许重名，拿值类型来举例\n\n```ts\ntype Color = \"红\";\ntype Color = \"绿\"; //报错\n```\n\n如果一些类型定义很冗长，我们往往会用 type 命令为函数类型定义一个别名。\n\n```ts\ntype MyFunc = (a: string) => void;\n\nconst fn: MyFunc = function (a) {\n  console.log(\"hello \" + a);\n};\n```\n\n## interface 接口\n\ninterface 是对象的模板，可以看作是一种类型约定，中文译为“接口”。使用了某个模板的对象，就拥有了指定的类型结构。\n\n### 属性\n\n```ts\ninterface Person {\n  name: string;\n  age: number;\n}\n```\n\n这里我们定义了一个接口`Person`，两个属性`name`和`age`，任何实现这个接口的对象都必须具有这两个属性，并符合规定类型。\n\n```ts\nconst me: Person = {\n  name: \"阳阳羊\",\n  age: 21,\n};\n```\n\n如果属性和类型有一个不符就会报错。\n\n如果你希望属性是可选的，则可以使用`?`可选操作符，只读可以使用`readonly`修饰符\n\n```ts\ninterface Person {\n  name?: \"阳阳羊\";\n  readonly age: 21;\n}\n```\n\n### 方法\n\n除了属性外，接口还允许我们定义对象的方法\n\n```ts\ninterface Person {\n  say(x: string): string;\n}\n```\n\n### 函数\n\n接口也可以用来声明独立的函数\n\n```ts\ninterface Add {\n  (x: number, y: number): number;\n}\nconst myAdd: Add = (x, y) => x + y;\n```\n\n### 继承\n\n接口可以使用`extends`关键字实现继承\n\n```ts\ninterface Animal {\n  name: string;\n  age: number;\n}\n\ninterface Dog extends Animal {\n  color: string;\n}\n```\n\n`extends`关键字会从继承的接口里面拷贝属性类型，这样就不必书写重复的属性\n\n如果子接口与父接口存在同名属性，那么子接口的属性会覆盖父接口的属性。前提是不能有冲突，属性方法他们的类型得是一致的，不然会报错\n\n```ts\ninterface Animal {\n  name: string;\n  age: number;\n}\n\ninterface Dog extends Animal {\n  color: string;\n  age: bigint;\n}\n```\n\n这里存在同名属性，但是类型不一致\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3634c66ca59942e287f2cde4ae39687c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=519&h=226&s=30080&e=png&b=272728)\n\n### 合并\n\n多个同名接口会合并成一个接口\n\n```ts\ninterface Box {\n  height: number;\n  width: number;\n}\n\ninterface Box {\n  length: number;\n}\n```\n\n两个`Box`接口会合并成一个接口，同时有`height`、`width`和`length`三个属性。前提仍然是不能有冲突。\n\n### 和 type 的区别\n\n（1）`type`能够表示非对象类型，而`interface`只能表示对象类型（包括数组、函数等）。\n\n（2）`interface`可以继承其他类型，`type`不支持继承。\n\n（3）同名`interface`会自动合并，同名`type`则会报错。也就是说，TypeScript 不允许使用`type`多次定义同一个类型。\n\n## 参考\n\n- [阮一峰 TypeScript 教程](https://typescript.p6p.net/typescript-tutorial/types.html)\n- [TypeScript 官方文档](https://www.typescriptlang.org/)\n\n## 最后\n\n以上是对 TS 进阶类型的基本介绍，内容相对于基础，对于新同学来说比较友好，后面我会继续更新进阶知识，关于类、泛型、Enum 类型等等，可以收藏本站，我会持续更新。\n\n已将学习代码上传至 [github](https://github.com/YangyangU/CodeSpace)，欢迎大家学习指正！\n","slug":"快速上手TS（进阶类型篇）","published":1,"updated":"2024-09-09T15:30:56.910Z","_id":"clywvnjz7000318v66lyl5r4g","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ul>\n<li><a href=\"https://juejin.cn/post/7383643463532953619\">快速上手 TS（环境篇）- 掘金 (juejin.cn)</a></li>\n<li><a href=\"https://juejin.cn/post/7386701961808904204\">快速上手 TS（基础类型篇）- 掘金 (juejin.cn)</a></li>\n</ul>\n<p>前两篇中我介绍了 TS 从安装到运行的环境配置，以及 TS 的基础类型介绍，希望能够对你带来帮助。今天我们来学习一下 TS 的进阶知识，数组、元组、函数、接口等等，具体可以参考目录，还是那句话希望我能坚持更新，更希望你能坚持看下去！</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>在 JS 中数组就是数组，但 TS 中的数组被分为了数组和元组</p>\n<h3 id=\"数组-1\"><a href=\"#数组-1\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>TS 数组有一个根本的特征，所有的成员类型必须相同，成员数量可以不确定。</p>\n<p>数组有两种声明方式，类型后面加<code>[]</code>或者使用内置<code>Array</code>接口（下面会详细介绍接口 interface）</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">arr</span>: <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">arr2</span>: <span class=\"hljs-title class_\">Array</span>&lt;<span class=\"hljs-built_in\">number</span>&gt; = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br></code></pre></td></tr></table></figure>\n\n<p>如果成员类型有不同类型，可以使用联合类型</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">arr</span>: (<span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span>)[] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&quot;阳阳羊&quot;</span>, <span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">arr2</span>: <span class=\"hljs-title class_\">Array</span>&lt;<span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span>&gt; = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&quot;阳阳羊&quot;</span>];<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"类型推断\"><a href=\"#类型推断\" class=\"headerlink\" title=\"类型推断\"></a>类型推断</h4><p>数组的类型推断与前文讲的有所不同，它会根据每个成员的类型而变化</p>\n<p>如果没有声明数组类型，TS 会自动进行类型推断，当数组为空时，会推断为<code>any</code>类型的数组</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89c40b0e3b3c48e1ba5fb62597e78793~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=295&h=86&s=4591&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n<p>当我们修改成员时，会自动进行更新。</p>\n<p>这里我们<code>push</code>一个数字，会自动推断为<code>number</code>数组</p>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e381d85cb3742d282c8e2c8385aac75~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=302&h=143&s=7453&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n<p>我们再<code>push</code>一个字符串，自动推断成联合类型<code>string | number</code>的数组</p>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ed3af34f1a943718984afa42f7d5525~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=405&h=164&s=11903&e=png&b=1e1e1e\" alt=\"image.png\" width=\"50%\" />\n\n<h3 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h3><p>元组是 TS 新增的数据类型，它表示成员类型可以自由设置的数组。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">tuple</span>: [<span class=\"hljs-built_in\">string</span>, <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-built_in\">boolean</span>] = [<span class=\"hljs-string\">&quot;阳阳羊&quot;</span>, <span class=\"hljs-number\">123</span>, <span class=\"hljs-literal\">true</span>];<br></code></pre></td></tr></table></figure>\n\n<p>写法上与数组有所不同，数组的类型是写在<code>[]</code>的左边，而元组的类型是写在<code>[]</code>内部。</p>\n<p>使用元组时必须给出类型声明，不然会被 TS 自动推断为数组</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd3c5599c3b04805a490f0d506373b24~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=578&h=87&s=9894&e=png&b=1f1f1f\" alt=\"image.png\" width=\"50%\" />\n\n<h4 id=\"可选符\"><a href=\"#可选符\" class=\"headerlink\" title=\"?可选符\"></a><code>?</code>可选符</h4><p>元组成员的类型可以添加问号后缀（<code>?</code>），表示该成员是可选的。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">tuple</span>: [<span class=\"hljs-built_in\">string</span>, <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-built_in\">boolean</span>?] = [<span class=\"hljs-string\">&quot;阳阳羊&quot;</span>, <span class=\"hljs-number\">123</span>];<br></code></pre></td></tr></table></figure>\n\n<p>需要注意的是可选成员要放在尾部，即所有可选成员必须在必选成员之后</p>\n<p>如果放在前面会报错</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a91064aa2774f42ab530ec2ef5cee14~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=740&h=150&s=22684&e=png&b=1f1f1f\" alt=\"image.png\" width=\"70%\" />\n\n<h4 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"...扩展运算符\"></a><code>...</code>扩展运算符</h4><p>一般情况下，元组的成员数量是固定的，有多少个类型声明就有多少个成员，但是<code>...</code>扩展运算符允许我们表示不定成员数量的元组。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">tuple</span>: [<span class=\"hljs-built_in\">string</span>, ...<span class=\"hljs-built_in\">number</span>[]] = [<span class=\"hljs-string\">&quot;阳阳羊&quot;</span>, <span class=\"hljs-number\">123</span>, <span class=\"hljs-number\">456</span>];<br></code></pre></td></tr></table></figure>\n\n<p>扩展运算符用在元组的任意位置都可以，但是只能扩展数组或元组。</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>函数的类型声明，需要给出参数和返回值的类型</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">a</span>: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-built_in\">number</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里两个参数<code>a</code>、<code>b</code>类型都为<code>number</code>，以及返回值的类型<code>number</code>，返回值类型写在参数列表的圆括号后面。</p>\n<p>我们也可以使用函数表达式进行声明</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">//方式一</span><br><span class=\"hljs-keyword\">const</span> fn = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"><span class=\"hljs-attr\">a</span>: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-built_in\">number</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;;<br><span class=\"hljs-comment\">//方式二</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">fn</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">a</span>: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a, b</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>这里的两种方式都可以实现，第一种是通过等号右边来推断<code>fn</code>的类型，第二种则是直接指明了<code>fn</code>的类型。</p>\n<p>返回值类型通常可以不写，TS 会自己推断出来，如果没写<code>return</code>语句，会推断为没有返回值</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d54abea603554da3a2b998bbf727de04~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=494&h=138&s=13079&e=png&b=1f1f1f\" alt=\"image.png\" width=\"50%\" />\n\n<h3 id=\"void-类型\"><a href=\"#void-类型\" class=\"headerlink\" title=\"void 类型\"></a>void 类型</h3><p>void 类型表示函数没有返回值。如果你学过 c 语言，那你一定不会陌生。</p>\n<p>在 TS 中<code>void</code>并不代表不能写<code>return</code>语句，它允许返回<code>undefined</code>或<code>null</code>（<code>null</code>需要关闭严格模式），因为它俩在 TS 看来也是相当于没有返回值。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn3</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">a</span>: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-built_in\">void</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">undefined</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>但是如果你返回其它类型就会报错</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">a</span>: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-built_in\">void</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> a + b; <span class=\"hljs-comment\">//报错</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76765d6f43fc4fabb8edf79d0ebc8efa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=569&h=162&s=18617&e=png&b=272728\" alt=\"image.png\" width=\"70%\" />\n\n<h3 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h3><p>有些函数可以接受不同类型或不同个数的参数，并且根据参数的不同，会有不同的函数行为。这种根据参数类型不同，执行不同逻辑的行为，称为函数重载。</p>\n<p>这里我们想实现一个函数，不管你传入的是数组还是字符串，我都希望它返回一个反转后的结果</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-title function_\">reverse</span>(<span class=\"hljs-string\">&quot;abc&quot;</span>); <span class=\"hljs-comment\">// &#x27;cba&#x27;</span><br><span class=\"hljs-title function_\">reverse</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]); <span class=\"hljs-comment\">// [3, 2, 1]</span><br></code></pre></td></tr></table></figure>\n\n<p>首先我们逐一定义每一种情况的类型</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">reverse</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">str</span>: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-built_in\">string</span>;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">reverse</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">arr</span>: <span class=\"hljs-built_in\">any</span>[]</span>): <span class=\"hljs-built_in\">any</span>[];<br></code></pre></td></tr></table></figure>\n\n<p>然后给予函数完整的类型声明</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">reverse</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">stringOrArray</span>: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">any</span>[]</span>): <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">any</span>[] &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> stringOrArray === <span class=\"hljs-string\">&quot;string&quot;</span>)<br>    <span class=\"hljs-keyword\">return</span> stringOrArray.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&quot;&quot;</span>).<span class=\"hljs-title function_\">reverse</span>().<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&quot;&quot;</span>);<br>  <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> stringOrArray.<span class=\"hljs-title function_\">slice</span>().<span class=\"hljs-title function_\">reverse</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>效果如下</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">reverse</span>([<span class=\"hljs-string\">&quot;🐂&quot;</span>, <span class=\"hljs-string\">&quot;🐑&quot;</span>, <span class=\"hljs-string\">&quot;🐎&quot;</span>, <span class=\"hljs-string\">&quot;🐒&quot;</span>])); <span class=\"hljs-comment\">//[ &#x27;🐒&#x27;, &#x27;🐎&#x27;, &#x27;🐑&#x27;, &#x27;🐂&#x27; ]</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">reverse</span>(<span class=\"hljs-string\">&quot;牛羊马猴&quot;</span>)); <span class=\"hljs-comment\">//猴马羊牛</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"type-命令\"><a href=\"#type-命令\" class=\"headerlink\" title=\"type 命令\"></a>type 命令</h2><p>TS 允许我们用 type 来定义一个类型别名，我们习惯使用大驼峰命名方式进行命名。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Name</span> = <span class=\"hljs-built_in\">string</span>;<br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">Name</span> = <span class=\"hljs-string\">&quot;阳阳羊&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这样<code>Age</code>就能像使用<code>number</code>一样作为类型来使用</p>\n<p>别名不允许重名，拿值类型来举例</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Color</span> = <span class=\"hljs-string\">&quot;红&quot;</span>;<br><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Color</span> = <span class=\"hljs-string\">&quot;绿&quot;</span>; <span class=\"hljs-comment\">//报错</span><br></code></pre></td></tr></table></figure>\n\n<p>如果一些类型定义很冗长，我们往往会用 type 命令为函数类型定义一个别名。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">MyFunc</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">a</span>: <span class=\"hljs-built_in\">string</span></span>) =&gt;</span> <span class=\"hljs-built_in\">void</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">fn</span>: <span class=\"hljs-title class_\">MyFunc</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;hello &quot;</span> + a);<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"interface-接口\"><a href=\"#interface-接口\" class=\"headerlink\" title=\"interface 接口\"></a>interface 接口</h2><p>interface 是对象的模板，可以看作是一种类型约定，中文译为“接口”。使用了某个模板的对象，就拥有了指定的类型结构。</p>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Person</span> &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里我们定义了一个接口<code>Person</code>，两个属性<code>name</code>和<code>age</code>，任何实现这个接口的对象都必须具有这两个属性，并符合规定类型。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">me</span>: <span class=\"hljs-title class_\">Person</span> = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;阳阳羊&quot;</span>,<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">21</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>如果属性和类型有一个不符就会报错。</p>\n<p>如果你希望属性是可选的，则可以使用<code>?</code>可选操作符，只读可以使用<code>readonly</code>修饰符</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Person</span> &#123;<br>  name?: <span class=\"hljs-string\">&quot;阳阳羊&quot;</span>;<br>  <span class=\"hljs-keyword\">readonly</span> <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">21</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>除了属性外，接口还允许我们定义对象的方法</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Person</span> &#123;<br>  <span class=\"hljs-title function_\">say</span>(<span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">string</span>): <span class=\"hljs-built_in\">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"函数-1\"><a href=\"#函数-1\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>接口也可以用来声明独立的函数</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Add</span> &#123;<br>  (<span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-built_in\">number</span>;<br>&#125;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">myAdd</span>: <span class=\"hljs-title class_\">Add</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">x, y</span>) =&gt;</span> x + y;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>接口可以使用<code>extends</code>关键字实现继承</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>  <span class=\"hljs-attr\">color</span>: <span class=\"hljs-built_in\">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>extends</code>关键字会从继承的接口里面拷贝属性类型，这样就不必书写重复的属性</p>\n<p>如果子接口与父接口存在同名属性，那么子接口的属性会覆盖父接口的属性。前提是不能有冲突，属性方法他们的类型得是一致的，不然会报错</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>  <span class=\"hljs-attr\">color</span>: <span class=\"hljs-built_in\">string</span>;<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">bigint</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里存在同名属性，但是类型不一致</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3634c66ca59942e287f2cde4ae39687c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=519&h=226&s=30080&e=png&b=272728\" alt=\"image.png\"></p>\n<h3 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并\"></a>合并</h3><p>多个同名接口会合并成一个接口</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Box</span> &#123;<br>  <span class=\"hljs-attr\">height</span>: <span class=\"hljs-built_in\">number</span>;<br>  <span class=\"hljs-attr\">width</span>: <span class=\"hljs-built_in\">number</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Box</span> &#123;<br>  <span class=\"hljs-attr\">length</span>: <span class=\"hljs-built_in\">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>两个<code>Box</code>接口会合并成一个接口，同时有<code>height</code>、<code>width</code>和<code>length</code>三个属性。前提仍然是不能有冲突。</p>\n<h3 id=\"和-type-的区别\"><a href=\"#和-type-的区别\" class=\"headerlink\" title=\"和 type 的区别\"></a>和 type 的区别</h3><p>（1）<code>type</code>能够表示非对象类型，而<code>interface</code>只能表示对象类型（包括数组、函数等）。</p>\n<p>（2）<code>interface</code>可以继承其他类型，<code>type</code>不支持继承。</p>\n<p>（3）同名<code>interface</code>会自动合并，同名<code>type</code>则会报错。也就是说，TypeScript 不允许使用<code>type</code>多次定义同一个类型。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://typescript.p6p.net/typescript-tutorial/types.html\">阮一峰 TypeScript 教程</a></li>\n<li><a href=\"https://www.typescriptlang.org/\">TypeScript 官方文档</a></li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>以上是对 TS 进阶类型的基本介绍，内容相对于基础，对于新同学来说比较友好，后面我会继续更新进阶知识，关于类、泛型、Enum 类型等等，可以收藏本站，我会持续更新。</p>\n<p>已将学习代码上传至 <a href=\"https://github.com/YangyangU/CodeSpace\">github</a>，欢迎大家学习指正！</p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ul>\n<li><a href=\"https://juejin.cn/post/7383643463532953619\">快速上手 TS（环境篇）- 掘金 (juejin.cn)</a></li>\n<li><a href=\"https://juejin.cn/post/7386701961808904204\">快速上手 TS（基础类型篇）- 掘金 (juejin.cn)</a></li>\n</ul>\n<p>前两篇中我介绍了 TS 从安装到运行的环境配置，以及 TS 的基础类型介绍，希望能够对你带来帮助。今天我们来学习一下 TS 的进阶知识，数组、元组、函数、接口等等，具体可以参考目录，还是那句话希望我能坚持更新，更希望你能坚持看下去！</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>在 JS 中数组就是数组，但 TS 中的数组被分为了数组和元组</p>\n<h3 id=\"数组-1\"><a href=\"#数组-1\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>TS 数组有一个根本的特征，所有的成员类型必须相同，成员数量可以不确定。</p>\n<p>数组有两种声明方式，类型后面加<code>[]</code>或者使用内置<code>Array</code>接口（下面会详细介绍接口 interface）</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">arr</span>: <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">arr2</span>: <span class=\"hljs-title class_\">Array</span>&lt;<span class=\"hljs-built_in\">number</span>&gt; = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br></code></pre></td></tr></table></figure>\n\n<p>如果成员类型有不同类型，可以使用联合类型</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">arr</span>: (<span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span>)[] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&quot;阳阳羊&quot;</span>, <span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">arr2</span>: <span class=\"hljs-title class_\">Array</span>&lt;<span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span>&gt; = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&quot;阳阳羊&quot;</span>];<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"类型推断\"><a href=\"#类型推断\" class=\"headerlink\" title=\"类型推断\"></a>类型推断</h4><p>数组的类型推断与前文讲的有所不同，它会根据每个成员的类型而变化</p>\n<p>如果没有声明数组类型，TS 会自动进行类型推断，当数组为空时，会推断为<code>any</code>类型的数组</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89c40b0e3b3c48e1ba5fb62597e78793~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=295&h=86&s=4591&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n<p>当我们修改成员时，会自动进行更新。</p>\n<p>这里我们<code>push</code>一个数字，会自动推断为<code>number</code>数组</p>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e381d85cb3742d282c8e2c8385aac75~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=302&h=143&s=7453&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n<p>我们再<code>push</code>一个字符串，自动推断成联合类型<code>string | number</code>的数组</p>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ed3af34f1a943718984afa42f7d5525~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=405&h=164&s=11903&e=png&b=1e1e1e\" alt=\"image.png\" width=\"50%\" />\n\n<h3 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h3><p>元组是 TS 新增的数据类型，它表示成员类型可以自由设置的数组。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">tuple</span>: [<span class=\"hljs-built_in\">string</span>, <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-built_in\">boolean</span>] = [<span class=\"hljs-string\">&quot;阳阳羊&quot;</span>, <span class=\"hljs-number\">123</span>, <span class=\"hljs-literal\">true</span>];<br></code></pre></td></tr></table></figure>\n\n<p>写法上与数组有所不同，数组的类型是写在<code>[]</code>的左边，而元组的类型是写在<code>[]</code>内部。</p>\n<p>使用元组时必须给出类型声明，不然会被 TS 自动推断为数组</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd3c5599c3b04805a490f0d506373b24~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=578&h=87&s=9894&e=png&b=1f1f1f\" alt=\"image.png\" width=\"50%\" />\n\n<h4 id=\"可选符\"><a href=\"#可选符\" class=\"headerlink\" title=\"?可选符\"></a><code>?</code>可选符</h4><p>元组成员的类型可以添加问号后缀（<code>?</code>），表示该成员是可选的。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">tuple</span>: [<span class=\"hljs-built_in\">string</span>, <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-built_in\">boolean</span>?] = [<span class=\"hljs-string\">&quot;阳阳羊&quot;</span>, <span class=\"hljs-number\">123</span>];<br></code></pre></td></tr></table></figure>\n\n<p>需要注意的是可选成员要放在尾部，即所有可选成员必须在必选成员之后</p>\n<p>如果放在前面会报错</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a91064aa2774f42ab530ec2ef5cee14~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=740&h=150&s=22684&e=png&b=1f1f1f\" alt=\"image.png\" width=\"70%\" />\n\n<h4 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"...扩展运算符\"></a><code>...</code>扩展运算符</h4><p>一般情况下，元组的成员数量是固定的，有多少个类型声明就有多少个成员，但是<code>...</code>扩展运算符允许我们表示不定成员数量的元组。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">tuple</span>: [<span class=\"hljs-built_in\">string</span>, ...<span class=\"hljs-built_in\">number</span>[]] = [<span class=\"hljs-string\">&quot;阳阳羊&quot;</span>, <span class=\"hljs-number\">123</span>, <span class=\"hljs-number\">456</span>];<br></code></pre></td></tr></table></figure>\n\n<p>扩展运算符用在元组的任意位置都可以，但是只能扩展数组或元组。</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>函数的类型声明，需要给出参数和返回值的类型</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">a</span>: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-built_in\">number</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里两个参数<code>a</code>、<code>b</code>类型都为<code>number</code>，以及返回值的类型<code>number</code>，返回值类型写在参数列表的圆括号后面。</p>\n<p>我们也可以使用函数表达式进行声明</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">//方式一</span><br><span class=\"hljs-keyword\">const</span> fn = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"><span class=\"hljs-attr\">a</span>: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-built_in\">number</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;;<br><span class=\"hljs-comment\">//方式二</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">fn</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">a</span>: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a, b</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>这里的两种方式都可以实现，第一种是通过等号右边来推断<code>fn</code>的类型，第二种则是直接指明了<code>fn</code>的类型。</p>\n<p>返回值类型通常可以不写，TS 会自己推断出来，如果没写<code>return</code>语句，会推断为没有返回值</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d54abea603554da3a2b998bbf727de04~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=494&h=138&s=13079&e=png&b=1f1f1f\" alt=\"image.png\" width=\"50%\" />\n\n<h3 id=\"void-类型\"><a href=\"#void-类型\" class=\"headerlink\" title=\"void 类型\"></a>void 类型</h3><p>void 类型表示函数没有返回值。如果你学过 c 语言，那你一定不会陌生。</p>\n<p>在 TS 中<code>void</code>并不代表不能写<code>return</code>语句，它允许返回<code>undefined</code>或<code>null</code>（<code>null</code>需要关闭严格模式），因为它俩在 TS 看来也是相当于没有返回值。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn3</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">a</span>: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-built_in\">void</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">undefined</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>但是如果你返回其它类型就会报错</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">a</span>: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-built_in\">void</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> a + b; <span class=\"hljs-comment\">//报错</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76765d6f43fc4fabb8edf79d0ebc8efa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=569&h=162&s=18617&e=png&b=272728\" alt=\"image.png\" width=\"70%\" />\n\n<h3 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h3><p>有些函数可以接受不同类型或不同个数的参数，并且根据参数的不同，会有不同的函数行为。这种根据参数类型不同，执行不同逻辑的行为，称为函数重载。</p>\n<p>这里我们想实现一个函数，不管你传入的是数组还是字符串，我都希望它返回一个反转后的结果</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-title function_\">reverse</span>(<span class=\"hljs-string\">&quot;abc&quot;</span>); <span class=\"hljs-comment\">// &#x27;cba&#x27;</span><br><span class=\"hljs-title function_\">reverse</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]); <span class=\"hljs-comment\">// [3, 2, 1]</span><br></code></pre></td></tr></table></figure>\n\n<p>首先我们逐一定义每一种情况的类型</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">reverse</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">str</span>: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-built_in\">string</span>;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">reverse</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">arr</span>: <span class=\"hljs-built_in\">any</span>[]</span>): <span class=\"hljs-built_in\">any</span>[];<br></code></pre></td></tr></table></figure>\n\n<p>然后给予函数完整的类型声明</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">reverse</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">stringOrArray</span>: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">any</span>[]</span>): <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">any</span>[] &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> stringOrArray === <span class=\"hljs-string\">&quot;string&quot;</span>)<br>    <span class=\"hljs-keyword\">return</span> stringOrArray.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&quot;&quot;</span>).<span class=\"hljs-title function_\">reverse</span>().<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&quot;&quot;</span>);<br>  <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> stringOrArray.<span class=\"hljs-title function_\">slice</span>().<span class=\"hljs-title function_\">reverse</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>效果如下</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">reverse</span>([<span class=\"hljs-string\">&quot;🐂&quot;</span>, <span class=\"hljs-string\">&quot;🐑&quot;</span>, <span class=\"hljs-string\">&quot;🐎&quot;</span>, <span class=\"hljs-string\">&quot;🐒&quot;</span>])); <span class=\"hljs-comment\">//[ &#x27;🐒&#x27;, &#x27;🐎&#x27;, &#x27;🐑&#x27;, &#x27;🐂&#x27; ]</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">reverse</span>(<span class=\"hljs-string\">&quot;牛羊马猴&quot;</span>)); <span class=\"hljs-comment\">//猴马羊牛</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"type-命令\"><a href=\"#type-命令\" class=\"headerlink\" title=\"type 命令\"></a>type 命令</h2><p>TS 允许我们用 type 来定义一个类型别名，我们习惯使用大驼峰命名方式进行命名。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Name</span> = <span class=\"hljs-built_in\">string</span>;<br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">Name</span> = <span class=\"hljs-string\">&quot;阳阳羊&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这样<code>Age</code>就能像使用<code>number</code>一样作为类型来使用</p>\n<p>别名不允许重名，拿值类型来举例</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Color</span> = <span class=\"hljs-string\">&quot;红&quot;</span>;<br><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Color</span> = <span class=\"hljs-string\">&quot;绿&quot;</span>; <span class=\"hljs-comment\">//报错</span><br></code></pre></td></tr></table></figure>\n\n<p>如果一些类型定义很冗长，我们往往会用 type 命令为函数类型定义一个别名。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">MyFunc</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">a</span>: <span class=\"hljs-built_in\">string</span></span>) =&gt;</span> <span class=\"hljs-built_in\">void</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">fn</span>: <span class=\"hljs-title class_\">MyFunc</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;hello &quot;</span> + a);<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"interface-接口\"><a href=\"#interface-接口\" class=\"headerlink\" title=\"interface 接口\"></a>interface 接口</h2><p>interface 是对象的模板，可以看作是一种类型约定，中文译为“接口”。使用了某个模板的对象，就拥有了指定的类型结构。</p>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Person</span> &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里我们定义了一个接口<code>Person</code>，两个属性<code>name</code>和<code>age</code>，任何实现这个接口的对象都必须具有这两个属性，并符合规定类型。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">me</span>: <span class=\"hljs-title class_\">Person</span> = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;阳阳羊&quot;</span>,<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">21</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>如果属性和类型有一个不符就会报错。</p>\n<p>如果你希望属性是可选的，则可以使用<code>?</code>可选操作符，只读可以使用<code>readonly</code>修饰符</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Person</span> &#123;<br>  name?: <span class=\"hljs-string\">&quot;阳阳羊&quot;</span>;<br>  <span class=\"hljs-keyword\">readonly</span> <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">21</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>除了属性外，接口还允许我们定义对象的方法</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Person</span> &#123;<br>  <span class=\"hljs-title function_\">say</span>(<span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">string</span>): <span class=\"hljs-built_in\">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"函数-1\"><a href=\"#函数-1\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>接口也可以用来声明独立的函数</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Add</span> &#123;<br>  (<span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-built_in\">number</span>;<br>&#125;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">myAdd</span>: <span class=\"hljs-title class_\">Add</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">x, y</span>) =&gt;</span> x + y;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>接口可以使用<code>extends</code>关键字实现继承</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>  <span class=\"hljs-attr\">color</span>: <span class=\"hljs-built_in\">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>extends</code>关键字会从继承的接口里面拷贝属性类型，这样就不必书写重复的属性</p>\n<p>如果子接口与父接口存在同名属性，那么子接口的属性会覆盖父接口的属性。前提是不能有冲突，属性方法他们的类型得是一致的，不然会报错</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>  <span class=\"hljs-attr\">color</span>: <span class=\"hljs-built_in\">string</span>;<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">bigint</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里存在同名属性，但是类型不一致</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3634c66ca59942e287f2cde4ae39687c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=519&h=226&s=30080&e=png&b=272728\" alt=\"image.png\"></p>\n<h3 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并\"></a>合并</h3><p>多个同名接口会合并成一个接口</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Box</span> &#123;<br>  <span class=\"hljs-attr\">height</span>: <span class=\"hljs-built_in\">number</span>;<br>  <span class=\"hljs-attr\">width</span>: <span class=\"hljs-built_in\">number</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Box</span> &#123;<br>  <span class=\"hljs-attr\">length</span>: <span class=\"hljs-built_in\">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>两个<code>Box</code>接口会合并成一个接口，同时有<code>height</code>、<code>width</code>和<code>length</code>三个属性。前提仍然是不能有冲突。</p>\n<h3 id=\"和-type-的区别\"><a href=\"#和-type-的区别\" class=\"headerlink\" title=\"和 type 的区别\"></a>和 type 的区别</h3><p>（1）<code>type</code>能够表示非对象类型，而<code>interface</code>只能表示对象类型（包括数组、函数等）。</p>\n<p>（2）<code>interface</code>可以继承其他类型，<code>type</code>不支持继承。</p>\n<p>（3）同名<code>interface</code>会自动合并，同名<code>type</code>则会报错。也就是说，TypeScript 不允许使用<code>type</code>多次定义同一个类型。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://typescript.p6p.net/typescript-tutorial/types.html\">阮一峰 TypeScript 教程</a></li>\n<li><a href=\"https://www.typescriptlang.org/\">TypeScript 官方文档</a></li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>以上是对 TS 进阶类型的基本介绍，内容相对于基础，对于新同学来说比较友好，后面我会继续更新进阶知识，关于类、泛型、Enum 类型等等，可以收藏本站，我会持续更新。</p>\n<p>已将学习代码上传至 <a href=\"https://github.com/YangyangU/CodeSpace\">github</a>，欢迎大家学习指正！</p>\n"},{"title":"快速上手 TS（基础类型篇）","date":"2024-07-02T08:00:00.000Z","index_img":"/img/ts.png","banner_img":"/img/default.png","_content":"\n## 前言\n\n- [快速上手 TS（环境篇）- 掘金 (juejin.cn)](https://juejin.cn/post/7383643463532953619)\n\n上一篇中我介绍了 TS 从安装到运行的环境配置，希望能够对你带来帮助。今天我们来学习一下 TS 的一些基本知识，TS 知识可多了，一篇文章当然不能涵盖，所以我会写多篇文章进行介绍，希望我能坚持更新，更希望你能坚持看下去！\n\n## 基本用法\n\n你在写 JS 的时候有没有想过这样一个问题：为什么 JS 不用写类型，不写类型带来的后果是什么？如果你尝试写过任意一门后端语言，你就会发现，每个类型都有自己声明的方式，而不是一味的 let、const，换句话说，弱类型会导致什么后果？\n\nJS 设计之初的目标是成为一种简单易用的脚本语言，能够让非专业程序员快速学习，因此，JS 遵循动态类型系统，如果代码出现错误，只能在运行时才能发现，而 TS 跟一些后端语言一样提供的静态类型检测，能够在编译时就发现错误，避免一些不必要的失误。\n\n### 类型声明\n\nTS 允许我们在 JS 的基础上对变量进行声明\n\n```ts\nlet str: string;\n```\n\n这段代码中，TS 允许我们在声明的变量后面用`:`接类型，表示我们声明了一个什么类型的变量。\n\n如果你给变量赋的值不属于该类型，就会报错\n\n```ts\nlet str: string = 123; //报错\n```\n\n这里我们把数字`123`赋给一个声明为`string`的变量，就会报错。\n\n另外，如果变量在赋值之前被使用了，也会报错\n\n```ts\nlet str: string;\nconsole.log(str); //报错\n```\n\n如果在 JS 环境则不会报错，而是打印 `undefined`\n\n### 类型推断\n\n类型声明不是必须的，因为 TS 可以根据你的赋值推断出类型，这是 TS 比较厉害的一点\n\n如果你正常的像\n\n```ts\nlet num = 123;\n```\n\n你把鼠标放到上面就能看到它被推断出的类型\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8916287c61914b15a727d482e6434583~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=259&h=96&s=4237&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n另外，它还能推断出返回值的类型\n\n```ts\nconst fn = (str: string) => {\n  return Number(str);\n};\n```\n\n我们只需要知道这里用 TS 声明了一个函数（关于函数具体如何声明后面会讲），接收一个 string 类型的参数 str，但是没有声明返回值的类型，TS 自己推断出来了\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e045d1f88e548c0885a85125fbd455f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=472&h=133&s=12681&e=png&b=1f1f1f\" alt=\"image.png\" width=\"50%\" />\n\n这里可以看出，类型声明是可选的，你可以加，也可以不加，只是不能保证 TS 会正确推断出类型。\n\n## 类型系统\n\nTS 继承了 JS 的类型，在这个基础上进行升级，形成了一套自己的类型系统\n\n### 基本类型\n\n我们知道 JS 有七大基本类型和对象类型，下面我会将每一个类型都拎出来讲\n\n```ts\nconst num: number = 123;\nconst str: string = \"123\";\nconst flag: boolean = true;\nconst bigint: bigint = 123n;\nconst symbol: symbol = Symbol(\"123\");\nconst un: undefined = undefined;\nconst nu: null = null;\n```\n\n#### number 类型\n\nnumber 类型包含所有整数和浮点数\n\n```ts\nconst x: number = 123;\nconst y: number = 3.14;\nconst z: number = 0xffff;\n```\n\n#### string 类型\n\n普通字符串和模板字符串都属于 string 类型\n\n```ts\nconst x: string = \"hello\";\nconst y: string = `${x} world`;\n```\n\n#### boolean 类型\n\nboolean 类型只包含`true`和`false`，就没什么好说的了\n\n```ts\nconst x: boolean = true;\nconst y: boolean = false;\n```\n\n#### bigint 类型\n\nbigint 类型包含所有的大整数\n\n```ts\nconst x: bigint = 123n;\nconst y: bigint = 0xffffn;\n```\n\n但是要注意的是 bigint 与 number 相互不兼容，意思是当给 bigint 类型赋值 number 时会报错，反过来也是。\n\n#### symbol 类型\n\nsymbol 类型包含所有的 Symbol 值，用的较少，咱们就一笔带过\n\n```ts\nconst x: symbol = Symbol();\n```\n\n#### undefined 和 null 类型\n\n如果没有声明类型的变量，被赋值为`undefined`或`null`，默认情况下它们的类型会被推断为`any`。\n\n```ts\nlet a = undefined; // any\nconst b = undefined; // any\n\nlet c = null; // any\nconst d = null; // any\n```\n\n如果希望避免这种情况，则需要打开编译选项`strictNullChecks`。\n\n```ts\n// 打开编译设置 strictNullChecks\nlet a = undefined; // undefined\nconst b = undefined; // undefined\n\nlet c = null; // null\nconst d = null; // null\n```\n\n将所有类型都列出来大概就这么多，看起来好像跟 JS 没多大差别，就加了个类型声明罢了，真的是这样吗，咱们接着往下看\n\n### any、unknown、never 类型\n\nTS 新增了 any、unknown 和 never 三种类型，分别有着不同的应用场景\n\n#### any 类型\n\nany 类型的变量可以被赋为任何值\n\n```ts\nlet x: any;\n\nx = 1;\nx = \"阳阳羊\";\nx = true;\n```\n\n这个类型一般不推荐使用，因为 TS 不会对 any 类型的变量进行类型检查，即使有明显的类型错误，只要句法正确，都不会报错。意思你声明的 string 类型变量甚至可以拿来当函数给调用掉，并且都不会报错。\n\n```ts\nlet x: any = \"阳阳羊\";\nx(1);\n```\n\n如果每个变量类型都是 any，就失去了 TypeScript 的意义，直接写 JS 就好了 😂\n\n#### unknown 类型\n\n`unknown`类型的变量，不能直接赋值给其他类型的变量（除了`any`类型和`unknown`类型）\n\n避免了污染问题\n\n不能直接调用`unknown`类型变量的方法和属性\n\n可以赋值给任意其他类型\n\n#### never 类型\n\n意为空类型，不可能有这样的值，不可能赋给它任何值，否则都会报错。后面会用交叉类型进行举例\n\n### 对象类型\n\n在 JS 中我们将非基本类型的类型统称为对象类型，这其中包括了对象、数组、函数、包装类、正则等等\n\n#### Object 与 object 类型\n\n为什么要区分大小写呢？这是因为我们将 Object 称为广义上的对象，它囊括了几乎所有的值，原始类型值、对象、数组、函数都是合法的`Object`类型，除了`undefined`和`null`不能转为对象\n\n```ts\nlet obj: Object;\n\nobj = true;\nobj = \"hi\";\nobj = 1;\nobj = { foo: 123 };\nobj = [1, 2];\nobj = (a: number) => a + 1;\nobj = undefined; // 报错\nobj = null; // 报错\n```\n\n而小写的 object 就是我们狭义说的对象，即可以用字面量表示的对象，只包含对象、数组和函数，不包括原始类型的值。\n\n```ts\nconst x: object = { foo: 123 };\nconst y: object = [1, 2, 3];\nconst z: object = (n: number) => n + 1;\n```\n\n#### 包装类对象\n\n由于包装对象的存在，导致每一个原始类型的值都有包装对象和字面量两种情况。\n\n```ts\n\"hello\"; // 字面量\nnew String(\"hello\"); // 包装类对象\n```\n\n为了进行区分，TS 对五种原始类型分别提供了大写和小写两种类型。\n\n- Boolean 和 boolean\n- String 和 string\n- Number 和 number\n- BigInt 和 bigint\n- Symbol 和 symbol\n\n大写类型同时包含包装对象和字面量两种情况，小写类型只包含字面量，不包含包装对象。\n\n```ts\nconst s1: String = \"hello\"; // 正确\nconst s2: String = new String(\"hello\"); // 正确\n\nconst s3: string = \"hello\"; // 正确\nconst s4: string = new String(\"hello\"); // 报错\n```\n\n这里`String`类型可以赋值为字符串的字面量，也可以赋值为包装对象。但是，`string`类型只能赋值为字面量，赋值为包装对象就会报错。\n\n### 值类型\n\nTS 允许一个值成为一个类型\n\n```ts\nconst x: \"hello\" = \"hello\";\n```\n\n用`const`声明的变量，如果没有注明类型，则会把它推断为值类型\n\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffd019c1c25744bea099dad24fedd652~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=286&h=88&s=5528&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n而`let`则不会\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05d2a56546814fd2b3121395ad2ec747~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=234&h=94&s=4604&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n这个原因显而易见，因为`const`声明的变量不可修改，即常量，但如果声明是对象的话，那就另外谈了，因为对象存的是地址，属性值可以改变，所以并不会推断为值类型。\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06c5d56dd8c845f78aeb2dd3fd8b8ea5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=373&h=191&s=9037&e=png&b=1e1e1e\" alt=\"image.png\" width=\"50%\" />\n\n### 联合类型\n\n联合类型指的是多个类型组成的一个新类型，使用符号`|`拼接。我们知道`|`是`或`的意思，所以`A|B`的意思是只要属于`A`或`B`其中一个就行了。\n\n```ts\nlet x: string | number;\n\nx = 123; // 正确\nx = \"abc\"; // 正确\n```\n\n当联合类型与值类型结合，就可以表示一个变量可能有多个值。\n\n```ts\nlet color: \"红\" | \"黄\" | \"绿\";\n```\n\n### 交叉类型\n\n有`|`当然有`&`，不出所料这个意思应该是`与`。`A&B`表示，任何一个类型必须同时属于`A`和`B`。\n\n```ts\nlet z: number & string;\n```\n\n什么类型能兼具`number`和`string`？\n\n当然是不存在的，TS 新增了一个类型表示不存在的`never`，这里也可以用它来声明\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1df706673b3a4e2a928eb67083144c21~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=271&h=99&s=5356&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n交叉类型的主要用途是表示对象的合成。\n\n```ts\nlet person: { name: string } & { age: number };\n\nperson = {\n  name: \"阳阳羊\",\n  age: 21,\n};\n```\n\n## 参考\n\n- [阮一峰 TypeScript 教程](https://typescript.p6p.net/typescript-tutorial/types.html)\n- [TypeScript 官方文档](https://www.typescriptlang.org/)\n\n## 最后\n\n以上是对 TS 类型的简单介绍，对于新同学来说应该很容易入手，后面我会继续更新进阶知识，关于 type、元祖、接口、泛型等等，我会持续更新。\n","source":"_posts/快速上手 TS（基础类型篇）.md","raw":"---\ntitle: 快速上手 TS（基础类型篇）\ndate: 2024-07-02 16:00:00\ntags: [TypeScript]\ncategories: TypeScript\nindex_img: /img/ts.png\nbanner_img: /img/default.png\n---\n\n## 前言\n\n- [快速上手 TS（环境篇）- 掘金 (juejin.cn)](https://juejin.cn/post/7383643463532953619)\n\n上一篇中我介绍了 TS 从安装到运行的环境配置，希望能够对你带来帮助。今天我们来学习一下 TS 的一些基本知识，TS 知识可多了，一篇文章当然不能涵盖，所以我会写多篇文章进行介绍，希望我能坚持更新，更希望你能坚持看下去！\n\n## 基本用法\n\n你在写 JS 的时候有没有想过这样一个问题：为什么 JS 不用写类型，不写类型带来的后果是什么？如果你尝试写过任意一门后端语言，你就会发现，每个类型都有自己声明的方式，而不是一味的 let、const，换句话说，弱类型会导致什么后果？\n\nJS 设计之初的目标是成为一种简单易用的脚本语言，能够让非专业程序员快速学习，因此，JS 遵循动态类型系统，如果代码出现错误，只能在运行时才能发现，而 TS 跟一些后端语言一样提供的静态类型检测，能够在编译时就发现错误，避免一些不必要的失误。\n\n### 类型声明\n\nTS 允许我们在 JS 的基础上对变量进行声明\n\n```ts\nlet str: string;\n```\n\n这段代码中，TS 允许我们在声明的变量后面用`:`接类型，表示我们声明了一个什么类型的变量。\n\n如果你给变量赋的值不属于该类型，就会报错\n\n```ts\nlet str: string = 123; //报错\n```\n\n这里我们把数字`123`赋给一个声明为`string`的变量，就会报错。\n\n另外，如果变量在赋值之前被使用了，也会报错\n\n```ts\nlet str: string;\nconsole.log(str); //报错\n```\n\n如果在 JS 环境则不会报错，而是打印 `undefined`\n\n### 类型推断\n\n类型声明不是必须的，因为 TS 可以根据你的赋值推断出类型，这是 TS 比较厉害的一点\n\n如果你正常的像\n\n```ts\nlet num = 123;\n```\n\n你把鼠标放到上面就能看到它被推断出的类型\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8916287c61914b15a727d482e6434583~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=259&h=96&s=4237&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n另外，它还能推断出返回值的类型\n\n```ts\nconst fn = (str: string) => {\n  return Number(str);\n};\n```\n\n我们只需要知道这里用 TS 声明了一个函数（关于函数具体如何声明后面会讲），接收一个 string 类型的参数 str，但是没有声明返回值的类型，TS 自己推断出来了\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e045d1f88e548c0885a85125fbd455f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=472&h=133&s=12681&e=png&b=1f1f1f\" alt=\"image.png\" width=\"50%\" />\n\n这里可以看出，类型声明是可选的，你可以加，也可以不加，只是不能保证 TS 会正确推断出类型。\n\n## 类型系统\n\nTS 继承了 JS 的类型，在这个基础上进行升级，形成了一套自己的类型系统\n\n### 基本类型\n\n我们知道 JS 有七大基本类型和对象类型，下面我会将每一个类型都拎出来讲\n\n```ts\nconst num: number = 123;\nconst str: string = \"123\";\nconst flag: boolean = true;\nconst bigint: bigint = 123n;\nconst symbol: symbol = Symbol(\"123\");\nconst un: undefined = undefined;\nconst nu: null = null;\n```\n\n#### number 类型\n\nnumber 类型包含所有整数和浮点数\n\n```ts\nconst x: number = 123;\nconst y: number = 3.14;\nconst z: number = 0xffff;\n```\n\n#### string 类型\n\n普通字符串和模板字符串都属于 string 类型\n\n```ts\nconst x: string = \"hello\";\nconst y: string = `${x} world`;\n```\n\n#### boolean 类型\n\nboolean 类型只包含`true`和`false`，就没什么好说的了\n\n```ts\nconst x: boolean = true;\nconst y: boolean = false;\n```\n\n#### bigint 类型\n\nbigint 类型包含所有的大整数\n\n```ts\nconst x: bigint = 123n;\nconst y: bigint = 0xffffn;\n```\n\n但是要注意的是 bigint 与 number 相互不兼容，意思是当给 bigint 类型赋值 number 时会报错，反过来也是。\n\n#### symbol 类型\n\nsymbol 类型包含所有的 Symbol 值，用的较少，咱们就一笔带过\n\n```ts\nconst x: symbol = Symbol();\n```\n\n#### undefined 和 null 类型\n\n如果没有声明类型的变量，被赋值为`undefined`或`null`，默认情况下它们的类型会被推断为`any`。\n\n```ts\nlet a = undefined; // any\nconst b = undefined; // any\n\nlet c = null; // any\nconst d = null; // any\n```\n\n如果希望避免这种情况，则需要打开编译选项`strictNullChecks`。\n\n```ts\n// 打开编译设置 strictNullChecks\nlet a = undefined; // undefined\nconst b = undefined; // undefined\n\nlet c = null; // null\nconst d = null; // null\n```\n\n将所有类型都列出来大概就这么多，看起来好像跟 JS 没多大差别，就加了个类型声明罢了，真的是这样吗，咱们接着往下看\n\n### any、unknown、never 类型\n\nTS 新增了 any、unknown 和 never 三种类型，分别有着不同的应用场景\n\n#### any 类型\n\nany 类型的变量可以被赋为任何值\n\n```ts\nlet x: any;\n\nx = 1;\nx = \"阳阳羊\";\nx = true;\n```\n\n这个类型一般不推荐使用，因为 TS 不会对 any 类型的变量进行类型检查，即使有明显的类型错误，只要句法正确，都不会报错。意思你声明的 string 类型变量甚至可以拿来当函数给调用掉，并且都不会报错。\n\n```ts\nlet x: any = \"阳阳羊\";\nx(1);\n```\n\n如果每个变量类型都是 any，就失去了 TypeScript 的意义，直接写 JS 就好了 😂\n\n#### unknown 类型\n\n`unknown`类型的变量，不能直接赋值给其他类型的变量（除了`any`类型和`unknown`类型）\n\n避免了污染问题\n\n不能直接调用`unknown`类型变量的方法和属性\n\n可以赋值给任意其他类型\n\n#### never 类型\n\n意为空类型，不可能有这样的值，不可能赋给它任何值，否则都会报错。后面会用交叉类型进行举例\n\n### 对象类型\n\n在 JS 中我们将非基本类型的类型统称为对象类型，这其中包括了对象、数组、函数、包装类、正则等等\n\n#### Object 与 object 类型\n\n为什么要区分大小写呢？这是因为我们将 Object 称为广义上的对象，它囊括了几乎所有的值，原始类型值、对象、数组、函数都是合法的`Object`类型，除了`undefined`和`null`不能转为对象\n\n```ts\nlet obj: Object;\n\nobj = true;\nobj = \"hi\";\nobj = 1;\nobj = { foo: 123 };\nobj = [1, 2];\nobj = (a: number) => a + 1;\nobj = undefined; // 报错\nobj = null; // 报错\n```\n\n而小写的 object 就是我们狭义说的对象，即可以用字面量表示的对象，只包含对象、数组和函数，不包括原始类型的值。\n\n```ts\nconst x: object = { foo: 123 };\nconst y: object = [1, 2, 3];\nconst z: object = (n: number) => n + 1;\n```\n\n#### 包装类对象\n\n由于包装对象的存在，导致每一个原始类型的值都有包装对象和字面量两种情况。\n\n```ts\n\"hello\"; // 字面量\nnew String(\"hello\"); // 包装类对象\n```\n\n为了进行区分，TS 对五种原始类型分别提供了大写和小写两种类型。\n\n- Boolean 和 boolean\n- String 和 string\n- Number 和 number\n- BigInt 和 bigint\n- Symbol 和 symbol\n\n大写类型同时包含包装对象和字面量两种情况，小写类型只包含字面量，不包含包装对象。\n\n```ts\nconst s1: String = \"hello\"; // 正确\nconst s2: String = new String(\"hello\"); // 正确\n\nconst s3: string = \"hello\"; // 正确\nconst s4: string = new String(\"hello\"); // 报错\n```\n\n这里`String`类型可以赋值为字符串的字面量，也可以赋值为包装对象。但是，`string`类型只能赋值为字面量，赋值为包装对象就会报错。\n\n### 值类型\n\nTS 允许一个值成为一个类型\n\n```ts\nconst x: \"hello\" = \"hello\";\n```\n\n用`const`声明的变量，如果没有注明类型，则会把它推断为值类型\n\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffd019c1c25744bea099dad24fedd652~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=286&h=88&s=5528&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n而`let`则不会\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05d2a56546814fd2b3121395ad2ec747~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=234&h=94&s=4604&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n这个原因显而易见，因为`const`声明的变量不可修改，即常量，但如果声明是对象的话，那就另外谈了，因为对象存的是地址，属性值可以改变，所以并不会推断为值类型。\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06c5d56dd8c845f78aeb2dd3fd8b8ea5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=373&h=191&s=9037&e=png&b=1e1e1e\" alt=\"image.png\" width=\"50%\" />\n\n### 联合类型\n\n联合类型指的是多个类型组成的一个新类型，使用符号`|`拼接。我们知道`|`是`或`的意思，所以`A|B`的意思是只要属于`A`或`B`其中一个就行了。\n\n```ts\nlet x: string | number;\n\nx = 123; // 正确\nx = \"abc\"; // 正确\n```\n\n当联合类型与值类型结合，就可以表示一个变量可能有多个值。\n\n```ts\nlet color: \"红\" | \"黄\" | \"绿\";\n```\n\n### 交叉类型\n\n有`|`当然有`&`，不出所料这个意思应该是`与`。`A&B`表示，任何一个类型必须同时属于`A`和`B`。\n\n```ts\nlet z: number & string;\n```\n\n什么类型能兼具`number`和`string`？\n\n当然是不存在的，TS 新增了一个类型表示不存在的`never`，这里也可以用它来声明\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1df706673b3a4e2a928eb67083144c21~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=271&h=99&s=5356&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n交叉类型的主要用途是表示对象的合成。\n\n```ts\nlet person: { name: string } & { age: number };\n\nperson = {\n  name: \"阳阳羊\",\n  age: 21,\n};\n```\n\n## 参考\n\n- [阮一峰 TypeScript 教程](https://typescript.p6p.net/typescript-tutorial/types.html)\n- [TypeScript 官方文档](https://www.typescriptlang.org/)\n\n## 最后\n\n以上是对 TS 类型的简单介绍，对于新同学来说应该很容易入手，后面我会继续更新进阶知识，关于 type、元祖、接口、泛型等等，我会持续更新。\n","slug":"快速上手 TS（基础类型篇）","published":1,"updated":"2024-09-09T15:30:42.776Z","_id":"clywvnv1q000618v64uykds4d","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ul>\n<li><a href=\"https://juejin.cn/post/7383643463532953619\">快速上手 TS（环境篇）- 掘金 (juejin.cn)</a></li>\n</ul>\n<p>上一篇中我介绍了 TS 从安装到运行的环境配置，希望能够对你带来帮助。今天我们来学习一下 TS 的一些基本知识，TS 知识可多了，一篇文章当然不能涵盖，所以我会写多篇文章进行介绍，希望我能坚持更新，更希望你能坚持看下去！</p>\n<h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>你在写 JS 的时候有没有想过这样一个问题：为什么 JS 不用写类型，不写类型带来的后果是什么？如果你尝试写过任意一门后端语言，你就会发现，每个类型都有自己声明的方式，而不是一味的 let、const，换句话说，弱类型会导致什么后果？</p>\n<p>JS 设计之初的目标是成为一种简单易用的脚本语言，能够让非专业程序员快速学习，因此，JS 遵循动态类型系统，如果代码出现错误，只能在运行时才能发现，而 TS 跟一些后端语言一样提供的静态类型检测，能够在编译时就发现错误，避免一些不必要的失误。</p>\n<h3 id=\"类型声明\"><a href=\"#类型声明\" class=\"headerlink\" title=\"类型声明\"></a>类型声明</h3><p>TS 允许我们在 JS 的基础上对变量进行声明</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">str</span>: <span class=\"hljs-built_in\">string</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这段代码中，TS 允许我们在声明的变量后面用<code>:</code>接类型，表示我们声明了一个什么类型的变量。</p>\n<p>如果你给变量赋的值不属于该类型，就会报错</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">str</span>: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-number\">123</span>; <span class=\"hljs-comment\">//报错</span><br></code></pre></td></tr></table></figure>\n\n<p>这里我们把数字<code>123</code>赋给一个声明为<code>string</code>的变量，就会报错。</p>\n<p>另外，如果变量在赋值之前被使用了，也会报错</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">str</span>: <span class=\"hljs-built_in\">string</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str); <span class=\"hljs-comment\">//报错</span><br></code></pre></td></tr></table></figure>\n\n<p>如果在 JS 环境则不会报错，而是打印 <code>undefined</code></p>\n<h3 id=\"类型推断\"><a href=\"#类型推断\" class=\"headerlink\" title=\"类型推断\"></a>类型推断</h3><p>类型声明不是必须的，因为 TS 可以根据你的赋值推断出类型，这是 TS 比较厉害的一点</p>\n<p>如果你正常的像</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> num = <span class=\"hljs-number\">123</span>;<br></code></pre></td></tr></table></figure>\n\n<p>你把鼠标放到上面就能看到它被推断出的类型</p>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8916287c61914b15a727d482e6434583~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=259&h=96&s=4237&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n<p>另外，它还能推断出返回值的类型</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">fn</span> = (<span class=\"hljs-params\"><span class=\"hljs-attr\">str</span>: <span class=\"hljs-built_in\">string</span></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Number</span>(str);<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>我们只需要知道这里用 TS 声明了一个函数（关于函数具体如何声明后面会讲），接收一个 string 类型的参数 str，但是没有声明返回值的类型，TS 自己推断出来了</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e045d1f88e548c0885a85125fbd455f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=472&h=133&s=12681&e=png&b=1f1f1f\" alt=\"image.png\" width=\"50%\" />\n\n<p>这里可以看出，类型声明是可选的，你可以加，也可以不加，只是不能保证 TS 会正确推断出类型。</p>\n<h2 id=\"类型系统\"><a href=\"#类型系统\" class=\"headerlink\" title=\"类型系统\"></a>类型系统</h2><p>TS 继承了 JS 的类型，在这个基础上进行升级，形成了一套自己的类型系统</p>\n<h3 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a>基本类型</h3><p>我们知道 JS 有七大基本类型和对象类型，下面我会将每一个类型都拎出来讲</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">num</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">123</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">str</span>: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&quot;123&quot;</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">flag</span>: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">true</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">bigint</span>: <span class=\"hljs-built_in\">bigint</span> = <span class=\"hljs-number\">123n</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">symbol</span>: <span class=\"hljs-built_in\">symbol</span> = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&quot;123&quot;</span>);<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">un</span>: <span class=\"hljs-literal\">undefined</span> = <span class=\"hljs-literal\">undefined</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">nu</span>: <span class=\"hljs-literal\">null</span> = <span class=\"hljs-literal\">null</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"number-类型\"><a href=\"#number-类型\" class=\"headerlink\" title=\"number 类型\"></a>number 类型</h4><p>number 类型包含所有整数和浮点数</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">123</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">y</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">3.14</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">z</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">0xffff</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"string-类型\"><a href=\"#string-类型\" class=\"headerlink\" title=\"string 类型\"></a>string 类型</h4><p>普通字符串和模板字符串都属于 string 类型</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&quot;hello&quot;</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">y</span>: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;x&#125;</span> world`</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"boolean-类型\"><a href=\"#boolean-类型\" class=\"headerlink\" title=\"boolean 类型\"></a>boolean 类型</h4><p>boolean 类型只包含<code>true</code>和<code>false</code>，就没什么好说的了</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">true</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">y</span>: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">false</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"bigint-类型\"><a href=\"#bigint-类型\" class=\"headerlink\" title=\"bigint 类型\"></a>bigint 类型</h4><p>bigint 类型包含所有的大整数</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">bigint</span> = <span class=\"hljs-number\">123n</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">y</span>: <span class=\"hljs-built_in\">bigint</span> = <span class=\"hljs-number\">0xffffn</span>;<br></code></pre></td></tr></table></figure>\n\n<p>但是要注意的是 bigint 与 number 相互不兼容，意思是当给 bigint 类型赋值 number 时会报错，反过来也是。</p>\n<h4 id=\"symbol-类型\"><a href=\"#symbol-类型\" class=\"headerlink\" title=\"symbol 类型\"></a>symbol 类型</h4><p>symbol 类型包含所有的 Symbol 值，用的较少，咱们就一笔带过</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">symbol</span> = <span class=\"hljs-title class_\">Symbol</span>();<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"undefined-和-null-类型\"><a href=\"#undefined-和-null-类型\" class=\"headerlink\" title=\"undefined 和 null 类型\"></a>undefined 和 null 类型</h4><p>如果没有声明类型的变量，被赋值为<code>undefined</code>或<code>null</code>，默认情况下它们的类型会被推断为<code>any</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// any</span><br><span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// any</span><br><br><span class=\"hljs-keyword\">let</span> c = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// any</span><br><span class=\"hljs-keyword\">const</span> d = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// any</span><br></code></pre></td></tr></table></figure>\n\n<p>如果希望避免这种情况，则需要打开编译选项<code>strictNullChecks</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 打开编译设置 strictNullChecks</span><br><span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// undefined</span><br><span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// undefined</span><br><br><span class=\"hljs-keyword\">let</span> c = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// null</span><br><span class=\"hljs-keyword\">const</span> d = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// null</span><br></code></pre></td></tr></table></figure>\n\n<p>将所有类型都列出来大概就这么多，看起来好像跟 JS 没多大差别，就加了个类型声明罢了，真的是这样吗，咱们接着往下看</p>\n<h3 id=\"any、unknown、never-类型\"><a href=\"#any、unknown、never-类型\" class=\"headerlink\" title=\"any、unknown、never 类型\"></a>any、unknown、never 类型</h3><p>TS 新增了 any、unknown 和 never 三种类型，分别有着不同的应用场景</p>\n<h4 id=\"any-类型\"><a href=\"#any-类型\" class=\"headerlink\" title=\"any 类型\"></a>any 类型</h4><p>any 类型的变量可以被赋为任何值</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">any</span>;<br><br>x = <span class=\"hljs-number\">1</span>;<br>x = <span class=\"hljs-string\">&quot;阳阳羊&quot;</span>;<br>x = <span class=\"hljs-literal\">true</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这个类型一般不推荐使用，因为 TS 不会对 any 类型的变量进行类型检查，即使有明显的类型错误，只要句法正确，都不会报错。意思你声明的 string 类型变量甚至可以拿来当函数给调用掉，并且都不会报错。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">any</span> = <span class=\"hljs-string\">&quot;阳阳羊&quot;</span>;<br><span class=\"hljs-title function_\">x</span>(<span class=\"hljs-number\">1</span>);<br></code></pre></td></tr></table></figure>\n\n<p>如果每个变量类型都是 any，就失去了 TypeScript 的意义，直接写 JS 就好了 😂</p>\n<h4 id=\"unknown-类型\"><a href=\"#unknown-类型\" class=\"headerlink\" title=\"unknown 类型\"></a>unknown 类型</h4><p><code>unknown</code>类型的变量，不能直接赋值给其他类型的变量（除了<code>any</code>类型和<code>unknown</code>类型）</p>\n<p>避免了污染问题</p>\n<p>不能直接调用<code>unknown</code>类型变量的方法和属性</p>\n<p>可以赋值给任意其他类型</p>\n<h4 id=\"never-类型\"><a href=\"#never-类型\" class=\"headerlink\" title=\"never 类型\"></a>never 类型</h4><p>意为空类型，不可能有这样的值，不可能赋给它任何值，否则都会报错。后面会用交叉类型进行举例</p>\n<h3 id=\"对象类型\"><a href=\"#对象类型\" class=\"headerlink\" title=\"对象类型\"></a>对象类型</h3><p>在 JS 中我们将非基本类型的类型统称为对象类型，这其中包括了对象、数组、函数、包装类、正则等等</p>\n<h4 id=\"Object-与-object-类型\"><a href=\"#Object-与-object-类型\" class=\"headerlink\" title=\"Object 与 object 类型\"></a>Object 与 object 类型</h4><p>为什么要区分大小写呢？这是因为我们将 Object 称为广义上的对象，它囊括了几乎所有的值，原始类型值、对象、数组、函数都是合法的<code>Object</code>类型，除了<code>undefined</code>和<code>null</code>不能转为对象</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">obj</span>: <span class=\"hljs-title class_\">Object</span>;<br><br>obj = <span class=\"hljs-literal\">true</span>;<br>obj = <span class=\"hljs-string\">&quot;hi&quot;</span>;<br>obj = <span class=\"hljs-number\">1</span>;<br>obj = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">123</span> &#125;;<br>obj = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];<br>obj = <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">a</span>: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> a + <span class=\"hljs-number\">1</span>;<br>obj = <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// 报错</span><br>obj = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// 报错</span><br></code></pre></td></tr></table></figure>\n\n<p>而小写的 object 就是我们狭义说的对象，即可以用字面量表示的对象，只包含对象、数组和函数，不包括原始类型的值。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">object</span> = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">123</span> &#125;;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">y</span>: <span class=\"hljs-built_in\">object</span> = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">z</span>: <span class=\"hljs-built_in\">object</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">n</span>: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> n + <span class=\"hljs-number\">1</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"包装类对象\"><a href=\"#包装类对象\" class=\"headerlink\" title=\"包装类对象\"></a>包装类对象</h4><p>由于包装对象的存在，导致每一个原始类型的值都有包装对象和字面量两种情况。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-string\">&quot;hello&quot;</span>; <span class=\"hljs-comment\">// 字面量</span><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>); <span class=\"hljs-comment\">// 包装类对象</span><br></code></pre></td></tr></table></figure>\n\n<p>为了进行区分，TS 对五种原始类型分别提供了大写和小写两种类型。</p>\n<ul>\n<li>Boolean 和 boolean</li>\n<li>String 和 string</li>\n<li>Number 和 number</li>\n<li>BigInt 和 bigint</li>\n<li>Symbol 和 symbol</li>\n</ul>\n<p>大写类型同时包含包装对象和字面量两种情况，小写类型只包含字面量，不包含包装对象。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">s1</span>: <span class=\"hljs-title class_\">String</span> = <span class=\"hljs-string\">&quot;hello&quot;</span>; <span class=\"hljs-comment\">// 正确</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">s2</span>: <span class=\"hljs-title class_\">String</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>); <span class=\"hljs-comment\">// 正确</span><br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">s3</span>: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&quot;hello&quot;</span>; <span class=\"hljs-comment\">// 正确</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">s4</span>: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>); <span class=\"hljs-comment\">// 报错</span><br></code></pre></td></tr></table></figure>\n\n<p>这里<code>String</code>类型可以赋值为字符串的字面量，也可以赋值为包装对象。但是，<code>string</code>类型只能赋值为字面量，赋值为包装对象就会报错。</p>\n<h3 id=\"值类型\"><a href=\"#值类型\" class=\"headerlink\" title=\"值类型\"></a>值类型</h3><p>TS 允许一个值成为一个类型</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">x</span>: <span class=\"hljs-string\">&quot;hello&quot;</span> = <span class=\"hljs-string\">&quot;hello&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>用<code>const</code>声明的变量，如果没有注明类型，则会把它推断为值类型</p>\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffd019c1c25744bea099dad24fedd652~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=286&h=88&s=5528&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n<p>而<code>let</code>则不会</p>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05d2a56546814fd2b3121395ad2ec747~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=234&h=94&s=4604&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n<p>这个原因显而易见，因为<code>const</code>声明的变量不可修改，即常量，但如果声明是对象的话，那就另外谈了，因为对象存的是地址，属性值可以改变，所以并不会推断为值类型。</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06c5d56dd8c845f78aeb2dd3fd8b8ea5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=373&h=191&s=9037&e=png&b=1e1e1e\" alt=\"image.png\" width=\"50%\" />\n\n<h3 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h3><p>联合类型指的是多个类型组成的一个新类型，使用符号<code>|</code>拼接。我们知道<code>|</code>是<code>或</code>的意思，所以<code>A|B</code>的意思是只要属于<code>A</code>或<code>B</code>其中一个就行了。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>;<br><br>x = <span class=\"hljs-number\">123</span>; <span class=\"hljs-comment\">// 正确</span><br>x = <span class=\"hljs-string\">&quot;abc&quot;</span>; <span class=\"hljs-comment\">// 正确</span><br></code></pre></td></tr></table></figure>\n\n<p>当联合类型与值类型结合，就可以表示一个变量可能有多个值。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;红&quot;</span> | <span class=\"hljs-string\">&quot;黄&quot;</span> | <span class=\"hljs-string\">&quot;绿&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"交叉类型\"><a href=\"#交叉类型\" class=\"headerlink\" title=\"交叉类型\"></a>交叉类型</h3><p>有<code>|</code>当然有<code>&amp;</code>，不出所料这个意思应该是<code>与</code>。<code>A&amp;B</code>表示，任何一个类型必须同时属于<code>A</code>和<code>B</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">z</span>: <span class=\"hljs-built_in\">number</span> &amp; <span class=\"hljs-built_in\">string</span>;<br></code></pre></td></tr></table></figure>\n\n<p>什么类型能兼具<code>number</code>和<code>string</code>？</p>\n<p>当然是不存在的，TS 新增了一个类型表示不存在的<code>never</code>，这里也可以用它来声明</p>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1df706673b3a4e2a928eb67083144c21~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=271&h=99&s=5356&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n<p>交叉类型的主要用途是表示对象的合成。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">person</span>: &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span> &#125; &amp; &#123; <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span> &#125;;<br><br>person = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;阳阳羊&quot;</span>,<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">21</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://typescript.p6p.net/typescript-tutorial/types.html\">阮一峰 TypeScript 教程</a></li>\n<li><a href=\"https://www.typescriptlang.org/\">TypeScript 官方文档</a></li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>以上是对 TS 类型的简单介绍，对于新同学来说应该很容易入手，后面我会继续更新进阶知识，关于 type、元祖、接口、泛型等等，我会持续更新。</p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ul>\n<li><a href=\"https://juejin.cn/post/7383643463532953619\">快速上手 TS（环境篇）- 掘金 (juejin.cn)</a></li>\n</ul>\n<p>上一篇中我介绍了 TS 从安装到运行的环境配置，希望能够对你带来帮助。今天我们来学习一下 TS 的一些基本知识，TS 知识可多了，一篇文章当然不能涵盖，所以我会写多篇文章进行介绍，希望我能坚持更新，更希望你能坚持看下去！</p>\n<h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>你在写 JS 的时候有没有想过这样一个问题：为什么 JS 不用写类型，不写类型带来的后果是什么？如果你尝试写过任意一门后端语言，你就会发现，每个类型都有自己声明的方式，而不是一味的 let、const，换句话说，弱类型会导致什么后果？</p>\n<p>JS 设计之初的目标是成为一种简单易用的脚本语言，能够让非专业程序员快速学习，因此，JS 遵循动态类型系统，如果代码出现错误，只能在运行时才能发现，而 TS 跟一些后端语言一样提供的静态类型检测，能够在编译时就发现错误，避免一些不必要的失误。</p>\n<h3 id=\"类型声明\"><a href=\"#类型声明\" class=\"headerlink\" title=\"类型声明\"></a>类型声明</h3><p>TS 允许我们在 JS 的基础上对变量进行声明</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">str</span>: <span class=\"hljs-built_in\">string</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这段代码中，TS 允许我们在声明的变量后面用<code>:</code>接类型，表示我们声明了一个什么类型的变量。</p>\n<p>如果你给变量赋的值不属于该类型，就会报错</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">str</span>: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-number\">123</span>; <span class=\"hljs-comment\">//报错</span><br></code></pre></td></tr></table></figure>\n\n<p>这里我们把数字<code>123</code>赋给一个声明为<code>string</code>的变量，就会报错。</p>\n<p>另外，如果变量在赋值之前被使用了，也会报错</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">str</span>: <span class=\"hljs-built_in\">string</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(str); <span class=\"hljs-comment\">//报错</span><br></code></pre></td></tr></table></figure>\n\n<p>如果在 JS 环境则不会报错，而是打印 <code>undefined</code></p>\n<h3 id=\"类型推断\"><a href=\"#类型推断\" class=\"headerlink\" title=\"类型推断\"></a>类型推断</h3><p>类型声明不是必须的，因为 TS 可以根据你的赋值推断出类型，这是 TS 比较厉害的一点</p>\n<p>如果你正常的像</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> num = <span class=\"hljs-number\">123</span>;<br></code></pre></td></tr></table></figure>\n\n<p>你把鼠标放到上面就能看到它被推断出的类型</p>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8916287c61914b15a727d482e6434583~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=259&h=96&s=4237&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n<p>另外，它还能推断出返回值的类型</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">fn</span> = (<span class=\"hljs-params\"><span class=\"hljs-attr\">str</span>: <span class=\"hljs-built_in\">string</span></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Number</span>(str);<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>我们只需要知道这里用 TS 声明了一个函数（关于函数具体如何声明后面会讲），接收一个 string 类型的参数 str，但是没有声明返回值的类型，TS 自己推断出来了</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e045d1f88e548c0885a85125fbd455f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=472&h=133&s=12681&e=png&b=1f1f1f\" alt=\"image.png\" width=\"50%\" />\n\n<p>这里可以看出，类型声明是可选的，你可以加，也可以不加，只是不能保证 TS 会正确推断出类型。</p>\n<h2 id=\"类型系统\"><a href=\"#类型系统\" class=\"headerlink\" title=\"类型系统\"></a>类型系统</h2><p>TS 继承了 JS 的类型，在这个基础上进行升级，形成了一套自己的类型系统</p>\n<h3 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a>基本类型</h3><p>我们知道 JS 有七大基本类型和对象类型，下面我会将每一个类型都拎出来讲</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">num</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">123</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">str</span>: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&quot;123&quot;</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">flag</span>: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">true</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">bigint</span>: <span class=\"hljs-built_in\">bigint</span> = <span class=\"hljs-number\">123n</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">symbol</span>: <span class=\"hljs-built_in\">symbol</span> = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&quot;123&quot;</span>);<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">un</span>: <span class=\"hljs-literal\">undefined</span> = <span class=\"hljs-literal\">undefined</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">nu</span>: <span class=\"hljs-literal\">null</span> = <span class=\"hljs-literal\">null</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"number-类型\"><a href=\"#number-类型\" class=\"headerlink\" title=\"number 类型\"></a>number 类型</h4><p>number 类型包含所有整数和浮点数</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">123</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">y</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">3.14</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">z</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">0xffff</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"string-类型\"><a href=\"#string-类型\" class=\"headerlink\" title=\"string 类型\"></a>string 类型</h4><p>普通字符串和模板字符串都属于 string 类型</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&quot;hello&quot;</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">y</span>: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;x&#125;</span> world`</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"boolean-类型\"><a href=\"#boolean-类型\" class=\"headerlink\" title=\"boolean 类型\"></a>boolean 类型</h4><p>boolean 类型只包含<code>true</code>和<code>false</code>，就没什么好说的了</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">true</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">y</span>: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">false</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"bigint-类型\"><a href=\"#bigint-类型\" class=\"headerlink\" title=\"bigint 类型\"></a>bigint 类型</h4><p>bigint 类型包含所有的大整数</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">bigint</span> = <span class=\"hljs-number\">123n</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">y</span>: <span class=\"hljs-built_in\">bigint</span> = <span class=\"hljs-number\">0xffffn</span>;<br></code></pre></td></tr></table></figure>\n\n<p>但是要注意的是 bigint 与 number 相互不兼容，意思是当给 bigint 类型赋值 number 时会报错，反过来也是。</p>\n<h4 id=\"symbol-类型\"><a href=\"#symbol-类型\" class=\"headerlink\" title=\"symbol 类型\"></a>symbol 类型</h4><p>symbol 类型包含所有的 Symbol 值，用的较少，咱们就一笔带过</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">symbol</span> = <span class=\"hljs-title class_\">Symbol</span>();<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"undefined-和-null-类型\"><a href=\"#undefined-和-null-类型\" class=\"headerlink\" title=\"undefined 和 null 类型\"></a>undefined 和 null 类型</h4><p>如果没有声明类型的变量，被赋值为<code>undefined</code>或<code>null</code>，默认情况下它们的类型会被推断为<code>any</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// any</span><br><span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// any</span><br><br><span class=\"hljs-keyword\">let</span> c = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// any</span><br><span class=\"hljs-keyword\">const</span> d = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// any</span><br></code></pre></td></tr></table></figure>\n\n<p>如果希望避免这种情况，则需要打开编译选项<code>strictNullChecks</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 打开编译设置 strictNullChecks</span><br><span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// undefined</span><br><span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// undefined</span><br><br><span class=\"hljs-keyword\">let</span> c = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// null</span><br><span class=\"hljs-keyword\">const</span> d = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// null</span><br></code></pre></td></tr></table></figure>\n\n<p>将所有类型都列出来大概就这么多，看起来好像跟 JS 没多大差别，就加了个类型声明罢了，真的是这样吗，咱们接着往下看</p>\n<h3 id=\"any、unknown、never-类型\"><a href=\"#any、unknown、never-类型\" class=\"headerlink\" title=\"any、unknown、never 类型\"></a>any、unknown、never 类型</h3><p>TS 新增了 any、unknown 和 never 三种类型，分别有着不同的应用场景</p>\n<h4 id=\"any-类型\"><a href=\"#any-类型\" class=\"headerlink\" title=\"any 类型\"></a>any 类型</h4><p>any 类型的变量可以被赋为任何值</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">any</span>;<br><br>x = <span class=\"hljs-number\">1</span>;<br>x = <span class=\"hljs-string\">&quot;阳阳羊&quot;</span>;<br>x = <span class=\"hljs-literal\">true</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这个类型一般不推荐使用，因为 TS 不会对 any 类型的变量进行类型检查，即使有明显的类型错误，只要句法正确，都不会报错。意思你声明的 string 类型变量甚至可以拿来当函数给调用掉，并且都不会报错。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">any</span> = <span class=\"hljs-string\">&quot;阳阳羊&quot;</span>;<br><span class=\"hljs-title function_\">x</span>(<span class=\"hljs-number\">1</span>);<br></code></pre></td></tr></table></figure>\n\n<p>如果每个变量类型都是 any，就失去了 TypeScript 的意义，直接写 JS 就好了 😂</p>\n<h4 id=\"unknown-类型\"><a href=\"#unknown-类型\" class=\"headerlink\" title=\"unknown 类型\"></a>unknown 类型</h4><p><code>unknown</code>类型的变量，不能直接赋值给其他类型的变量（除了<code>any</code>类型和<code>unknown</code>类型）</p>\n<p>避免了污染问题</p>\n<p>不能直接调用<code>unknown</code>类型变量的方法和属性</p>\n<p>可以赋值给任意其他类型</p>\n<h4 id=\"never-类型\"><a href=\"#never-类型\" class=\"headerlink\" title=\"never 类型\"></a>never 类型</h4><p>意为空类型，不可能有这样的值，不可能赋给它任何值，否则都会报错。后面会用交叉类型进行举例</p>\n<h3 id=\"对象类型\"><a href=\"#对象类型\" class=\"headerlink\" title=\"对象类型\"></a>对象类型</h3><p>在 JS 中我们将非基本类型的类型统称为对象类型，这其中包括了对象、数组、函数、包装类、正则等等</p>\n<h4 id=\"Object-与-object-类型\"><a href=\"#Object-与-object-类型\" class=\"headerlink\" title=\"Object 与 object 类型\"></a>Object 与 object 类型</h4><p>为什么要区分大小写呢？这是因为我们将 Object 称为广义上的对象，它囊括了几乎所有的值，原始类型值、对象、数组、函数都是合法的<code>Object</code>类型，除了<code>undefined</code>和<code>null</code>不能转为对象</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">obj</span>: <span class=\"hljs-title class_\">Object</span>;<br><br>obj = <span class=\"hljs-literal\">true</span>;<br>obj = <span class=\"hljs-string\">&quot;hi&quot;</span>;<br>obj = <span class=\"hljs-number\">1</span>;<br>obj = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">123</span> &#125;;<br>obj = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];<br>obj = <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">a</span>: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> a + <span class=\"hljs-number\">1</span>;<br>obj = <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// 报错</span><br>obj = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// 报错</span><br></code></pre></td></tr></table></figure>\n\n<p>而小写的 object 就是我们狭义说的对象，即可以用字面量表示的对象，只包含对象、数组和函数，不包括原始类型的值。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">object</span> = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">123</span> &#125;;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">y</span>: <span class=\"hljs-built_in\">object</span> = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">z</span>: <span class=\"hljs-built_in\">object</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">n</span>: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> n + <span class=\"hljs-number\">1</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"包装类对象\"><a href=\"#包装类对象\" class=\"headerlink\" title=\"包装类对象\"></a>包装类对象</h4><p>由于包装对象的存在，导致每一个原始类型的值都有包装对象和字面量两种情况。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-string\">&quot;hello&quot;</span>; <span class=\"hljs-comment\">// 字面量</span><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>); <span class=\"hljs-comment\">// 包装类对象</span><br></code></pre></td></tr></table></figure>\n\n<p>为了进行区分，TS 对五种原始类型分别提供了大写和小写两种类型。</p>\n<ul>\n<li>Boolean 和 boolean</li>\n<li>String 和 string</li>\n<li>Number 和 number</li>\n<li>BigInt 和 bigint</li>\n<li>Symbol 和 symbol</li>\n</ul>\n<p>大写类型同时包含包装对象和字面量两种情况，小写类型只包含字面量，不包含包装对象。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">s1</span>: <span class=\"hljs-title class_\">String</span> = <span class=\"hljs-string\">&quot;hello&quot;</span>; <span class=\"hljs-comment\">// 正确</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">s2</span>: <span class=\"hljs-title class_\">String</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>); <span class=\"hljs-comment\">// 正确</span><br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">s3</span>: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&quot;hello&quot;</span>; <span class=\"hljs-comment\">// 正确</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">s4</span>: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>); <span class=\"hljs-comment\">// 报错</span><br></code></pre></td></tr></table></figure>\n\n<p>这里<code>String</code>类型可以赋值为字符串的字面量，也可以赋值为包装对象。但是，<code>string</code>类型只能赋值为字面量，赋值为包装对象就会报错。</p>\n<h3 id=\"值类型\"><a href=\"#值类型\" class=\"headerlink\" title=\"值类型\"></a>值类型</h3><p>TS 允许一个值成为一个类型</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">x</span>: <span class=\"hljs-string\">&quot;hello&quot;</span> = <span class=\"hljs-string\">&quot;hello&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>用<code>const</code>声明的变量，如果没有注明类型，则会把它推断为值类型</p>\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffd019c1c25744bea099dad24fedd652~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=286&h=88&s=5528&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n<p>而<code>let</code>则不会</p>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05d2a56546814fd2b3121395ad2ec747~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=234&h=94&s=4604&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n<p>这个原因显而易见，因为<code>const</code>声明的变量不可修改，即常量，但如果声明是对象的话，那就另外谈了，因为对象存的是地址，属性值可以改变，所以并不会推断为值类型。</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06c5d56dd8c845f78aeb2dd3fd8b8ea5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=373&h=191&s=9037&e=png&b=1e1e1e\" alt=\"image.png\" width=\"50%\" />\n\n<h3 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h3><p>联合类型指的是多个类型组成的一个新类型，使用符号<code>|</code>拼接。我们知道<code>|</code>是<code>或</code>的意思，所以<code>A|B</code>的意思是只要属于<code>A</code>或<code>B</code>其中一个就行了。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>;<br><br>x = <span class=\"hljs-number\">123</span>; <span class=\"hljs-comment\">// 正确</span><br>x = <span class=\"hljs-string\">&quot;abc&quot;</span>; <span class=\"hljs-comment\">// 正确</span><br></code></pre></td></tr></table></figure>\n\n<p>当联合类型与值类型结合，就可以表示一个变量可能有多个值。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;红&quot;</span> | <span class=\"hljs-string\">&quot;黄&quot;</span> | <span class=\"hljs-string\">&quot;绿&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"交叉类型\"><a href=\"#交叉类型\" class=\"headerlink\" title=\"交叉类型\"></a>交叉类型</h3><p>有<code>|</code>当然有<code>&amp;</code>，不出所料这个意思应该是<code>与</code>。<code>A&amp;B</code>表示，任何一个类型必须同时属于<code>A</code>和<code>B</code>。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">z</span>: <span class=\"hljs-built_in\">number</span> &amp; <span class=\"hljs-built_in\">string</span>;<br></code></pre></td></tr></table></figure>\n\n<p>什么类型能兼具<code>number</code>和<code>string</code>？</p>\n<p>当然是不存在的，TS 新增了一个类型表示不存在的<code>never</code>，这里也可以用它来声明</p>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1df706673b3a4e2a928eb67083144c21~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=271&h=99&s=5356&e=png&b=1f1f1f\" alt=\"image.png\" width=\"30%\" />\n\n<p>交叉类型的主要用途是表示对象的合成。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">person</span>: &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span> &#125; &amp; &#123; <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span> &#125;;<br><br>person = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;阳阳羊&quot;</span>,<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">21</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://typescript.p6p.net/typescript-tutorial/types.html\">阮一峰 TypeScript 教程</a></li>\n<li><a href=\"https://www.typescriptlang.org/\">TypeScript 官方文档</a></li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>以上是对 TS 类型的简单介绍，对于新同学来说应该很容易入手，后面我会继续更新进阶知识，关于 type、元祖、接口、泛型等等，我会持续更新。</p>\n"},{"title":"如何将提交说明（commit message）导出到指定文件？","date":"2024-06-26T08:00:00.000Z","index_img":"/img/git.png","banner_img":"/img/default.png","_content":"\n## 前言\n\n公司里总会有一些有趣的需求，这不，mentor：“你去调研一下，看怎么把 commit 提交说明导出到一个 txt 文件里，条目的话最好可以指定，后续我们……”。刚开始接到这个任务还是挺忙蒙的，网上应该有这个功能的第三方包吧？但是在我查询多方资料，发现 Git 真 🐂，哪需要什么第三方包！\n\n我在一个 git 学习的网站看到这句话真绷不住，赶紧跟大家分享一下\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/841eec7d5078487ebc2f15ba3a5a8756~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=842&h=130&s=15474&e=png&b=fefefe\" alt=\"image.png\" width=\"70%\" />\n\n假如我真的学完了 16 章的内容，然后你跟我说还没入门？这我学集贸啊 😂。\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9d7c8aae7eb4f68b6268f1ec3c72adf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=321&h=737&s=36251&e=png&b=fefefe\" alt=\"image.png\" width=\"30%\" />\n\n行了，闲话少说，我们步入正题，开始今天的分享。\n\n## 拿到提交说明\n\n我们如果想查看`commit`的内容，可以`git show`查看详细信息，它可以显示最新提交的详细信息，包括作者、日期、提交说明和每个文件的变更内容。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08cabde444e440018e9a95c357768b6d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=665&h=294&s=21106&e=png&b=1e1e1e)\n\n但是这里只能展示最新提交，而我们的需求是可以指定条目的 commit 提交说明，而这里只显示一条，显然不满足需求。\n\n然后又找到`git log`，允许我们查看 git 仓库的提交历史，它会按照时间顺序列出提交记录，并可以显示提交的哈希值、作者、日期、提交信息等信息。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a5de345be0e492b8e76588ff5ac604e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=693&h=376&s=27111&e=png&b=1e1e1e)\n\n这不正是我们想要的吗，看看怎么单独拿到提交说明。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b4a6454cd0d4d609d35f1b35ece3f57~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=674&h=200&s=29029&e=png&b=fbfbf8)\n\n[git 文档](https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History)中提到了`--pretty`这个选项，它允许日志输出默认格式以外的格式！如果我可以将输出只显示提交说明那不是美哉，于是我继续看文档。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1719fc5f89d4d4fa885d63a6f3e7628~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=671&h=230&s=24282&e=png&b=f7f6f5)\n\n然后选项值为`format`时，我们就可以指定输出格式，它提供一些占位符允许我们自定义输出，文档中也对每个占位进行列举。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1064fd81ccbc41e6bfb34f69fff7a85f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=440&h=773&s=30905&e=png&b=fcfcfa)\n\n其中`%s`就是我们需要的提交说明，试试看！\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fd5492cbdcd4ab485408e2778e7ad4e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=387&h=139&s=6332&e=png&b=1e1e1e)\n\n果然成功拿到！成就感爆棚了。\n\n## 导出到指定文件\n\n我们离成功只差一步，现在我们只是在终端看到结果，怎么将终端的数据导到本地文件呢？\n\ngit 有一个打包文件的方法`git archive`，这个命令本身并不支持包含提交说明字段的功能。它主要用于将指定的提交、分支或标签的代码打包成归档文件，主要关注代码本身而非提交历史，而不包含 Git 仓库的元数据（如提交历史、提交说明等），所以行不通。\n\n查了一些资料，发现已经用不着 Git 了，既然是在控制台显示，那我就用控制台的方法呗。\n\n### 重定向操作符`>`，`>>`\n\n在大多数命令行环境中，可以使用`>`将控制台输出保存到文件中\n\n```bash\ngit log > log.txt\n```\n\n这行命令将会把我们的日志保存到当前目录下的`log.txt`文件中，如果已经存在`log.txt`文件则会进行覆盖操作。\n\n而`>>`则会将输出追加到文件末尾，而不覆盖原有内容。\n\n### PowerShell 脚本\n\n如果你使用 PowerShell，也可以通过脚本来执行 Git 命令并将输出进行保存\n\n```powershell\ngit log | Out-File -FilePath log.txt\n```\n\n---\n\n因为我是用 VScode，它自带的就是 PowerShell，所以就用 PowerShell 脚本给大家进行展示\n\n```bash\ngit log --pretty=format:\"%s\" | Out-File -FilePath commit_messages.txt\n```\n\n执行完命令，我们可以在当前目录下看到新生成的`commit_messages.txt`文件。\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04482d43ef534b0893bb07858a5d6e02~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=391&h=411&s=39493&e=png&b=1e1e1e\" alt=\"image.png\" width=\"50%\" />\n\n当当，成功导入 txt 文件，但是我们发现文件里的中文全是乱码，为什么会这样？\n\n## 解决中文乱码\n\n**1. 在导出的时候明确编码**\n\n```bash\ngit log --pretty=format:\"%s\" | Out-File -FilePath commit_messages.txt -Encoding utf8\n```\n\n但是发现并不奏效\n\n**2. 设置 Git 输出编码**\n\n```bash\ngit config --global i18n.logOutputEncoding gb2312\n```\n\n这里我将 git 输出的编码格式改为 gb2312，再次执行导出操作，发现乱码消失。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0b2830415434d2788d899f0ad0cf3ea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=324&h=355&s=27528&e=png&b=1e1e1e)\n\n## 指定输出条目和格式\n\n现在我们想实现输出最新的 20 条数据，并且标上序号（如`1.`）\n\n想要指定条目，我们只需加上`-n + 数字`\n\n```bash\ngit log -n 20\n```\n\n这里表示指定输出最新的 20 条日志信息\n\n加上序号的话，我们可以创建一个计数器，然后对每行内容进行拼接\n\n```bash\n$counter = 1\ngit log -n 20 --pretty=format:\"%s\" | ForEach-Object {\n    \"$counter. $_\" | Out-File -FilePath commit_messages.txt -Append\n    $counter++\n}\n```\n\n`$counter = 1`初始化一个计数器，初始值为 1\n\n`ForEach-Object{}`是对输出的每一条进行单独的操作，这里进行拼接操作\n\n`-Append`将内容追加到文末，而不是覆盖\n\n**最终效果**\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4e44519d6f84090991db1aa63ffc250~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=671&h=605&s=65520&e=png&b=1e1e1e)\n\n---\n\n调研完，不出意外的就要出意外了……\n\nmentor：你现在再调研一下然后实现两种方式：\n\n可以指定到具体更新了多少内容，比如说可能有两种情况：用 tag 进行区分，上次的 tag 到本次 tag 之间的 commit messages，对这个区间进行导出；另一种情况就是，拉一个新分支进行开发，新分支的最后一次提交到主分主的最后一次提交，这个区间进行导出。\n\n这些我们后期会针对不同的场景进行实施……\n\n## 一些前驱知识\n\n### 区间符..\n\n`..`允许我们指定输出的区间\n\n```bash\ngit log master..HEAD\n```\n\n输出从 master 的最新提交到当前项目的 HEAD\n\n### ^操作符\n\n`^` 操作符用于指定父提交\n\n父提交指一个提交的上一个提交。每个提交都有一个或多个父提交，具体取决于它是普通提交还是合并提交。\n\n#### 普通提交\n\n对于普通提交，每个提交只有一个父提交。\n\n```css\nA---B---C---D\n```\n\n- 提交 `D` 的父提交是 `C`。\n- 提交 `C` 的父提交是 `B`。\n- 提交 `B` 的父提交是 `A`。\n\n在这种情况下：\n\n- `D^` 或 `D^1` 表示提交 `D` 的父提交 `C`。\n\n#### 合并提交\n\n合并提交是指将两个或多个分支合并在一起时产生的提交。合并提交有两个或更多的父提交。\n\n```css\nA---B---C---E  (main)\n     \\     /\n      D---F   (feat-test)\n```\n\n- 提交 `E` 是一个合并提交，合并了 `feat-test` 到 `main`。\n\n- 提交 `E` 有两个父提交：\n\n  - 第一个父提交 `C`，表示 `main` 分支在合并前的最后一个提交。\n  - 第二个父提交 `F`，表示 `feat-test` 的最后一个提交。\n\n在这种情况下：\n\n- `E^1` 表示提交 `E` 的第一个父提交 `C`。\n- `E^2` 表示提交 `E` 的第二个父提交 `F`。\n\n搞清楚这些，那我们的工作就好开展了\n\n## 使用 Tag 进行区间导出\n\n假设你有两个 tag，分别为 `v1.0` 和 `v2.0`，你想导出这两个 tag 之间的 commit messages\n\n```bash\n$counter = 1\ngit log v1.0..v2.0 --pretty=format:\"%s\" | ForEach-Object {\n    \"$counter. $_\" | Out-File -FilePath commit_messages.txt -Append\n    $counter++\n}\n```\n\n`v1.0..v2.0`就可以指定两个 tag 之间\n\n## 从新分支的最后一次提交到主分支的最后一次提交\n\n假设你有一个新分支 `feat-test` 和主分支 `main`，这种就要分情况了，可能是合并前也可能是合并后\n\n### 合并前\n\n```bash\n#合并前\n$counter = 1\ngit log main..feat-test --pretty=format:\"%s\" | ForEach-Object {\n    \"$counter. $_\" | Out-File -FilePath commit_messages.txt -Append\n    $counter++\n}\n```\n\n### 合并后\n\n合并后的话只需要将开始指向合并前的最后一次提交，不就是 main 的第一个父提交吗\n\n```bash\ngit log main^..HEAD\n```\n\nover\n\n## 参考\n\n- [How do I export a Git log to a text file?](https://stackoverflow.com/questions/10330425/how-do-i-export-a-git-log-to-a-text-file)\n- [Git 官方文档](https://git-scm.com/docs)\n- [learn-git-the-super-hard-way](https://b1f6c1c4.gitbook.io/learn-git-the-super-hard-way)\n\n## 最后\n\n已将学习代码上传至 [github](https://github.com/YangyangU/CodeSpace)，欢迎大家学习指正！\n","source":"_posts/如何将提交说明（commit message）导出到指定文件.md","raw":"---\ntitle: 如何将提交说明（commit message）导出到指定文件？\ndate: 2024-06-26 16:00:00\ntags: [Git]\ncategories: Git\nindex_img: /img/git.png\nbanner_img: /img/default.png\n---\n\n## 前言\n\n公司里总会有一些有趣的需求，这不，mentor：“你去调研一下，看怎么把 commit 提交说明导出到一个 txt 文件里，条目的话最好可以指定，后续我们……”。刚开始接到这个任务还是挺忙蒙的，网上应该有这个功能的第三方包吧？但是在我查询多方资料，发现 Git 真 🐂，哪需要什么第三方包！\n\n我在一个 git 学习的网站看到这句话真绷不住，赶紧跟大家分享一下\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/841eec7d5078487ebc2f15ba3a5a8756~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=842&h=130&s=15474&e=png&b=fefefe\" alt=\"image.png\" width=\"70%\" />\n\n假如我真的学完了 16 章的内容，然后你跟我说还没入门？这我学集贸啊 😂。\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9d7c8aae7eb4f68b6268f1ec3c72adf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=321&h=737&s=36251&e=png&b=fefefe\" alt=\"image.png\" width=\"30%\" />\n\n行了，闲话少说，我们步入正题，开始今天的分享。\n\n## 拿到提交说明\n\n我们如果想查看`commit`的内容，可以`git show`查看详细信息，它可以显示最新提交的详细信息，包括作者、日期、提交说明和每个文件的变更内容。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08cabde444e440018e9a95c357768b6d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=665&h=294&s=21106&e=png&b=1e1e1e)\n\n但是这里只能展示最新提交，而我们的需求是可以指定条目的 commit 提交说明，而这里只显示一条，显然不满足需求。\n\n然后又找到`git log`，允许我们查看 git 仓库的提交历史，它会按照时间顺序列出提交记录，并可以显示提交的哈希值、作者、日期、提交信息等信息。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a5de345be0e492b8e76588ff5ac604e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=693&h=376&s=27111&e=png&b=1e1e1e)\n\n这不正是我们想要的吗，看看怎么单独拿到提交说明。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b4a6454cd0d4d609d35f1b35ece3f57~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=674&h=200&s=29029&e=png&b=fbfbf8)\n\n[git 文档](https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History)中提到了`--pretty`这个选项，它允许日志输出默认格式以外的格式！如果我可以将输出只显示提交说明那不是美哉，于是我继续看文档。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1719fc5f89d4d4fa885d63a6f3e7628~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=671&h=230&s=24282&e=png&b=f7f6f5)\n\n然后选项值为`format`时，我们就可以指定输出格式，它提供一些占位符允许我们自定义输出，文档中也对每个占位进行列举。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1064fd81ccbc41e6bfb34f69fff7a85f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=440&h=773&s=30905&e=png&b=fcfcfa)\n\n其中`%s`就是我们需要的提交说明，试试看！\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fd5492cbdcd4ab485408e2778e7ad4e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=387&h=139&s=6332&e=png&b=1e1e1e)\n\n果然成功拿到！成就感爆棚了。\n\n## 导出到指定文件\n\n我们离成功只差一步，现在我们只是在终端看到结果，怎么将终端的数据导到本地文件呢？\n\ngit 有一个打包文件的方法`git archive`，这个命令本身并不支持包含提交说明字段的功能。它主要用于将指定的提交、分支或标签的代码打包成归档文件，主要关注代码本身而非提交历史，而不包含 Git 仓库的元数据（如提交历史、提交说明等），所以行不通。\n\n查了一些资料，发现已经用不着 Git 了，既然是在控制台显示，那我就用控制台的方法呗。\n\n### 重定向操作符`>`，`>>`\n\n在大多数命令行环境中，可以使用`>`将控制台输出保存到文件中\n\n```bash\ngit log > log.txt\n```\n\n这行命令将会把我们的日志保存到当前目录下的`log.txt`文件中，如果已经存在`log.txt`文件则会进行覆盖操作。\n\n而`>>`则会将输出追加到文件末尾，而不覆盖原有内容。\n\n### PowerShell 脚本\n\n如果你使用 PowerShell，也可以通过脚本来执行 Git 命令并将输出进行保存\n\n```powershell\ngit log | Out-File -FilePath log.txt\n```\n\n---\n\n因为我是用 VScode，它自带的就是 PowerShell，所以就用 PowerShell 脚本给大家进行展示\n\n```bash\ngit log --pretty=format:\"%s\" | Out-File -FilePath commit_messages.txt\n```\n\n执行完命令，我们可以在当前目录下看到新生成的`commit_messages.txt`文件。\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04482d43ef534b0893bb07858a5d6e02~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=391&h=411&s=39493&e=png&b=1e1e1e\" alt=\"image.png\" width=\"50%\" />\n\n当当，成功导入 txt 文件，但是我们发现文件里的中文全是乱码，为什么会这样？\n\n## 解决中文乱码\n\n**1. 在导出的时候明确编码**\n\n```bash\ngit log --pretty=format:\"%s\" | Out-File -FilePath commit_messages.txt -Encoding utf8\n```\n\n但是发现并不奏效\n\n**2. 设置 Git 输出编码**\n\n```bash\ngit config --global i18n.logOutputEncoding gb2312\n```\n\n这里我将 git 输出的编码格式改为 gb2312，再次执行导出操作，发现乱码消失。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0b2830415434d2788d899f0ad0cf3ea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=324&h=355&s=27528&e=png&b=1e1e1e)\n\n## 指定输出条目和格式\n\n现在我们想实现输出最新的 20 条数据，并且标上序号（如`1.`）\n\n想要指定条目，我们只需加上`-n + 数字`\n\n```bash\ngit log -n 20\n```\n\n这里表示指定输出最新的 20 条日志信息\n\n加上序号的话，我们可以创建一个计数器，然后对每行内容进行拼接\n\n```bash\n$counter = 1\ngit log -n 20 --pretty=format:\"%s\" | ForEach-Object {\n    \"$counter. $_\" | Out-File -FilePath commit_messages.txt -Append\n    $counter++\n}\n```\n\n`$counter = 1`初始化一个计数器，初始值为 1\n\n`ForEach-Object{}`是对输出的每一条进行单独的操作，这里进行拼接操作\n\n`-Append`将内容追加到文末，而不是覆盖\n\n**最终效果**\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4e44519d6f84090991db1aa63ffc250~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=671&h=605&s=65520&e=png&b=1e1e1e)\n\n---\n\n调研完，不出意外的就要出意外了……\n\nmentor：你现在再调研一下然后实现两种方式：\n\n可以指定到具体更新了多少内容，比如说可能有两种情况：用 tag 进行区分，上次的 tag 到本次 tag 之间的 commit messages，对这个区间进行导出；另一种情况就是，拉一个新分支进行开发，新分支的最后一次提交到主分主的最后一次提交，这个区间进行导出。\n\n这些我们后期会针对不同的场景进行实施……\n\n## 一些前驱知识\n\n### 区间符..\n\n`..`允许我们指定输出的区间\n\n```bash\ngit log master..HEAD\n```\n\n输出从 master 的最新提交到当前项目的 HEAD\n\n### ^操作符\n\n`^` 操作符用于指定父提交\n\n父提交指一个提交的上一个提交。每个提交都有一个或多个父提交，具体取决于它是普通提交还是合并提交。\n\n#### 普通提交\n\n对于普通提交，每个提交只有一个父提交。\n\n```css\nA---B---C---D\n```\n\n- 提交 `D` 的父提交是 `C`。\n- 提交 `C` 的父提交是 `B`。\n- 提交 `B` 的父提交是 `A`。\n\n在这种情况下：\n\n- `D^` 或 `D^1` 表示提交 `D` 的父提交 `C`。\n\n#### 合并提交\n\n合并提交是指将两个或多个分支合并在一起时产生的提交。合并提交有两个或更多的父提交。\n\n```css\nA---B---C---E  (main)\n     \\     /\n      D---F   (feat-test)\n```\n\n- 提交 `E` 是一个合并提交，合并了 `feat-test` 到 `main`。\n\n- 提交 `E` 有两个父提交：\n\n  - 第一个父提交 `C`，表示 `main` 分支在合并前的最后一个提交。\n  - 第二个父提交 `F`，表示 `feat-test` 的最后一个提交。\n\n在这种情况下：\n\n- `E^1` 表示提交 `E` 的第一个父提交 `C`。\n- `E^2` 表示提交 `E` 的第二个父提交 `F`。\n\n搞清楚这些，那我们的工作就好开展了\n\n## 使用 Tag 进行区间导出\n\n假设你有两个 tag，分别为 `v1.0` 和 `v2.0`，你想导出这两个 tag 之间的 commit messages\n\n```bash\n$counter = 1\ngit log v1.0..v2.0 --pretty=format:\"%s\" | ForEach-Object {\n    \"$counter. $_\" | Out-File -FilePath commit_messages.txt -Append\n    $counter++\n}\n```\n\n`v1.0..v2.0`就可以指定两个 tag 之间\n\n## 从新分支的最后一次提交到主分支的最后一次提交\n\n假设你有一个新分支 `feat-test` 和主分支 `main`，这种就要分情况了，可能是合并前也可能是合并后\n\n### 合并前\n\n```bash\n#合并前\n$counter = 1\ngit log main..feat-test --pretty=format:\"%s\" | ForEach-Object {\n    \"$counter. $_\" | Out-File -FilePath commit_messages.txt -Append\n    $counter++\n}\n```\n\n### 合并后\n\n合并后的话只需要将开始指向合并前的最后一次提交，不就是 main 的第一个父提交吗\n\n```bash\ngit log main^..HEAD\n```\n\nover\n\n## 参考\n\n- [How do I export a Git log to a text file?](https://stackoverflow.com/questions/10330425/how-do-i-export-a-git-log-to-a-text-file)\n- [Git 官方文档](https://git-scm.com/docs)\n- [learn-git-the-super-hard-way](https://b1f6c1c4.gitbook.io/learn-git-the-super-hard-way)\n\n## 最后\n\n已将学习代码上传至 [github](https://github.com/YangyangU/CodeSpace)，欢迎大家学习指正！\n","slug":"如何将提交说明（commit message）导出到指定文件","published":1,"updated":"2024-09-09T15:30:53.197Z","_id":"clywvs6t2000i18v689c949f9","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>公司里总会有一些有趣的需求，这不，mentor：“你去调研一下，看怎么把 commit 提交说明导出到一个 txt 文件里，条目的话最好可以指定，后续我们……”。刚开始接到这个任务还是挺忙蒙的，网上应该有这个功能的第三方包吧？但是在我查询多方资料，发现 Git 真 🐂，哪需要什么第三方包！</p>\n<p>我在一个 git 学习的网站看到这句话真绷不住，赶紧跟大家分享一下</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/841eec7d5078487ebc2f15ba3a5a8756~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=842&h=130&s=15474&e=png&b=fefefe\" alt=\"image.png\" width=\"70%\" />\n\n<p>假如我真的学完了 16 章的内容，然后你跟我说还没入门？这我学集贸啊 😂。</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9d7c8aae7eb4f68b6268f1ec3c72adf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=321&h=737&s=36251&e=png&b=fefefe\" alt=\"image.png\" width=\"30%\" />\n\n<p>行了，闲话少说，我们步入正题，开始今天的分享。</p>\n<h2 id=\"拿到提交说明\"><a href=\"#拿到提交说明\" class=\"headerlink\" title=\"拿到提交说明\"></a>拿到提交说明</h2><p>我们如果想查看<code>commit</code>的内容，可以<code>git show</code>查看详细信息，它可以显示最新提交的详细信息，包括作者、日期、提交说明和每个文件的变更内容。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08cabde444e440018e9a95c357768b6d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=665&h=294&s=21106&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>但是这里只能展示最新提交，而我们的需求是可以指定条目的 commit 提交说明，而这里只显示一条，显然不满足需求。</p>\n<p>然后又找到<code>git log</code>，允许我们查看 git 仓库的提交历史，它会按照时间顺序列出提交记录，并可以显示提交的哈希值、作者、日期、提交信息等信息。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a5de345be0e492b8e76588ff5ac604e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=693&h=376&s=27111&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>这不正是我们想要的吗，看看怎么单独拿到提交说明。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b4a6454cd0d4d609d35f1b35ece3f57~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=674&h=200&s=29029&e=png&b=fbfbf8\" alt=\"image.png\"></p>\n<p><a href=\"https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History\">git 文档</a>中提到了<code>--pretty</code>这个选项，它允许日志输出默认格式以外的格式！如果我可以将输出只显示提交说明那不是美哉，于是我继续看文档。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1719fc5f89d4d4fa885d63a6f3e7628~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=671&h=230&s=24282&e=png&b=f7f6f5\" alt=\"image.png\"></p>\n<p>然后选项值为<code>format</code>时，我们就可以指定输出格式，它提供一些占位符允许我们自定义输出，文档中也对每个占位进行列举。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1064fd81ccbc41e6bfb34f69fff7a85f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=440&h=773&s=30905&e=png&b=fcfcfa\" alt=\"image.png\"></p>\n<p>其中<code>%s</code>就是我们需要的提交说明，试试看！</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fd5492cbdcd4ab485408e2778e7ad4e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=387&h=139&s=6332&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>果然成功拿到！成就感爆棚了。</p>\n<h2 id=\"导出到指定文件\"><a href=\"#导出到指定文件\" class=\"headerlink\" title=\"导出到指定文件\"></a>导出到指定文件</h2><p>我们离成功只差一步，现在我们只是在终端看到结果，怎么将终端的数据导到本地文件呢？</p>\n<p>git 有一个打包文件的方法<code>git archive</code>，这个命令本身并不支持包含提交说明字段的功能。它主要用于将指定的提交、分支或标签的代码打包成归档文件，主要关注代码本身而非提交历史，而不包含 Git 仓库的元数据（如提交历史、提交说明等），所以行不通。</p>\n<p>查了一些资料，发现已经用不着 Git 了，既然是在控制台显示，那我就用控制台的方法呗。</p>\n<h3 id=\"重定向操作符-，\"><a href=\"#重定向操作符-，\" class=\"headerlink\" title=\"重定向操作符&gt;，&gt;&gt;\"></a>重定向操作符<code>&gt;</code>，<code>&gt;&gt;</code></h3><p>在大多数命令行环境中，可以使用<code>&gt;</code>将控制台输出保存到文件中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">log</span> &gt; log.txt<br></code></pre></td></tr></table></figure>\n\n<p>这行命令将会把我们的日志保存到当前目录下的<code>log.txt</code>文件中，如果已经存在<code>log.txt</code>文件则会进行覆盖操作。</p>\n<p>而<code>&gt;&gt;</code>则会将输出追加到文件末尾，而不覆盖原有内容。</p>\n<h3 id=\"PowerShell-脚本\"><a href=\"#PowerShell-脚本\" class=\"headerlink\" title=\"PowerShell 脚本\"></a>PowerShell 脚本</h3><p>如果你使用 PowerShell，也可以通过脚本来执行 Git 命令并将输出进行保存</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">git log | <span class=\"hljs-built_in\">Out-File</span> <span class=\"hljs-literal\">-FilePath</span> log.txt<br></code></pre></td></tr></table></figure>\n\n<hr>\n<p>因为我是用 VScode，它自带的就是 PowerShell，所以就用 PowerShell 脚本给大家进行展示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">log</span> --pretty=format:<span class=\"hljs-string\">&quot;%s&quot;</span> | Out-File -FilePath commit_messages.txt<br></code></pre></td></tr></table></figure>\n\n<p>执行完命令，我们可以在当前目录下看到新生成的<code>commit_messages.txt</code>文件。</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04482d43ef534b0893bb07858a5d6e02~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=391&h=411&s=39493&e=png&b=1e1e1e\" alt=\"image.png\" width=\"50%\" />\n\n<p>当当，成功导入 txt 文件，但是我们发现文件里的中文全是乱码，为什么会这样？</p>\n<h2 id=\"解决中文乱码\"><a href=\"#解决中文乱码\" class=\"headerlink\" title=\"解决中文乱码\"></a>解决中文乱码</h2><p><strong>1. 在导出的时候明确编码</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">log</span> --pretty=format:<span class=\"hljs-string\">&quot;%s&quot;</span> | Out-File -FilePath commit_messages.txt -Encoding utf8<br></code></pre></td></tr></table></figure>\n\n<p>但是发现并不奏效</p>\n<p><strong>2. 设置 Git 输出编码</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git config --global i18n.logOutputEncoding gb2312<br></code></pre></td></tr></table></figure>\n\n<p>这里我将 git 输出的编码格式改为 gb2312，再次执行导出操作，发现乱码消失。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0b2830415434d2788d899f0ad0cf3ea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=324&h=355&s=27528&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<h2 id=\"指定输出条目和格式\"><a href=\"#指定输出条目和格式\" class=\"headerlink\" title=\"指定输出条目和格式\"></a>指定输出条目和格式</h2><p>现在我们想实现输出最新的 20 条数据，并且标上序号（如<code>1.</code>）</p>\n<p>想要指定条目，我们只需加上<code>-n + 数字</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">log</span> -n 20<br></code></pre></td></tr></table></figure>\n\n<p>这里表示指定输出最新的 20 条日志信息</p>\n<p>加上序号的话，我们可以创建一个计数器，然后对每行内容进行拼接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-variable\">$counter</span> = 1<br>git <span class=\"hljs-built_in\">log</span> -n 20 --pretty=format:<span class=\"hljs-string\">&quot;%s&quot;</span> | ForEach-Object &#123;<br>    <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$counter</span>. <span class=\"hljs-variable\">$_</span>&quot;</span> | Out-File -FilePath commit_messages.txt -Append<br>    <span class=\"hljs-variable\">$counter</span>++<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>$counter = 1</code>初始化一个计数器，初始值为 1</p>\n<p><code>ForEach-Object&#123;&#125;</code>是对输出的每一条进行单独的操作，这里进行拼接操作</p>\n<p><code>-Append</code>将内容追加到文末，而不是覆盖</p>\n<p><strong>最终效果</strong></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4e44519d6f84090991db1aa63ffc250~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=671&h=605&s=65520&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<hr>\n<p>调研完，不出意外的就要出意外了……</p>\n<p>mentor：你现在再调研一下然后实现两种方式：</p>\n<p>可以指定到具体更新了多少内容，比如说可能有两种情况：用 tag 进行区分，上次的 tag 到本次 tag 之间的 commit messages，对这个区间进行导出；另一种情况就是，拉一个新分支进行开发，新分支的最后一次提交到主分主的最后一次提交，这个区间进行导出。</p>\n<p>这些我们后期会针对不同的场景进行实施……</p>\n<h2 id=\"一些前驱知识\"><a href=\"#一些前驱知识\" class=\"headerlink\" title=\"一些前驱知识\"></a>一些前驱知识</h2><h3 id=\"区间符\"><a href=\"#区间符\" class=\"headerlink\" title=\"区间符..\"></a>区间符..</h3><p><code>..</code>允许我们指定输出的区间</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">log</span> master..HEAD<br></code></pre></td></tr></table></figure>\n\n<p>输出从 master 的最新提交到当前项目的 HEAD</p>\n<h3 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"^操作符\"></a>^操作符</h3><p><code>^</code> 操作符用于指定父提交</p>\n<p>父提交指一个提交的上一个提交。每个提交都有一个或多个父提交，具体取决于它是普通提交还是合并提交。</p>\n<h4 id=\"普通提交\"><a href=\"#普通提交\" class=\"headerlink\" title=\"普通提交\"></a>普通提交</h4><p>对于普通提交，每个提交只有一个父提交。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">A</span>-<span class=\"hljs-attr\">--B---C---D</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>提交 <code>D</code> 的父提交是 <code>C</code>。</li>\n<li>提交 <code>C</code> 的父提交是 <code>B</code>。</li>\n<li>提交 <code>B</code> 的父提交是 <code>A</code>。</li>\n</ul>\n<p>在这种情况下：</p>\n<ul>\n<li><code>D^</code> 或 <code>D^1</code> 表示提交 <code>D</code> 的父提交 <code>C</code>。</li>\n</ul>\n<h4 id=\"合并提交\"><a href=\"#合并提交\" class=\"headerlink\" title=\"合并提交\"></a>合并提交</h4><p>合并提交是指将两个或多个分支合并在一起时产生的提交。合并提交有两个或更多的父提交。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">A</span>-<span class=\"hljs-attr\">--B---C---E</span>  (<span class=\"hljs-selector-tag\">main</span>)<br>     \\     /<br>      D-<span class=\"hljs-attr\">--F</span>   (feat-test)<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>提交 <code>E</code> 是一个合并提交，合并了 <code>feat-test</code> 到 <code>main</code>。</p>\n</li>\n<li><p>提交 <code>E</code> 有两个父提交：</p>\n<ul>\n<li>第一个父提交 <code>C</code>，表示 <code>main</code> 分支在合并前的最后一个提交。</li>\n<li>第二个父提交 <code>F</code>，表示 <code>feat-test</code> 的最后一个提交。</li>\n</ul>\n</li>\n</ul>\n<p>在这种情况下：</p>\n<ul>\n<li><code>E^1</code> 表示提交 <code>E</code> 的第一个父提交 <code>C</code>。</li>\n<li><code>E^2</code> 表示提交 <code>E</code> 的第二个父提交 <code>F</code>。</li>\n</ul>\n<p>搞清楚这些，那我们的工作就好开展了</p>\n<h2 id=\"使用-Tag-进行区间导出\"><a href=\"#使用-Tag-进行区间导出\" class=\"headerlink\" title=\"使用 Tag 进行区间导出\"></a>使用 Tag 进行区间导出</h2><p>假设你有两个 tag，分别为 <code>v1.0</code> 和 <code>v2.0</code>，你想导出这两个 tag 之间的 commit messages</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-variable\">$counter</span> = 1<br>git <span class=\"hljs-built_in\">log</span> v1.0..v2.0 --pretty=format:<span class=\"hljs-string\">&quot;%s&quot;</span> | ForEach-Object &#123;<br>    <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$counter</span>. <span class=\"hljs-variable\">$_</span>&quot;</span> | Out-File -FilePath commit_messages.txt -Append<br>    <span class=\"hljs-variable\">$counter</span>++<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>v1.0..v2.0</code>就可以指定两个 tag 之间</p>\n<h2 id=\"从新分支的最后一次提交到主分支的最后一次提交\"><a href=\"#从新分支的最后一次提交到主分支的最后一次提交\" class=\"headerlink\" title=\"从新分支的最后一次提交到主分支的最后一次提交\"></a>从新分支的最后一次提交到主分支的最后一次提交</h2><p>假设你有一个新分支 <code>feat-test</code> 和主分支 <code>main</code>，这种就要分情况了，可能是合并前也可能是合并后</p>\n<h3 id=\"合并前\"><a href=\"#合并前\" class=\"headerlink\" title=\"合并前\"></a>合并前</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#合并前</span><br><span class=\"hljs-variable\">$counter</span> = 1<br>git <span class=\"hljs-built_in\">log</span> main..feat-test --pretty=format:<span class=\"hljs-string\">&quot;%s&quot;</span> | ForEach-Object &#123;<br>    <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$counter</span>. <span class=\"hljs-variable\">$_</span>&quot;</span> | Out-File -FilePath commit_messages.txt -Append<br>    <span class=\"hljs-variable\">$counter</span>++<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"合并后\"><a href=\"#合并后\" class=\"headerlink\" title=\"合并后\"></a>合并后</h3><p>合并后的话只需要将开始指向合并前的最后一次提交，不就是 main 的第一个父提交吗</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">log</span> main^..HEAD<br></code></pre></td></tr></table></figure>\n\n<p>over</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://stackoverflow.com/questions/10330425/how-do-i-export-a-git-log-to-a-text-file\">How do I export a Git log to a text file?</a></li>\n<li><a href=\"https://git-scm.com/docs\">Git 官方文档</a></li>\n<li><a href=\"https://b1f6c1c4.gitbook.io/learn-git-the-super-hard-way\">learn-git-the-super-hard-way</a></li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>已将学习代码上传至 <a href=\"https://github.com/YangyangU/CodeSpace\">github</a>，欢迎大家学习指正！</p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>公司里总会有一些有趣的需求，这不，mentor：“你去调研一下，看怎么把 commit 提交说明导出到一个 txt 文件里，条目的话最好可以指定，后续我们……”。刚开始接到这个任务还是挺忙蒙的，网上应该有这个功能的第三方包吧？但是在我查询多方资料，发现 Git 真 🐂，哪需要什么第三方包！</p>\n<p>我在一个 git 学习的网站看到这句话真绷不住，赶紧跟大家分享一下</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/841eec7d5078487ebc2f15ba3a5a8756~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=842&h=130&s=15474&e=png&b=fefefe\" alt=\"image.png\" width=\"70%\" />\n\n<p>假如我真的学完了 16 章的内容，然后你跟我说还没入门？这我学集贸啊 😂。</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9d7c8aae7eb4f68b6268f1ec3c72adf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=321&h=737&s=36251&e=png&b=fefefe\" alt=\"image.png\" width=\"30%\" />\n\n<p>行了，闲话少说，我们步入正题，开始今天的分享。</p>\n<h2 id=\"拿到提交说明\"><a href=\"#拿到提交说明\" class=\"headerlink\" title=\"拿到提交说明\"></a>拿到提交说明</h2><p>我们如果想查看<code>commit</code>的内容，可以<code>git show</code>查看详细信息，它可以显示最新提交的详细信息，包括作者、日期、提交说明和每个文件的变更内容。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08cabde444e440018e9a95c357768b6d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=665&h=294&s=21106&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>但是这里只能展示最新提交，而我们的需求是可以指定条目的 commit 提交说明，而这里只显示一条，显然不满足需求。</p>\n<p>然后又找到<code>git log</code>，允许我们查看 git 仓库的提交历史，它会按照时间顺序列出提交记录，并可以显示提交的哈希值、作者、日期、提交信息等信息。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a5de345be0e492b8e76588ff5ac604e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=693&h=376&s=27111&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>这不正是我们想要的吗，看看怎么单独拿到提交说明。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b4a6454cd0d4d609d35f1b35ece3f57~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=674&h=200&s=29029&e=png&b=fbfbf8\" alt=\"image.png\"></p>\n<p><a href=\"https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History\">git 文档</a>中提到了<code>--pretty</code>这个选项，它允许日志输出默认格式以外的格式！如果我可以将输出只显示提交说明那不是美哉，于是我继续看文档。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1719fc5f89d4d4fa885d63a6f3e7628~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=671&h=230&s=24282&e=png&b=f7f6f5\" alt=\"image.png\"></p>\n<p>然后选项值为<code>format</code>时，我们就可以指定输出格式，它提供一些占位符允许我们自定义输出，文档中也对每个占位进行列举。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1064fd81ccbc41e6bfb34f69fff7a85f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=440&h=773&s=30905&e=png&b=fcfcfa\" alt=\"image.png\"></p>\n<p>其中<code>%s</code>就是我们需要的提交说明，试试看！</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fd5492cbdcd4ab485408e2778e7ad4e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=387&h=139&s=6332&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>果然成功拿到！成就感爆棚了。</p>\n<h2 id=\"导出到指定文件\"><a href=\"#导出到指定文件\" class=\"headerlink\" title=\"导出到指定文件\"></a>导出到指定文件</h2><p>我们离成功只差一步，现在我们只是在终端看到结果，怎么将终端的数据导到本地文件呢？</p>\n<p>git 有一个打包文件的方法<code>git archive</code>，这个命令本身并不支持包含提交说明字段的功能。它主要用于将指定的提交、分支或标签的代码打包成归档文件，主要关注代码本身而非提交历史，而不包含 Git 仓库的元数据（如提交历史、提交说明等），所以行不通。</p>\n<p>查了一些资料，发现已经用不着 Git 了，既然是在控制台显示，那我就用控制台的方法呗。</p>\n<h3 id=\"重定向操作符-，\"><a href=\"#重定向操作符-，\" class=\"headerlink\" title=\"重定向操作符&gt;，&gt;&gt;\"></a>重定向操作符<code>&gt;</code>，<code>&gt;&gt;</code></h3><p>在大多数命令行环境中，可以使用<code>&gt;</code>将控制台输出保存到文件中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">log</span> &gt; log.txt<br></code></pre></td></tr></table></figure>\n\n<p>这行命令将会把我们的日志保存到当前目录下的<code>log.txt</code>文件中，如果已经存在<code>log.txt</code>文件则会进行覆盖操作。</p>\n<p>而<code>&gt;&gt;</code>则会将输出追加到文件末尾，而不覆盖原有内容。</p>\n<h3 id=\"PowerShell-脚本\"><a href=\"#PowerShell-脚本\" class=\"headerlink\" title=\"PowerShell 脚本\"></a>PowerShell 脚本</h3><p>如果你使用 PowerShell，也可以通过脚本来执行 Git 命令并将输出进行保存</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">git log | <span class=\"hljs-built_in\">Out-File</span> <span class=\"hljs-literal\">-FilePath</span> log.txt<br></code></pre></td></tr></table></figure>\n\n<hr>\n<p>因为我是用 VScode，它自带的就是 PowerShell，所以就用 PowerShell 脚本给大家进行展示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">log</span> --pretty=format:<span class=\"hljs-string\">&quot;%s&quot;</span> | Out-File -FilePath commit_messages.txt<br></code></pre></td></tr></table></figure>\n\n<p>执行完命令，我们可以在当前目录下看到新生成的<code>commit_messages.txt</code>文件。</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04482d43ef534b0893bb07858a5d6e02~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=391&h=411&s=39493&e=png&b=1e1e1e\" alt=\"image.png\" width=\"50%\" />\n\n<p>当当，成功导入 txt 文件，但是我们发现文件里的中文全是乱码，为什么会这样？</p>\n<h2 id=\"解决中文乱码\"><a href=\"#解决中文乱码\" class=\"headerlink\" title=\"解决中文乱码\"></a>解决中文乱码</h2><p><strong>1. 在导出的时候明确编码</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">log</span> --pretty=format:<span class=\"hljs-string\">&quot;%s&quot;</span> | Out-File -FilePath commit_messages.txt -Encoding utf8<br></code></pre></td></tr></table></figure>\n\n<p>但是发现并不奏效</p>\n<p><strong>2. 设置 Git 输出编码</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git config --global i18n.logOutputEncoding gb2312<br></code></pre></td></tr></table></figure>\n\n<p>这里我将 git 输出的编码格式改为 gb2312，再次执行导出操作，发现乱码消失。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0b2830415434d2788d899f0ad0cf3ea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=324&h=355&s=27528&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<h2 id=\"指定输出条目和格式\"><a href=\"#指定输出条目和格式\" class=\"headerlink\" title=\"指定输出条目和格式\"></a>指定输出条目和格式</h2><p>现在我们想实现输出最新的 20 条数据，并且标上序号（如<code>1.</code>）</p>\n<p>想要指定条目，我们只需加上<code>-n + 数字</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">log</span> -n 20<br></code></pre></td></tr></table></figure>\n\n<p>这里表示指定输出最新的 20 条日志信息</p>\n<p>加上序号的话，我们可以创建一个计数器，然后对每行内容进行拼接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-variable\">$counter</span> = 1<br>git <span class=\"hljs-built_in\">log</span> -n 20 --pretty=format:<span class=\"hljs-string\">&quot;%s&quot;</span> | ForEach-Object &#123;<br>    <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$counter</span>. <span class=\"hljs-variable\">$_</span>&quot;</span> | Out-File -FilePath commit_messages.txt -Append<br>    <span class=\"hljs-variable\">$counter</span>++<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>$counter = 1</code>初始化一个计数器，初始值为 1</p>\n<p><code>ForEach-Object&#123;&#125;</code>是对输出的每一条进行单独的操作，这里进行拼接操作</p>\n<p><code>-Append</code>将内容追加到文末，而不是覆盖</p>\n<p><strong>最终效果</strong></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4e44519d6f84090991db1aa63ffc250~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=671&h=605&s=65520&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<hr>\n<p>调研完，不出意外的就要出意外了……</p>\n<p>mentor：你现在再调研一下然后实现两种方式：</p>\n<p>可以指定到具体更新了多少内容，比如说可能有两种情况：用 tag 进行区分，上次的 tag 到本次 tag 之间的 commit messages，对这个区间进行导出；另一种情况就是，拉一个新分支进行开发，新分支的最后一次提交到主分主的最后一次提交，这个区间进行导出。</p>\n<p>这些我们后期会针对不同的场景进行实施……</p>\n<h2 id=\"一些前驱知识\"><a href=\"#一些前驱知识\" class=\"headerlink\" title=\"一些前驱知识\"></a>一些前驱知识</h2><h3 id=\"区间符\"><a href=\"#区间符\" class=\"headerlink\" title=\"区间符..\"></a>区间符..</h3><p><code>..</code>允许我们指定输出的区间</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">log</span> master..HEAD<br></code></pre></td></tr></table></figure>\n\n<p>输出从 master 的最新提交到当前项目的 HEAD</p>\n<h3 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"^操作符\"></a>^操作符</h3><p><code>^</code> 操作符用于指定父提交</p>\n<p>父提交指一个提交的上一个提交。每个提交都有一个或多个父提交，具体取决于它是普通提交还是合并提交。</p>\n<h4 id=\"普通提交\"><a href=\"#普通提交\" class=\"headerlink\" title=\"普通提交\"></a>普通提交</h4><p>对于普通提交，每个提交只有一个父提交。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">A</span>-<span class=\"hljs-attr\">--B---C---D</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>提交 <code>D</code> 的父提交是 <code>C</code>。</li>\n<li>提交 <code>C</code> 的父提交是 <code>B</code>。</li>\n<li>提交 <code>B</code> 的父提交是 <code>A</code>。</li>\n</ul>\n<p>在这种情况下：</p>\n<ul>\n<li><code>D^</code> 或 <code>D^1</code> 表示提交 <code>D</code> 的父提交 <code>C</code>。</li>\n</ul>\n<h4 id=\"合并提交\"><a href=\"#合并提交\" class=\"headerlink\" title=\"合并提交\"></a>合并提交</h4><p>合并提交是指将两个或多个分支合并在一起时产生的提交。合并提交有两个或更多的父提交。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">A</span>-<span class=\"hljs-attr\">--B---C---E</span>  (<span class=\"hljs-selector-tag\">main</span>)<br>     \\     /<br>      D-<span class=\"hljs-attr\">--F</span>   (feat-test)<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>提交 <code>E</code> 是一个合并提交，合并了 <code>feat-test</code> 到 <code>main</code>。</p>\n</li>\n<li><p>提交 <code>E</code> 有两个父提交：</p>\n<ul>\n<li>第一个父提交 <code>C</code>，表示 <code>main</code> 分支在合并前的最后一个提交。</li>\n<li>第二个父提交 <code>F</code>，表示 <code>feat-test</code> 的最后一个提交。</li>\n</ul>\n</li>\n</ul>\n<p>在这种情况下：</p>\n<ul>\n<li><code>E^1</code> 表示提交 <code>E</code> 的第一个父提交 <code>C</code>。</li>\n<li><code>E^2</code> 表示提交 <code>E</code> 的第二个父提交 <code>F</code>。</li>\n</ul>\n<p>搞清楚这些，那我们的工作就好开展了</p>\n<h2 id=\"使用-Tag-进行区间导出\"><a href=\"#使用-Tag-进行区间导出\" class=\"headerlink\" title=\"使用 Tag 进行区间导出\"></a>使用 Tag 进行区间导出</h2><p>假设你有两个 tag，分别为 <code>v1.0</code> 和 <code>v2.0</code>，你想导出这两个 tag 之间的 commit messages</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-variable\">$counter</span> = 1<br>git <span class=\"hljs-built_in\">log</span> v1.0..v2.0 --pretty=format:<span class=\"hljs-string\">&quot;%s&quot;</span> | ForEach-Object &#123;<br>    <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$counter</span>. <span class=\"hljs-variable\">$_</span>&quot;</span> | Out-File -FilePath commit_messages.txt -Append<br>    <span class=\"hljs-variable\">$counter</span>++<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>v1.0..v2.0</code>就可以指定两个 tag 之间</p>\n<h2 id=\"从新分支的最后一次提交到主分支的最后一次提交\"><a href=\"#从新分支的最后一次提交到主分支的最后一次提交\" class=\"headerlink\" title=\"从新分支的最后一次提交到主分支的最后一次提交\"></a>从新分支的最后一次提交到主分支的最后一次提交</h2><p>假设你有一个新分支 <code>feat-test</code> 和主分支 <code>main</code>，这种就要分情况了，可能是合并前也可能是合并后</p>\n<h3 id=\"合并前\"><a href=\"#合并前\" class=\"headerlink\" title=\"合并前\"></a>合并前</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#合并前</span><br><span class=\"hljs-variable\">$counter</span> = 1<br>git <span class=\"hljs-built_in\">log</span> main..feat-test --pretty=format:<span class=\"hljs-string\">&quot;%s&quot;</span> | ForEach-Object &#123;<br>    <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$counter</span>. <span class=\"hljs-variable\">$_</span>&quot;</span> | Out-File -FilePath commit_messages.txt -Append<br>    <span class=\"hljs-variable\">$counter</span>++<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"合并后\"><a href=\"#合并后\" class=\"headerlink\" title=\"合并后\"></a>合并后</h3><p>合并后的话只需要将开始指向合并前的最后一次提交，不就是 main 的第一个父提交吗</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">log</span> main^..HEAD<br></code></pre></td></tr></table></figure>\n\n<p>over</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://stackoverflow.com/questions/10330425/how-do-i-export-a-git-log-to-a-text-file\">How do I export a Git log to a text file?</a></li>\n<li><a href=\"https://git-scm.com/docs\">Git 官方文档</a></li>\n<li><a href=\"https://b1f6c1c4.gitbook.io/learn-git-the-super-hard-way\">learn-git-the-super-hard-way</a></li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>已将学习代码上传至 <a href=\"https://github.com/YangyangU/CodeSpace\">github</a>，欢迎大家学习指正！</p>\n"},{"title":"面试官 ：[] == ! [] 为什么返回 true ？","date":"2023-12-04T08:00:00.000Z","index_img":"/img/面试.jpg","banner_img":"/img/default.png","_content":"\n> 本文的讲解是建立在类型转换的基础上，如果对类型转换机制不了解的同学可以先阅读一下我的上一篇文章（[看了一天的官方文档，终于搞懂了 JS 类型转换机制 - 掘金 (juejin.cn)](https://juejin.cn/post/7307857937699405862)）\n\n在 JavaScript 学习过程中，往往出现一些与我们常理相违背的结果，比如我们今天的论题`[] == ![]` ，它的返回的结果竟然是`true` ，这着实让初学者感到困惑。因为根据直觉，`[]`和`![]`两者应该是不相等的。面试官恰恰就会抓住这一点，对程序员们进行考察。\n\n而本文将结合官方文档对该题进行深度剖析。\n\n## 看看官方文档怎么说\n\n### 关于 `==`\n\n关于`==`，文档这样描述：[Annotated ES5 11.9.1](https://es5.github.io/#x11.9.1)\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/974ce8282bb642cfbf0f14bdcff5f088~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1037&h=284&s=36877&e=png&b=ffffff)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ad3699c380045b89d0047d7fec7df8b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1217&h=932&s=123351&e=png&b=ffffff)\n\n根据官方文档，我总结了以下 `==` 的隐式转换规则，一些简单的就忽略掉了：\n\n1.  **类型相同的比较：**\n\n    （1）如果类型是 Undefined 或 Null，返回 `true`。\n\n    ```js\n    null == null; // true\n    ```\n\n    （2）如果一个是 +0，另一个是 -0，返回 `true`：\n\n    ```js\n    +0 == -0; // true\n    ```\n\n    （3）如果类型是对象，二者引用同一个对象，返回 `true`，反之返回 `false`。\n\n    ```js\n    {} == {}; // false\n    ```\n\n2.  **null 和 undefined 比较：** 仅当它们之间的比较时，返回 `true`。\n\n```js\nnull == undefined; // true\n```\n\n3.  **NaN 比较：** NaN 与任何值比较都返回 `false`，包括 NaN 自己。\n\n```js\nNaN == NaN; // false\n```\n\n4.  **字符串与数字比较：** 如果其中一个操作数是字符串，另一个是数字，将字符串转换为数字，然后进行比较。\n\n```js\n\"5\" == 5; // true，将字符串 '5' 转换为数字 5 进行比较\n```\n\n5.  **布尔值与非布尔值比较：** 布尔值无法直接比较，需先将布尔值转换为数字（`true` 转换为 `1`，`false` 转换为 `0`），非布尔值也需要转换成数字再比较。\n\n```js\ntrue == 1; // true，将布尔值 true 转换为数字 1 进行比较\nfalse == \"123\"; // false，将布尔值 false 转换为数字 0 ，将字符串 '123' 转换为数字 123 进行比较\n```\n\n6.  **对象与原始类型比较：** 如果其中一个是对象，另一个是原始类型，将对象通过 `ToPrimitive` 转换为原始类型，然后进行比较。_（即如果原始类型为字符串，则对象转换成字符串再比较；如果原始类为布尔值，则将布尔值与对象都转换成数字进行比较；如果原始类为数字，则将对象转换成数字进行比较。）_\n\n举个例子：\n\n```js\n{} == 1;  //false\n```\n\n`ToPrimitive` 在我的上篇文章（[看了一天的官方文档，终于搞懂了 JS 类型转换机制](https://juejin.cn/post/7307857937699405862)）中详细介绍过，这里我们直接当做公式套用。\n\n> ToPrimitive(obj, Number) ==> Number({})\n>\n> 1.  如果 obj 是基本类型，直接返回\n> 1.  否则，调用 valueOf 方法，如果得到原始值，则返回\n> 1.  否则，调用 toString 方法，如果得到原始值，则返回\n> 1.  否则，报错\n\n首先`{}`先被`ToPrimitive`转换成字符串`\"[object Object]\"`，就相当于直接判断 `\"[object Object]\" == 1`，字符串与数字的比较中，又要将字符串转换成数字，\"[object Object]\"转换成数字为 `NaN`，而`NaN` 与任何值比较都为 `false`。\n\n所以 `{} == 1` 返回 `false`。\n\n7. **关系转换图如下：**\n\n<p align=center><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaf399a47c6f44ee8bcb54996ba8cc28~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=637&h=327&s=12357&e=png&b=ffffff\" alt=\"image.png\" width=\"70%\" /></p>\n\n---\n\n回到`[] == ! [] `\n\n这里判断`[]`与`![]`，两边都是对象，那怎么比呢，我们发现右边还有一个`!`，我们知道`!`的优先级是要大于`==`的，那么先进行非运算。\n\n### 关于 `!`\n\n关于`!`，文档这样描述：[Annotated ES5 11.4.9](https://es5.github.io/#x11.4.9)\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/744fe88550fe4c1898cb0531dfd3ff05~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=804&h=264&s=29364&e=png&b=ffffff)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04d61953adad4811aaae747aac5bc178~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=912&h=395&s=36695&e=png&b=fafafa)\n\n上表为各数据类型转换成布尔值的结果。\n\n简而言之，`!`这个运算符会进行两步操作：\n\n> 1. **对`!`后面的操作数转换成布尔值**\n>\n> 2. **将这个布尔值取反**\n\n于是我们判断`![]`，将`[]`转换成布尔值，我们在官方文档中就知道了，任何对象转换成布尔值都得到`ture`，然后在取反，得到`![]`为`false`。\n\n## 最终判断\n\n原式`[] == ![]`经过`!`运算将等式右边转换成了 `false`。即`[] == false`。\n\n接着，根据`==`隐式转换规则，等式两边为对象和布尔，那么它们都应该转换成数字进行比较。\n\n`[]`经过`ToPrimitive`会被转换成字符串`\"\"`。再将等号两边的字符串`\"\"`和布尔值`false`转换成数字 `0` ，得到 `0 == 0` 。打印得到 `true`。\n\n# 总结\n\n所以实际在进行`[] == ! []`判断时，在 JS 引擎内部，会将这行代码执行成这个样子：\n\n```js\n[] == ![]\n\n[] == !true // 将空数组这个对象类型转换成布尔值\n\n[] == false // ! 运算符对 true 进行取反\n\n'' == false // 对 [] 进行 ToPrimitive 操作，返回一个空对象\n\n0 == 0 // 将等号两边都转换成数字类型\n```\n\n# 最后\n\n**看到这里，恭喜你又拿下一道大厂面试题！**\n\n希望这篇文章能够为你提供帮助，如果你还有不懂之处，可以反复阅读，或者在评论区留言，学习是一个循序渐进，敢于试错的过程，我们顶峰相见！\n","source":"_posts/面试官为什么返回true.md","raw":"---\ntitle: 面试官 ：[] == ! [] 为什么返回 true ？\ndate: 2023-12-04 16:00:00\ntags: [JavaScript]\ncategories: JavaScript\nindex_img: /img/面试.jpg\nbanner_img: /img/default.png\n---\n\n> 本文的讲解是建立在类型转换的基础上，如果对类型转换机制不了解的同学可以先阅读一下我的上一篇文章（[看了一天的官方文档，终于搞懂了 JS 类型转换机制 - 掘金 (juejin.cn)](https://juejin.cn/post/7307857937699405862)）\n\n在 JavaScript 学习过程中，往往出现一些与我们常理相违背的结果，比如我们今天的论题`[] == ![]` ，它的返回的结果竟然是`true` ，这着实让初学者感到困惑。因为根据直觉，`[]`和`![]`两者应该是不相等的。面试官恰恰就会抓住这一点，对程序员们进行考察。\n\n而本文将结合官方文档对该题进行深度剖析。\n\n## 看看官方文档怎么说\n\n### 关于 `==`\n\n关于`==`，文档这样描述：[Annotated ES5 11.9.1](https://es5.github.io/#x11.9.1)\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/974ce8282bb642cfbf0f14bdcff5f088~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1037&h=284&s=36877&e=png&b=ffffff)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ad3699c380045b89d0047d7fec7df8b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1217&h=932&s=123351&e=png&b=ffffff)\n\n根据官方文档，我总结了以下 `==` 的隐式转换规则，一些简单的就忽略掉了：\n\n1.  **类型相同的比较：**\n\n    （1）如果类型是 Undefined 或 Null，返回 `true`。\n\n    ```js\n    null == null; // true\n    ```\n\n    （2）如果一个是 +0，另一个是 -0，返回 `true`：\n\n    ```js\n    +0 == -0; // true\n    ```\n\n    （3）如果类型是对象，二者引用同一个对象，返回 `true`，反之返回 `false`。\n\n    ```js\n    {} == {}; // false\n    ```\n\n2.  **null 和 undefined 比较：** 仅当它们之间的比较时，返回 `true`。\n\n```js\nnull == undefined; // true\n```\n\n3.  **NaN 比较：** NaN 与任何值比较都返回 `false`，包括 NaN 自己。\n\n```js\nNaN == NaN; // false\n```\n\n4.  **字符串与数字比较：** 如果其中一个操作数是字符串，另一个是数字，将字符串转换为数字，然后进行比较。\n\n```js\n\"5\" == 5; // true，将字符串 '5' 转换为数字 5 进行比较\n```\n\n5.  **布尔值与非布尔值比较：** 布尔值无法直接比较，需先将布尔值转换为数字（`true` 转换为 `1`，`false` 转换为 `0`），非布尔值也需要转换成数字再比较。\n\n```js\ntrue == 1; // true，将布尔值 true 转换为数字 1 进行比较\nfalse == \"123\"; // false，将布尔值 false 转换为数字 0 ，将字符串 '123' 转换为数字 123 进行比较\n```\n\n6.  **对象与原始类型比较：** 如果其中一个是对象，另一个是原始类型，将对象通过 `ToPrimitive` 转换为原始类型，然后进行比较。_（即如果原始类型为字符串，则对象转换成字符串再比较；如果原始类为布尔值，则将布尔值与对象都转换成数字进行比较；如果原始类为数字，则将对象转换成数字进行比较。）_\n\n举个例子：\n\n```js\n{} == 1;  //false\n```\n\n`ToPrimitive` 在我的上篇文章（[看了一天的官方文档，终于搞懂了 JS 类型转换机制](https://juejin.cn/post/7307857937699405862)）中详细介绍过，这里我们直接当做公式套用。\n\n> ToPrimitive(obj, Number) ==> Number({})\n>\n> 1.  如果 obj 是基本类型，直接返回\n> 1.  否则，调用 valueOf 方法，如果得到原始值，则返回\n> 1.  否则，调用 toString 方法，如果得到原始值，则返回\n> 1.  否则，报错\n\n首先`{}`先被`ToPrimitive`转换成字符串`\"[object Object]\"`，就相当于直接判断 `\"[object Object]\" == 1`，字符串与数字的比较中，又要将字符串转换成数字，\"[object Object]\"转换成数字为 `NaN`，而`NaN` 与任何值比较都为 `false`。\n\n所以 `{} == 1` 返回 `false`。\n\n7. **关系转换图如下：**\n\n<p align=center><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaf399a47c6f44ee8bcb54996ba8cc28~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=637&h=327&s=12357&e=png&b=ffffff\" alt=\"image.png\" width=\"70%\" /></p>\n\n---\n\n回到`[] == ! [] `\n\n这里判断`[]`与`![]`，两边都是对象，那怎么比呢，我们发现右边还有一个`!`，我们知道`!`的优先级是要大于`==`的，那么先进行非运算。\n\n### 关于 `!`\n\n关于`!`，文档这样描述：[Annotated ES5 11.4.9](https://es5.github.io/#x11.4.9)\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/744fe88550fe4c1898cb0531dfd3ff05~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=804&h=264&s=29364&e=png&b=ffffff)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04d61953adad4811aaae747aac5bc178~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=912&h=395&s=36695&e=png&b=fafafa)\n\n上表为各数据类型转换成布尔值的结果。\n\n简而言之，`!`这个运算符会进行两步操作：\n\n> 1. **对`!`后面的操作数转换成布尔值**\n>\n> 2. **将这个布尔值取反**\n\n于是我们判断`![]`，将`[]`转换成布尔值，我们在官方文档中就知道了，任何对象转换成布尔值都得到`ture`，然后在取反，得到`![]`为`false`。\n\n## 最终判断\n\n原式`[] == ![]`经过`!`运算将等式右边转换成了 `false`。即`[] == false`。\n\n接着，根据`==`隐式转换规则，等式两边为对象和布尔，那么它们都应该转换成数字进行比较。\n\n`[]`经过`ToPrimitive`会被转换成字符串`\"\"`。再将等号两边的字符串`\"\"`和布尔值`false`转换成数字 `0` ，得到 `0 == 0` 。打印得到 `true`。\n\n# 总结\n\n所以实际在进行`[] == ! []`判断时，在 JS 引擎内部，会将这行代码执行成这个样子：\n\n```js\n[] == ![]\n\n[] == !true // 将空数组这个对象类型转换成布尔值\n\n[] == false // ! 运算符对 true 进行取反\n\n'' == false // 对 [] 进行 ToPrimitive 操作，返回一个空对象\n\n0 == 0 // 将等号两边都转换成数字类型\n```\n\n# 最后\n\n**看到这里，恭喜你又拿下一道大厂面试题！**\n\n希望这篇文章能够为你提供帮助，如果你还有不懂之处，可以反复阅读，或者在评论区留言，学习是一个循序渐进，敢于试错的过程，我们顶峰相见！\n","slug":"面试官为什么返回true","published":1,"updated":"2024-09-09T15:30:36.516Z","_id":"clywvswxp0003cwv68y240h6j","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p>本文的讲解是建立在类型转换的基础上，如果对类型转换机制不了解的同学可以先阅读一下我的上一篇文章（<a href=\"https://juejin.cn/post/7307857937699405862\">看了一天的官方文档，终于搞懂了 JS 类型转换机制 - 掘金 (juejin.cn)</a>）</p>\n</blockquote>\n<p>在 JavaScript 学习过程中，往往出现一些与我们常理相违背的结果，比如我们今天的论题<code>[] == ![]</code> ，它的返回的结果竟然是<code>true</code> ，这着实让初学者感到困惑。因为根据直觉，<code>[]</code>和<code>![]</code>两者应该是不相等的。面试官恰恰就会抓住这一点，对程序员们进行考察。</p>\n<p>而本文将结合官方文档对该题进行深度剖析。</p>\n<h2 id=\"看看官方文档怎么说\"><a href=\"#看看官方文档怎么说\" class=\"headerlink\" title=\"看看官方文档怎么说\"></a>看看官方文档怎么说</h2><h3 id=\"关于\"><a href=\"#关于\" class=\"headerlink\" title=\"关于 ==\"></a>关于 <code>==</code></h3><p>关于<code>==</code>，文档这样描述：<a href=\"https://es5.github.io/#x11.9.1\">Annotated ES5 11.9.1</a></p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/974ce8282bb642cfbf0f14bdcff5f088~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1037&h=284&s=36877&e=png&b=ffffff\" alt=\"image.png\"></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ad3699c380045b89d0047d7fec7df8b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1217&h=932&s=123351&e=png&b=ffffff\" alt=\"image.png\"></p>\n<p>根据官方文档，我总结了以下 <code>==</code> 的隐式转换规则，一些简单的就忽略掉了：</p>\n<ol>\n<li><p><strong>类型相同的比较：</strong></p>\n<p>（1）如果类型是 Undefined 或 Null，返回 <code>true</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-literal\">null</span> == <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<p>（2）如果一个是 +0，另一个是 -0，返回 <code>true</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">+<span class=\"hljs-number\">0</span> == -<span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<p>（3）如果类型是对象，二者引用同一个对象，返回 <code>true</code>，反之返回 <code>false</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&#123;&#125; == &#123;&#125;; <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>null 和 undefined 比较：</strong> 仅当它们之间的比较时，返回 <code>true</code>。</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-literal\">null</span> == <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>NaN 比较：</strong> NaN 与任何值比较都返回 <code>false</code>，包括 NaN 自己。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">NaN</span> == <span class=\"hljs-title class_\">NaN</span>; <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>字符串与数字比较：</strong> 如果其中一个操作数是字符串，另一个是数字，将字符串转换为数字，然后进行比较。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-string\">&quot;5&quot;</span> == <span class=\"hljs-number\">5</span>; <span class=\"hljs-comment\">// true，将字符串 &#x27;5&#x27; 转换为数字 5 进行比较</span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li><strong>布尔值与非布尔值比较：</strong> 布尔值无法直接比较，需先将布尔值转换为数字（<code>true</code> 转换为 <code>1</code>，<code>false</code> 转换为 <code>0</code>），非布尔值也需要转换成数字再比较。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-literal\">true</span> == <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// true，将布尔值 true 转换为数字 1 进行比较</span><br><span class=\"hljs-literal\">false</span> == <span class=\"hljs-string\">&quot;123&quot;</span>; <span class=\"hljs-comment\">// false，将布尔值 false 转换为数字 0 ，将字符串 &#x27;123&#x27; 转换为数字 123 进行比较</span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li><strong>对象与原始类型比较：</strong> 如果其中一个是对象，另一个是原始类型，将对象通过 <code>ToPrimitive</code> 转换为原始类型，然后进行比较。<em>（即如果原始类型为字符串，则对象转换成字符串再比较；如果原始类为布尔值，则将布尔值与对象都转换成数字进行比较；如果原始类为数字，则将对象转换成数字进行比较。）</em></li>\n</ol>\n<p>举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&#123;&#125; == <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">//false</span><br></code></pre></td></tr></table></figure>\n\n<p><code>ToPrimitive</code> 在我的上篇文章（<a href=\"https://juejin.cn/post/7307857937699405862\">看了一天的官方文档，终于搞懂了 JS 类型转换机制</a>）中详细介绍过，这里我们直接当做公式套用。</p>\n<blockquote>\n<p>ToPrimitive(obj, Number) &#x3D;&#x3D;&gt; Number({})</p>\n<ol>\n<li>如果 obj 是基本类型，直接返回</li>\n<li>否则，调用 valueOf 方法，如果得到原始值，则返回</li>\n<li>否则，调用 toString 方法，如果得到原始值，则返回</li>\n<li>否则，报错</li>\n</ol>\n</blockquote>\n<p>首先<code>&#123;&#125;</code>先被<code>ToPrimitive</code>转换成字符串<code>&quot;[object Object]&quot;</code>，就相当于直接判断 <code>&quot;[object Object]&quot; == 1</code>，字符串与数字的比较中，又要将字符串转换成数字，”[object Object]”转换成数字为 <code>NaN</code>，而<code>NaN</code> 与任何值比较都为 <code>false</code>。</p>\n<p>所以 <code>&#123;&#125; == 1</code> 返回 <code>false</code>。</p>\n<ol start=\"7\">\n<li><strong>关系转换图如下：</strong></li>\n</ol>\n<p align=center><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaf399a47c6f44ee8bcb54996ba8cc28~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=637&h=327&s=12357&e=png&b=ffffff\" alt=\"image.png\" width=\"70%\" /></p>\n\n<hr>\n<p>回到<code>[] == ! [] </code></p>\n<p>这里判断<code>[]</code>与<code>![]</code>，两边都是对象，那怎么比呢，我们发现右边还有一个<code>!</code>，我们知道<code>!</code>的优先级是要大于<code>==</code>的，那么先进行非运算。</p>\n<h3 id=\"关于-1\"><a href=\"#关于-1\" class=\"headerlink\" title=\"关于 !\"></a>关于 <code>!</code></h3><p>关于<code>!</code>，文档这样描述：<a href=\"https://es5.github.io/#x11.4.9\">Annotated ES5 11.4.9</a><br><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/744fe88550fe4c1898cb0531dfd3ff05~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=804&h=264&s=29364&e=png&b=ffffff\" alt=\"image.png\"></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04d61953adad4811aaae747aac5bc178~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=912&h=395&s=36695&e=png&b=fafafa\" alt=\"image.png\"></p>\n<p>上表为各数据类型转换成布尔值的结果。</p>\n<p>简而言之，<code>!</code>这个运算符会进行两步操作：</p>\n<blockquote>\n<ol>\n<li><p><strong>对<code>!</code>后面的操作数转换成布尔值</strong></p>\n</li>\n<li><p><strong>将这个布尔值取反</strong></p>\n</li>\n</ol>\n</blockquote>\n<p>于是我们判断<code>![]</code>，将<code>[]</code>转换成布尔值，我们在官方文档中就知道了，任何对象转换成布尔值都得到<code>ture</code>，然后在取反，得到<code>![]</code>为<code>false</code>。</p>\n<h2 id=\"最终判断\"><a href=\"#最终判断\" class=\"headerlink\" title=\"最终判断\"></a>最终判断</h2><p>原式<code>[] == ![]</code>经过<code>!</code>运算将等式右边转换成了 <code>false</code>。即<code>[] == false</code>。</p>\n<p>接着，根据<code>==</code>隐式转换规则，等式两边为对象和布尔，那么它们都应该转换成数字进行比较。</p>\n<p><code>[]</code>经过<code>ToPrimitive</code>会被转换成字符串<code>&quot;&quot;</code>。再将等号两边的字符串<code>&quot;&quot;</code>和布尔值<code>false</code>转换成数字 <code>0</code> ，得到 <code>0 == 0</code> 。打印得到 <code>true</code>。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>所以实际在进行<code>[] == ! []</code>判断时，在 JS 引擎内部，会将这行代码执行成这个样子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">[] == ![]<br><br>[] == !<span class=\"hljs-literal\">true</span> <span class=\"hljs-comment\">// 将空数组这个对象类型转换成布尔值</span><br><br>[] == <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\">// ! 运算符对 true 进行取反</span><br><br><span class=\"hljs-string\">&#x27;&#x27;</span> == <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\">// 对 [] 进行 ToPrimitive 操作，返回一个空对象</span><br><br><span class=\"hljs-number\">0</span> == <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">// 将等号两边都转换成数字类型</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p><strong>看到这里，恭喜你又拿下一道大厂面试题！</strong></p>\n<p>希望这篇文章能够为你提供帮助，如果你还有不懂之处，可以反复阅读，或者在评论区留言，学习是一个循序渐进，敢于试错的过程，我们顶峰相见！</p>\n","excerpt":"","more":"<blockquote>\n<p>本文的讲解是建立在类型转换的基础上，如果对类型转换机制不了解的同学可以先阅读一下我的上一篇文章（<a href=\"https://juejin.cn/post/7307857937699405862\">看了一天的官方文档，终于搞懂了 JS 类型转换机制 - 掘金 (juejin.cn)</a>）</p>\n</blockquote>\n<p>在 JavaScript 学习过程中，往往出现一些与我们常理相违背的结果，比如我们今天的论题<code>[] == ![]</code> ，它的返回的结果竟然是<code>true</code> ，这着实让初学者感到困惑。因为根据直觉，<code>[]</code>和<code>![]</code>两者应该是不相等的。面试官恰恰就会抓住这一点，对程序员们进行考察。</p>\n<p>而本文将结合官方文档对该题进行深度剖析。</p>\n<h2 id=\"看看官方文档怎么说\"><a href=\"#看看官方文档怎么说\" class=\"headerlink\" title=\"看看官方文档怎么说\"></a>看看官方文档怎么说</h2><h3 id=\"关于\"><a href=\"#关于\" class=\"headerlink\" title=\"关于 ==\"></a>关于 <code>==</code></h3><p>关于<code>==</code>，文档这样描述：<a href=\"https://es5.github.io/#x11.9.1\">Annotated ES5 11.9.1</a></p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/974ce8282bb642cfbf0f14bdcff5f088~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1037&h=284&s=36877&e=png&b=ffffff\" alt=\"image.png\"></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ad3699c380045b89d0047d7fec7df8b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1217&h=932&s=123351&e=png&b=ffffff\" alt=\"image.png\"></p>\n<p>根据官方文档，我总结了以下 <code>==</code> 的隐式转换规则，一些简单的就忽略掉了：</p>\n<ol>\n<li><p><strong>类型相同的比较：</strong></p>\n<p>（1）如果类型是 Undefined 或 Null，返回 <code>true</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-literal\">null</span> == <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<p>（2）如果一个是 +0，另一个是 -0，返回 <code>true</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">+<span class=\"hljs-number\">0</span> == -<span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<p>（3）如果类型是对象，二者引用同一个对象，返回 <code>true</code>，反之返回 <code>false</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&#123;&#125; == &#123;&#125;; <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>null 和 undefined 比较：</strong> 仅当它们之间的比较时，返回 <code>true</code>。</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-literal\">null</span> == <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>NaN 比较：</strong> NaN 与任何值比较都返回 <code>false</code>，包括 NaN 自己。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">NaN</span> == <span class=\"hljs-title class_\">NaN</span>; <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>字符串与数字比较：</strong> 如果其中一个操作数是字符串，另一个是数字，将字符串转换为数字，然后进行比较。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-string\">&quot;5&quot;</span> == <span class=\"hljs-number\">5</span>; <span class=\"hljs-comment\">// true，将字符串 &#x27;5&#x27; 转换为数字 5 进行比较</span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li><strong>布尔值与非布尔值比较：</strong> 布尔值无法直接比较，需先将布尔值转换为数字（<code>true</code> 转换为 <code>1</code>，<code>false</code> 转换为 <code>0</code>），非布尔值也需要转换成数字再比较。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-literal\">true</span> == <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// true，将布尔值 true 转换为数字 1 进行比较</span><br><span class=\"hljs-literal\">false</span> == <span class=\"hljs-string\">&quot;123&quot;</span>; <span class=\"hljs-comment\">// false，将布尔值 false 转换为数字 0 ，将字符串 &#x27;123&#x27; 转换为数字 123 进行比较</span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li><strong>对象与原始类型比较：</strong> 如果其中一个是对象，另一个是原始类型，将对象通过 <code>ToPrimitive</code> 转换为原始类型，然后进行比较。<em>（即如果原始类型为字符串，则对象转换成字符串再比较；如果原始类为布尔值，则将布尔值与对象都转换成数字进行比较；如果原始类为数字，则将对象转换成数字进行比较。）</em></li>\n</ol>\n<p>举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&#123;&#125; == <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">//false</span><br></code></pre></td></tr></table></figure>\n\n<p><code>ToPrimitive</code> 在我的上篇文章（<a href=\"https://juejin.cn/post/7307857937699405862\">看了一天的官方文档，终于搞懂了 JS 类型转换机制</a>）中详细介绍过，这里我们直接当做公式套用。</p>\n<blockquote>\n<p>ToPrimitive(obj, Number) &#x3D;&#x3D;&gt; Number({})</p>\n<ol>\n<li>如果 obj 是基本类型，直接返回</li>\n<li>否则，调用 valueOf 方法，如果得到原始值，则返回</li>\n<li>否则，调用 toString 方法，如果得到原始值，则返回</li>\n<li>否则，报错</li>\n</ol>\n</blockquote>\n<p>首先<code>&#123;&#125;</code>先被<code>ToPrimitive</code>转换成字符串<code>&quot;[object Object]&quot;</code>，就相当于直接判断 <code>&quot;[object Object]&quot; == 1</code>，字符串与数字的比较中，又要将字符串转换成数字，”[object Object]”转换成数字为 <code>NaN</code>，而<code>NaN</code> 与任何值比较都为 <code>false</code>。</p>\n<p>所以 <code>&#123;&#125; == 1</code> 返回 <code>false</code>。</p>\n<ol start=\"7\">\n<li><strong>关系转换图如下：</strong></li>\n</ol>\n<p align=center><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaf399a47c6f44ee8bcb54996ba8cc28~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=637&h=327&s=12357&e=png&b=ffffff\" alt=\"image.png\" width=\"70%\" /></p>\n\n<hr>\n<p>回到<code>[] == ! [] </code></p>\n<p>这里判断<code>[]</code>与<code>![]</code>，两边都是对象，那怎么比呢，我们发现右边还有一个<code>!</code>，我们知道<code>!</code>的优先级是要大于<code>==</code>的，那么先进行非运算。</p>\n<h3 id=\"关于-1\"><a href=\"#关于-1\" class=\"headerlink\" title=\"关于 !\"></a>关于 <code>!</code></h3><p>关于<code>!</code>，文档这样描述：<a href=\"https://es5.github.io/#x11.4.9\">Annotated ES5 11.4.9</a><br><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/744fe88550fe4c1898cb0531dfd3ff05~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=804&h=264&s=29364&e=png&b=ffffff\" alt=\"image.png\"></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04d61953adad4811aaae747aac5bc178~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=912&h=395&s=36695&e=png&b=fafafa\" alt=\"image.png\"></p>\n<p>上表为各数据类型转换成布尔值的结果。</p>\n<p>简而言之，<code>!</code>这个运算符会进行两步操作：</p>\n<blockquote>\n<ol>\n<li><p><strong>对<code>!</code>后面的操作数转换成布尔值</strong></p>\n</li>\n<li><p><strong>将这个布尔值取反</strong></p>\n</li>\n</ol>\n</blockquote>\n<p>于是我们判断<code>![]</code>，将<code>[]</code>转换成布尔值，我们在官方文档中就知道了，任何对象转换成布尔值都得到<code>ture</code>，然后在取反，得到<code>![]</code>为<code>false</code>。</p>\n<h2 id=\"最终判断\"><a href=\"#最终判断\" class=\"headerlink\" title=\"最终判断\"></a>最终判断</h2><p>原式<code>[] == ![]</code>经过<code>!</code>运算将等式右边转换成了 <code>false</code>。即<code>[] == false</code>。</p>\n<p>接着，根据<code>==</code>隐式转换规则，等式两边为对象和布尔，那么它们都应该转换成数字进行比较。</p>\n<p><code>[]</code>经过<code>ToPrimitive</code>会被转换成字符串<code>&quot;&quot;</code>。再将等号两边的字符串<code>&quot;&quot;</code>和布尔值<code>false</code>转换成数字 <code>0</code> ，得到 <code>0 == 0</code> 。打印得到 <code>true</code>。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>所以实际在进行<code>[] == ! []</code>判断时，在 JS 引擎内部，会将这行代码执行成这个样子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">[] == ![]<br><br>[] == !<span class=\"hljs-literal\">true</span> <span class=\"hljs-comment\">// 将空数组这个对象类型转换成布尔值</span><br><br>[] == <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\">// ! 运算符对 true 进行取反</span><br><br><span class=\"hljs-string\">&#x27;&#x27;</span> == <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\">// 对 [] 进行 ToPrimitive 操作，返回一个空对象</span><br><br><span class=\"hljs-number\">0</span> == <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">// 将等号两边都转换成数字类型</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p><strong>看到这里，恭喜你又拿下一道大厂面试题！</strong></p>\n<p>希望这篇文章能够为你提供帮助，如果你还有不懂之处，可以反复阅读，或者在评论区留言，学习是一个循序渐进，敢于试错的过程，我们顶峰相见！</p>\n"},{"title":"快速上手 TS（环境篇）","date":"2024-06-24T08:00:00.000Z","index_img":"/img/ts.png","banner_img":"/img/default.png","_content":"\n## 前言\n\n1. [只会 Vue 的我，上班第一天就要我写 React+TS，是种什么样的体验？](https://juejin.cn/post/7377320107929829388)\n2. [只会 Vue，快速上手 React（React Router 篇）](https://juejin.cn/post/7379157261426655273)\n\n在前面两篇文章中，我分享了自己从 Vue 转 React 的心得，希望对大家有所帮助，今天再给大家分享一下如何搭建 TS 的学习环境。\n\n## 为什么要学习 TS\n\n从铺天盖地的 TS 教程，到 Vue3 被 TS 重写，种种迹象就可以见得 TS 的地位越来越重，TS 给我们开发到底带来了什么？用 JS 就不行吗？\n\nTS 的静态类型系统允许我们在开发阶段就可以发现错误，通过显示类型注解和类型推断，让我们在团队开发中协作，TS 引入面向对象编程特效，接口泛型让我们可以写更 👍 的代码。\n\n## TS 和 JS 的关系\n\n一句话解释就是 TS 是 JS 的超集。\n\nTS 与 C、Java 等众多后端语言类似，都需要先对代码进行编译才能运行。具体来说，TS 会将代码编译成浏览器或者 Node 能够读懂的 JS 代码。每次运行 TS 代码，首先需要通过 tsc 将其编译成 JS 文件，可能会生成不止一个 JS 文件。然后，我们就能够利用 TS 提供的高级特性来编写代码，同时确保最终生成的 JS 代码仍然能够成功运行。\n\n## 环境搭建\n\n### 安装 TS\n\nTS 支持全局安装和本地安装，全局顾名思义就是我们可以在任意控制台运行 TS，适合个人开发配置。而本地安装则更适用于团队开发，确保项目中使用相同版本的 TS。\n\n#### 全局安装\n\n```bash\nnpm i typescript -g\n```\n\n安装完毕，现在控制台允许我们使用 ts 编译器，执行 tsc 命令，输入以下指令查看 TS 版本，如果可以看到，则说明安装成功\n\n```bash\ntsc -v\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d96e0282663d48bea7ea3396119af66b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=271&h=37&s=2623&e=png&b=1e1e1e)\n\n#### 本地安装\n\n```bash\nnpm i --save-dev typescript\n```\n\n然后我们可以使用 npx 来运行 TS 编译器\n\n```bash\nnpx tsc -v\n```\n\n同样，如果可以看到 ts 版本，则说明安装成功\n\n### 初始化\n\n在运行 TS 代码之前，我们需要对目录进行初始化，执行以下命令会生成一个`tsconfig.json`配置文件\n\n```bash\ntsc --init\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04a56ebd53724658bd1cd70ec938995f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=669&h=227&s=11860&e=png&b=1e1e1e)\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f310e1e5007b464094d4caec62ae12b6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=207&h=68&s=2742&e=png&b=252526)\n\n#### 配置文件说明\n\n`tsconfig.json`顾名思义允许我们对 TS 进行配置，其中一些重要的配置项\n\n一个典型的`tsconfig.json`文件结构如下：\n\n```json\n{\n  \"compilerOptions\": {\n    // 编译选项\n  },\n  \"include\": [\n    // 包含的文件或目录\n  ],\n  \"exclude\": [\n    // 排除的文件或目录\n  ],\n  \"files\": [\n    // 需要编译的特定文件\n  ]\n}\n```\n\n`compilerOptions`可以配置 TS 编译器行为，常用配置项包括以下几个：\n\n```json\n\"target\": \"es2016\", //指定编译后代码的ES版本\n\"module\": \"commonjs\", //指定生成的模块系统\n\"strict\": true, //开启严格模式\n\"outDir\": \"./\", //指定编译后的文件输出的目录\n\"jsx\": \"react\", //指定JSX代码的编译方式\n\"allowJs\": true  //允许编译JS文件\n```\n\n其实这些在`tsconfig.json`文件都有注解，这里就不过多赘述\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c1714b0fcce4285adb4b4e7b88dd828~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1268&h=409&s=76064&e=png&b=1e1e1e)\n\n### 运行代码\n\n首先我们在目录下创建一个`.ts`文件，在里面书写我们需要运行的代码。\n\n🙋‍♀️🌰 创建一个 ts 文件，内容如下：\n\n```ts\n//1.ts\nlet nickname: string = \"阳阳羊\";\nconsole.log(nickname);\n```\n\n接着我们在控制台输入`tsc`命令，目录会生成一个对应的 JS 文件\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/306dca1cb3054ddc9ea339aa6e58230b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=286&h=41&s=2761&e=png&b=1e1e1e)\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cd21a3abacd432f85a0028156f0784b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=148&h=89&s=2641&e=png&b=252526)\n\ntsc 将 ts 文件编译成了 js 文件\n\n```js\n//1.js\n\"use strict\";\nlet nickname = \"阳阳羊\";\nconsole.log(nickname);\n```\n\n但是每当我们修改 TS 代码又需要重新执行一次`tsc`，很麻烦，TS 提供了一个指令`tsc --watch`（简写`tsc -w`）执行这段命令后，编译器会持续监听文件内容的变化，然后更新编译后的 JS 文件，就不用每次手动编译。\n\n拿到编译好的 JS 文件，我们执行 node 命令运行这个编译后的文件即可。\n\n#### 三方运行工具\n\n如果你觉得以上运行方式太复杂了，你可以安装第三方工具，这里我介绍两种，如果有好用的，欢迎大家在评论区分享！\n\n##### ts-node\n\n在控制台输入以下命令\n\n```bash\nnpm i ts-node -g\n```\n\n安装完毕后，在控制台输入命令`ts-node`加文件名即可\n\n```bash\nts-node 1.ts\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54151bf579ea40688ef039e8964d451f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=326&h=37&s=2526&e=png&b=1e1e1e)\n\n##### Code Runner\n\n还有一个是 VScode 中的一个插件\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94ee9c12eae8425f9698d6617f8d6897~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=629&h=149&s=16670&e=png&b=1e1e1e)\n\n安装完这个插件我们直接在文件右上角点击运行即可\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0a12dbad54144cf947eecd5024c7e6b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=806&h=144&s=13264&e=png&b=1e1e1e)\n\n这样我们可以在输出窗口看到代码运行结果\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab6912e2e2b94dfb9b71817610908034~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=601&h=118&s=14971&e=png&b=1e1e1e)\n\n## 总结\n\n以上就是《快速上手 TS（环境篇）》的全部内容了，如果你也对 TS 感兴趣，可以关注加三连，后期我会继续更新 TS 的相关知识。\n\n## 最后\n\n已将学习代码上传至 [github](https://github.com/YangyangU/CodeSpace)，欢迎大家学习指正！\n","source":"_posts/快速上手 TS（环境篇）.md","raw":"---\ntitle: 快速上手 TS（环境篇）\ndate: 2024-06-24 16:00:00\ntags: [TypeScript]\ncategories: TypeScript\nindex_img: /img/ts.png\nbanner_img: /img/default.png\n---\n\n## 前言\n\n1. [只会 Vue 的我，上班第一天就要我写 React+TS，是种什么样的体验？](https://juejin.cn/post/7377320107929829388)\n2. [只会 Vue，快速上手 React（React Router 篇）](https://juejin.cn/post/7379157261426655273)\n\n在前面两篇文章中，我分享了自己从 Vue 转 React 的心得，希望对大家有所帮助，今天再给大家分享一下如何搭建 TS 的学习环境。\n\n## 为什么要学习 TS\n\n从铺天盖地的 TS 教程，到 Vue3 被 TS 重写，种种迹象就可以见得 TS 的地位越来越重，TS 给我们开发到底带来了什么？用 JS 就不行吗？\n\nTS 的静态类型系统允许我们在开发阶段就可以发现错误，通过显示类型注解和类型推断，让我们在团队开发中协作，TS 引入面向对象编程特效，接口泛型让我们可以写更 👍 的代码。\n\n## TS 和 JS 的关系\n\n一句话解释就是 TS 是 JS 的超集。\n\nTS 与 C、Java 等众多后端语言类似，都需要先对代码进行编译才能运行。具体来说，TS 会将代码编译成浏览器或者 Node 能够读懂的 JS 代码。每次运行 TS 代码，首先需要通过 tsc 将其编译成 JS 文件，可能会生成不止一个 JS 文件。然后，我们就能够利用 TS 提供的高级特性来编写代码，同时确保最终生成的 JS 代码仍然能够成功运行。\n\n## 环境搭建\n\n### 安装 TS\n\nTS 支持全局安装和本地安装，全局顾名思义就是我们可以在任意控制台运行 TS，适合个人开发配置。而本地安装则更适用于团队开发，确保项目中使用相同版本的 TS。\n\n#### 全局安装\n\n```bash\nnpm i typescript -g\n```\n\n安装完毕，现在控制台允许我们使用 ts 编译器，执行 tsc 命令，输入以下指令查看 TS 版本，如果可以看到，则说明安装成功\n\n```bash\ntsc -v\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d96e0282663d48bea7ea3396119af66b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=271&h=37&s=2623&e=png&b=1e1e1e)\n\n#### 本地安装\n\n```bash\nnpm i --save-dev typescript\n```\n\n然后我们可以使用 npx 来运行 TS 编译器\n\n```bash\nnpx tsc -v\n```\n\n同样，如果可以看到 ts 版本，则说明安装成功\n\n### 初始化\n\n在运行 TS 代码之前，我们需要对目录进行初始化，执行以下命令会生成一个`tsconfig.json`配置文件\n\n```bash\ntsc --init\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04a56ebd53724658bd1cd70ec938995f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=669&h=227&s=11860&e=png&b=1e1e1e)\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f310e1e5007b464094d4caec62ae12b6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=207&h=68&s=2742&e=png&b=252526)\n\n#### 配置文件说明\n\n`tsconfig.json`顾名思义允许我们对 TS 进行配置，其中一些重要的配置项\n\n一个典型的`tsconfig.json`文件结构如下：\n\n```json\n{\n  \"compilerOptions\": {\n    // 编译选项\n  },\n  \"include\": [\n    // 包含的文件或目录\n  ],\n  \"exclude\": [\n    // 排除的文件或目录\n  ],\n  \"files\": [\n    // 需要编译的特定文件\n  ]\n}\n```\n\n`compilerOptions`可以配置 TS 编译器行为，常用配置项包括以下几个：\n\n```json\n\"target\": \"es2016\", //指定编译后代码的ES版本\n\"module\": \"commonjs\", //指定生成的模块系统\n\"strict\": true, //开启严格模式\n\"outDir\": \"./\", //指定编译后的文件输出的目录\n\"jsx\": \"react\", //指定JSX代码的编译方式\n\"allowJs\": true  //允许编译JS文件\n```\n\n其实这些在`tsconfig.json`文件都有注解，这里就不过多赘述\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c1714b0fcce4285adb4b4e7b88dd828~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1268&h=409&s=76064&e=png&b=1e1e1e)\n\n### 运行代码\n\n首先我们在目录下创建一个`.ts`文件，在里面书写我们需要运行的代码。\n\n🙋‍♀️🌰 创建一个 ts 文件，内容如下：\n\n```ts\n//1.ts\nlet nickname: string = \"阳阳羊\";\nconsole.log(nickname);\n```\n\n接着我们在控制台输入`tsc`命令，目录会生成一个对应的 JS 文件\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/306dca1cb3054ddc9ea339aa6e58230b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=286&h=41&s=2761&e=png&b=1e1e1e)\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cd21a3abacd432f85a0028156f0784b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=148&h=89&s=2641&e=png&b=252526)\n\ntsc 将 ts 文件编译成了 js 文件\n\n```js\n//1.js\n\"use strict\";\nlet nickname = \"阳阳羊\";\nconsole.log(nickname);\n```\n\n但是每当我们修改 TS 代码又需要重新执行一次`tsc`，很麻烦，TS 提供了一个指令`tsc --watch`（简写`tsc -w`）执行这段命令后，编译器会持续监听文件内容的变化，然后更新编译后的 JS 文件，就不用每次手动编译。\n\n拿到编译好的 JS 文件，我们执行 node 命令运行这个编译后的文件即可。\n\n#### 三方运行工具\n\n如果你觉得以上运行方式太复杂了，你可以安装第三方工具，这里我介绍两种，如果有好用的，欢迎大家在评论区分享！\n\n##### ts-node\n\n在控制台输入以下命令\n\n```bash\nnpm i ts-node -g\n```\n\n安装完毕后，在控制台输入命令`ts-node`加文件名即可\n\n```bash\nts-node 1.ts\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54151bf579ea40688ef039e8964d451f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=326&h=37&s=2526&e=png&b=1e1e1e)\n\n##### Code Runner\n\n还有一个是 VScode 中的一个插件\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94ee9c12eae8425f9698d6617f8d6897~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=629&h=149&s=16670&e=png&b=1e1e1e)\n\n安装完这个插件我们直接在文件右上角点击运行即可\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0a12dbad54144cf947eecd5024c7e6b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=806&h=144&s=13264&e=png&b=1e1e1e)\n\n这样我们可以在输出窗口看到代码运行结果\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab6912e2e2b94dfb9b71817610908034~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=601&h=118&s=14971&e=png&b=1e1e1e)\n\n## 总结\n\n以上就是《快速上手 TS（环境篇）》的全部内容了，如果你也对 TS 感兴趣，可以关注加三连，后期我会继续更新 TS 的相关知识。\n\n## 最后\n\n已将学习代码上传至 [github](https://github.com/YangyangU/CodeSpace)，欢迎大家学习指正！\n","slug":"快速上手 TS（环境篇）","published":1,"updated":"2024-09-09T15:25:29.603Z","_id":"clywvtn580006cwv6234za1sd","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ol>\n<li><a href=\"https://juejin.cn/post/7377320107929829388\">只会 Vue 的我，上班第一天就要我写 React+TS，是种什么样的体验？</a></li>\n<li><a href=\"https://juejin.cn/post/7379157261426655273\">只会 Vue，快速上手 React（React Router 篇）</a></li>\n</ol>\n<p>在前面两篇文章中，我分享了自己从 Vue 转 React 的心得，希望对大家有所帮助，今天再给大家分享一下如何搭建 TS 的学习环境。</p>\n<h2 id=\"为什么要学习-TS\"><a href=\"#为什么要学习-TS\" class=\"headerlink\" title=\"为什么要学习 TS\"></a>为什么要学习 TS</h2><p>从铺天盖地的 TS 教程，到 Vue3 被 TS 重写，种种迹象就可以见得 TS 的地位越来越重，TS 给我们开发到底带来了什么？用 JS 就不行吗？</p>\n<p>TS 的静态类型系统允许我们在开发阶段就可以发现错误，通过显示类型注解和类型推断，让我们在团队开发中协作，TS 引入面向对象编程特效，接口泛型让我们可以写更 👍 的代码。</p>\n<h2 id=\"TS-和-JS-的关系\"><a href=\"#TS-和-JS-的关系\" class=\"headerlink\" title=\"TS 和 JS 的关系\"></a>TS 和 JS 的关系</h2><p>一句话解释就是 TS 是 JS 的超集。</p>\n<p>TS 与 C、Java 等众多后端语言类似，都需要先对代码进行编译才能运行。具体来说，TS 会将代码编译成浏览器或者 Node 能够读懂的 JS 代码。每次运行 TS 代码，首先需要通过 tsc 将其编译成 JS 文件，可能会生成不止一个 JS 文件。然后，我们就能够利用 TS 提供的高级特性来编写代码，同时确保最终生成的 JS 代码仍然能够成功运行。</p>\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><h3 id=\"安装-TS\"><a href=\"#安装-TS\" class=\"headerlink\" title=\"安装 TS\"></a>安装 TS</h3><p>TS 支持全局安装和本地安装，全局顾名思义就是我们可以在任意控制台运行 TS，适合个人开发配置。而本地安装则更适用于团队开发，确保项目中使用相同版本的 TS。</p>\n<h4 id=\"全局安装\"><a href=\"#全局安装\" class=\"headerlink\" title=\"全局安装\"></a>全局安装</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm i typescript -g<br></code></pre></td></tr></table></figure>\n\n<p>安装完毕，现在控制台允许我们使用 ts 编译器，执行 tsc 命令，输入以下指令查看 TS 版本，如果可以看到，则说明安装成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">tsc -v<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d96e0282663d48bea7ea3396119af66b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=271&h=37&s=2623&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<h4 id=\"本地安装\"><a href=\"#本地安装\" class=\"headerlink\" title=\"本地安装\"></a>本地安装</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm i --save-dev typescript<br></code></pre></td></tr></table></figure>\n\n<p>然后我们可以使用 npx 来运行 TS 编译器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npx tsc -v<br></code></pre></td></tr></table></figure>\n\n<p>同样，如果可以看到 ts 版本，则说明安装成功</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>在运行 TS 代码之前，我们需要对目录进行初始化，执行以下命令会生成一个<code>tsconfig.json</code>配置文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">tsc --init<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04a56ebd53724658bd1cd70ec938995f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=669&h=227&s=11860&e=png&b=1e1e1e\" alt=\"image.png\"><br><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f310e1e5007b464094d4caec62ae12b6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=207&h=68&s=2742&e=png&b=252526\" alt=\"image.png\"></p>\n<h4 id=\"配置文件说明\"><a href=\"#配置文件说明\" class=\"headerlink\" title=\"配置文件说明\"></a>配置文件说明</h4><p><code>tsconfig.json</code>顾名思义允许我们对 TS 进行配置，其中一些重要的配置项</p>\n<p>一个典型的<code>tsconfig.json</code>文件结构如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\"><span class=\"hljs-punctuation\">&#123;</span><br>  <span class=\"hljs-attr\">&quot;compilerOptions&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span><br>    <span class=\"hljs-comment\">// 编译选项</span><br>  <span class=\"hljs-punctuation\">&#125;</span><span class=\"hljs-punctuation\">,</span><br>  <span class=\"hljs-attr\">&quot;include&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><br>    <span class=\"hljs-comment\">// 包含的文件或目录</span><br>  <span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span><br>  <span class=\"hljs-attr\">&quot;exclude&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><br>    <span class=\"hljs-comment\">// 排除的文件或目录</span><br>  <span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span><br>  <span class=\"hljs-attr\">&quot;files&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><br>    <span class=\"hljs-comment\">// 需要编译的特定文件</span><br>  <span class=\"hljs-punctuation\">]</span><br><span class=\"hljs-punctuation\">&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p><code>compilerOptions</code>可以配置 TS 编译器行为，常用配置项包括以下几个：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\"><span class=\"hljs-attr\">&quot;target&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;es2016&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">//指定编译后代码的ES版本</span><br><span class=\"hljs-attr\">&quot;module&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;commonjs&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">//指定生成的模块系统</span><br><span class=\"hljs-attr\">&quot;strict&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">true</span></span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">//开启严格模式</span><br><span class=\"hljs-attr\">&quot;outDir&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;./&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">//指定编译后的文件输出的目录</span><br><span class=\"hljs-attr\">&quot;jsx&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;react&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">//指定JSX代码的编译方式</span><br><span class=\"hljs-attr\">&quot;allowJs&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">true</span></span>  <span class=\"hljs-comment\">//允许编译JS文件</span><br></code></pre></td></tr></table></figure>\n\n<p>其实这些在<code>tsconfig.json</code>文件都有注解，这里就不过多赘述</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c1714b0fcce4285adb4b4e7b88dd828~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1268&h=409&s=76064&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<h3 id=\"运行代码\"><a href=\"#运行代码\" class=\"headerlink\" title=\"运行代码\"></a>运行代码</h3><p>首先我们在目录下创建一个<code>.ts</code>文件，在里面书写我们需要运行的代码。</p>\n<p>🙋‍♀️🌰 创建一个 ts 文件，内容如下：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">//1.ts</span><br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">nickname</span>: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&quot;阳阳羊&quot;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(nickname);<br></code></pre></td></tr></table></figure>\n\n<p>接着我们在控制台输入<code>tsc</code>命令，目录会生成一个对应的 JS 文件</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/306dca1cb3054ddc9ea339aa6e58230b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=286&h=41&s=2761&e=png&b=1e1e1e\" alt=\"image.png\"><br><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cd21a3abacd432f85a0028156f0784b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=148&h=89&s=2641&e=png&b=252526\" alt=\"image.png\"></p>\n<p>tsc 将 ts 文件编译成了 js 文件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//1.js</span><br><span class=\"hljs-meta\">&quot;use strict&quot;</span>;<br><span class=\"hljs-keyword\">let</span> nickname = <span class=\"hljs-string\">&quot;阳阳羊&quot;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(nickname);<br></code></pre></td></tr></table></figure>\n\n<p>但是每当我们修改 TS 代码又需要重新执行一次<code>tsc</code>，很麻烦，TS 提供了一个指令<code>tsc --watch</code>（简写<code>tsc -w</code>）执行这段命令后，编译器会持续监听文件内容的变化，然后更新编译后的 JS 文件，就不用每次手动编译。</p>\n<p>拿到编译好的 JS 文件，我们执行 node 命令运行这个编译后的文件即可。</p>\n<h4 id=\"三方运行工具\"><a href=\"#三方运行工具\" class=\"headerlink\" title=\"三方运行工具\"></a>三方运行工具</h4><p>如果你觉得以上运行方式太复杂了，你可以安装第三方工具，这里我介绍两种，如果有好用的，欢迎大家在评论区分享！</p>\n<h5 id=\"ts-node\"><a href=\"#ts-node\" class=\"headerlink\" title=\"ts-node\"></a>ts-node</h5><p>在控制台输入以下命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm i ts-node -g<br></code></pre></td></tr></table></figure>\n\n<p>安装完毕后，在控制台输入命令<code>ts-node</code>加文件名即可</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ts-node 1.ts<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54151bf579ea40688ef039e8964d451f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=326&h=37&s=2526&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<h5 id=\"Code-Runner\"><a href=\"#Code-Runner\" class=\"headerlink\" title=\"Code Runner\"></a>Code Runner</h5><p>还有一个是 VScode 中的一个插件</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94ee9c12eae8425f9698d6617f8d6897~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=629&h=149&s=16670&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>安装完这个插件我们直接在文件右上角点击运行即可</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0a12dbad54144cf947eecd5024c7e6b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=806&h=144&s=13264&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>这样我们可以在输出窗口看到代码运行结果</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab6912e2e2b94dfb9b71817610908034~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=601&h=118&s=14971&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>以上就是《快速上手 TS（环境篇）》的全部内容了，如果你也对 TS 感兴趣，可以关注加三连，后期我会继续更新 TS 的相关知识。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>已将学习代码上传至 <a href=\"https://github.com/YangyangU/CodeSpace\">github</a>，欢迎大家学习指正！</p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ol>\n<li><a href=\"https://juejin.cn/post/7377320107929829388\">只会 Vue 的我，上班第一天就要我写 React+TS，是种什么样的体验？</a></li>\n<li><a href=\"https://juejin.cn/post/7379157261426655273\">只会 Vue，快速上手 React（React Router 篇）</a></li>\n</ol>\n<p>在前面两篇文章中，我分享了自己从 Vue 转 React 的心得，希望对大家有所帮助，今天再给大家分享一下如何搭建 TS 的学习环境。</p>\n<h2 id=\"为什么要学习-TS\"><a href=\"#为什么要学习-TS\" class=\"headerlink\" title=\"为什么要学习 TS\"></a>为什么要学习 TS</h2><p>从铺天盖地的 TS 教程，到 Vue3 被 TS 重写，种种迹象就可以见得 TS 的地位越来越重，TS 给我们开发到底带来了什么？用 JS 就不行吗？</p>\n<p>TS 的静态类型系统允许我们在开发阶段就可以发现错误，通过显示类型注解和类型推断，让我们在团队开发中协作，TS 引入面向对象编程特效，接口泛型让我们可以写更 👍 的代码。</p>\n<h2 id=\"TS-和-JS-的关系\"><a href=\"#TS-和-JS-的关系\" class=\"headerlink\" title=\"TS 和 JS 的关系\"></a>TS 和 JS 的关系</h2><p>一句话解释就是 TS 是 JS 的超集。</p>\n<p>TS 与 C、Java 等众多后端语言类似，都需要先对代码进行编译才能运行。具体来说，TS 会将代码编译成浏览器或者 Node 能够读懂的 JS 代码。每次运行 TS 代码，首先需要通过 tsc 将其编译成 JS 文件，可能会生成不止一个 JS 文件。然后，我们就能够利用 TS 提供的高级特性来编写代码，同时确保最终生成的 JS 代码仍然能够成功运行。</p>\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><h3 id=\"安装-TS\"><a href=\"#安装-TS\" class=\"headerlink\" title=\"安装 TS\"></a>安装 TS</h3><p>TS 支持全局安装和本地安装，全局顾名思义就是我们可以在任意控制台运行 TS，适合个人开发配置。而本地安装则更适用于团队开发，确保项目中使用相同版本的 TS。</p>\n<h4 id=\"全局安装\"><a href=\"#全局安装\" class=\"headerlink\" title=\"全局安装\"></a>全局安装</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm i typescript -g<br></code></pre></td></tr></table></figure>\n\n<p>安装完毕，现在控制台允许我们使用 ts 编译器，执行 tsc 命令，输入以下指令查看 TS 版本，如果可以看到，则说明安装成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">tsc -v<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d96e0282663d48bea7ea3396119af66b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=271&h=37&s=2623&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<h4 id=\"本地安装\"><a href=\"#本地安装\" class=\"headerlink\" title=\"本地安装\"></a>本地安装</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm i --save-dev typescript<br></code></pre></td></tr></table></figure>\n\n<p>然后我们可以使用 npx 来运行 TS 编译器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npx tsc -v<br></code></pre></td></tr></table></figure>\n\n<p>同样，如果可以看到 ts 版本，则说明安装成功</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>在运行 TS 代码之前，我们需要对目录进行初始化，执行以下命令会生成一个<code>tsconfig.json</code>配置文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">tsc --init<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04a56ebd53724658bd1cd70ec938995f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=669&h=227&s=11860&e=png&b=1e1e1e\" alt=\"image.png\"><br><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f310e1e5007b464094d4caec62ae12b6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=207&h=68&s=2742&e=png&b=252526\" alt=\"image.png\"></p>\n<h4 id=\"配置文件说明\"><a href=\"#配置文件说明\" class=\"headerlink\" title=\"配置文件说明\"></a>配置文件说明</h4><p><code>tsconfig.json</code>顾名思义允许我们对 TS 进行配置，其中一些重要的配置项</p>\n<p>一个典型的<code>tsconfig.json</code>文件结构如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\"><span class=\"hljs-punctuation\">&#123;</span><br>  <span class=\"hljs-attr\">&quot;compilerOptions&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span><br>    <span class=\"hljs-comment\">// 编译选项</span><br>  <span class=\"hljs-punctuation\">&#125;</span><span class=\"hljs-punctuation\">,</span><br>  <span class=\"hljs-attr\">&quot;include&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><br>    <span class=\"hljs-comment\">// 包含的文件或目录</span><br>  <span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span><br>  <span class=\"hljs-attr\">&quot;exclude&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><br>    <span class=\"hljs-comment\">// 排除的文件或目录</span><br>  <span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span><br>  <span class=\"hljs-attr\">&quot;files&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><br>    <span class=\"hljs-comment\">// 需要编译的特定文件</span><br>  <span class=\"hljs-punctuation\">]</span><br><span class=\"hljs-punctuation\">&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p><code>compilerOptions</code>可以配置 TS 编译器行为，常用配置项包括以下几个：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\"><span class=\"hljs-attr\">&quot;target&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;es2016&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">//指定编译后代码的ES版本</span><br><span class=\"hljs-attr\">&quot;module&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;commonjs&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">//指定生成的模块系统</span><br><span class=\"hljs-attr\">&quot;strict&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">true</span></span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">//开启严格模式</span><br><span class=\"hljs-attr\">&quot;outDir&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;./&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">//指定编译后的文件输出的目录</span><br><span class=\"hljs-attr\">&quot;jsx&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;react&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">//指定JSX代码的编译方式</span><br><span class=\"hljs-attr\">&quot;allowJs&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">true</span></span>  <span class=\"hljs-comment\">//允许编译JS文件</span><br></code></pre></td></tr></table></figure>\n\n<p>其实这些在<code>tsconfig.json</code>文件都有注解，这里就不过多赘述</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c1714b0fcce4285adb4b4e7b88dd828~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1268&h=409&s=76064&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<h3 id=\"运行代码\"><a href=\"#运行代码\" class=\"headerlink\" title=\"运行代码\"></a>运行代码</h3><p>首先我们在目录下创建一个<code>.ts</code>文件，在里面书写我们需要运行的代码。</p>\n<p>🙋‍♀️🌰 创建一个 ts 文件，内容如下：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">//1.ts</span><br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">nickname</span>: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&quot;阳阳羊&quot;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(nickname);<br></code></pre></td></tr></table></figure>\n\n<p>接着我们在控制台输入<code>tsc</code>命令，目录会生成一个对应的 JS 文件</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/306dca1cb3054ddc9ea339aa6e58230b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=286&h=41&s=2761&e=png&b=1e1e1e\" alt=\"image.png\"><br><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cd21a3abacd432f85a0028156f0784b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=148&h=89&s=2641&e=png&b=252526\" alt=\"image.png\"></p>\n<p>tsc 将 ts 文件编译成了 js 文件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//1.js</span><br><span class=\"hljs-meta\">&quot;use strict&quot;</span>;<br><span class=\"hljs-keyword\">let</span> nickname = <span class=\"hljs-string\">&quot;阳阳羊&quot;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(nickname);<br></code></pre></td></tr></table></figure>\n\n<p>但是每当我们修改 TS 代码又需要重新执行一次<code>tsc</code>，很麻烦，TS 提供了一个指令<code>tsc --watch</code>（简写<code>tsc -w</code>）执行这段命令后，编译器会持续监听文件内容的变化，然后更新编译后的 JS 文件，就不用每次手动编译。</p>\n<p>拿到编译好的 JS 文件，我们执行 node 命令运行这个编译后的文件即可。</p>\n<h4 id=\"三方运行工具\"><a href=\"#三方运行工具\" class=\"headerlink\" title=\"三方运行工具\"></a>三方运行工具</h4><p>如果你觉得以上运行方式太复杂了，你可以安装第三方工具，这里我介绍两种，如果有好用的，欢迎大家在评论区分享！</p>\n<h5 id=\"ts-node\"><a href=\"#ts-node\" class=\"headerlink\" title=\"ts-node\"></a>ts-node</h5><p>在控制台输入以下命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm i ts-node -g<br></code></pre></td></tr></table></figure>\n\n<p>安装完毕后，在控制台输入命令<code>ts-node</code>加文件名即可</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ts-node 1.ts<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54151bf579ea40688ef039e8964d451f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=326&h=37&s=2526&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<h5 id=\"Code-Runner\"><a href=\"#Code-Runner\" class=\"headerlink\" title=\"Code Runner\"></a>Code Runner</h5><p>还有一个是 VScode 中的一个插件</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94ee9c12eae8425f9698d6617f8d6897~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=629&h=149&s=16670&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>安装完这个插件我们直接在文件右上角点击运行即可</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0a12dbad54144cf947eecd5024c7e6b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=806&h=144&s=13264&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>这样我们可以在输出窗口看到代码运行结果</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab6912e2e2b94dfb9b71817610908034~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=601&h=118&s=14971&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>以上就是《快速上手 TS（环境篇）》的全部内容了，如果你也对 TS 感兴趣，可以关注加三连，后期我会继续更新 TS 的相关知识。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>已将学习代码上传至 <a href=\"https://github.com/YangyangU/CodeSpace\">github</a>，欢迎大家学习指正！</p>\n"},{"title":"只会Vue，快速上手React（React Router篇）","date":"2024-06-12T08:00:00.000Z","index_img":"/img/react路由.jpg","banner_img":"/img/default.png","_content":"\n## 前言\n\n在上文中（[只会 Vue 的我，上班第一天就要我写 React+TS，是种什么样的体验？](https://juejin.cn/post/7377320107929829388)），我们讲述了 React 从项目创建到如何实现自定义 Hooks ，比较偏基础，今天这篇文章将带大家学习 React Router。\n\n## React Router\n\n如果你对 Vue Router 有了解的话，那么 React Router 肯定也不在话下，因为他们实在太相似了。我们知道前端路由是一个在单页应用中管理不同页面的导航，无需向服务器发送请求重新加载整个页面。即一个`path`对应一个`component`。所以 Router 在不管是 Vue 还是 React 亦或是 Angular 都是前端单页应用不可或缺的一部分。\n\n### 安装\n\n选择自己喜欢的包管理工具，这里需要注意安装的是 `react-router-dom`，后面有个 dom，跟 `react-dom` 一个道理，React Router 库分为多个包，其中`react-router-dom`是专门用于在浏览器中运行 React 的路由方案，适合 Web 开发。如果是移动端开发应该用`react-router-native`。\n\n```bash\nnpm install react-router-dom\n```\n\n### 路由模式\n\n我们知道在 Vue 中有两种路由模式 History 跟 Hash 模式，React 同样。下表是我对这两者的简单对比，想必大家背八股的时候就已经熟记于心了。\n\n| 模式    | url         | 原理                          | 后端支持 |\n| ------- | ----------- | ----------------------------- | -------- |\n| history | url/login   | history 对象 + pushState 事件 | 需要     |\n| hash    | url/#/login | hashChange 事件               | 不需要   |\n\n### 基本使用\n\n主要文件目录如下\n\n```lua\nsrc/\n|-- pages/\n|   |-- Login.jsx\n|   |-- About.jsx\n|-- router/\n|   |-- index.jsx\n|-- App.jsx\n|-- main.jsx\n```\n\n我们一般都在`src`下新建目录`router`，然后在`index.jsx`中创建路由。\n\n```jsx\n// router/index.jsx\nimport { createBrowserRouter } from \"react-router-dom\";\nimport Login from \"@/views/Login\";\nimport Home from \"@/views/Home\";\n\nconst router = createBrowserRouter([\n  //创建 history 路由\n  {\n    path: \"/home\",\n    element: <Home />,\n  },\n  {\n    path: \"/login\",\n    element: <Login />,\n  },\n]);\n\nexport default router;\n```\n\n`react-router-dom`提供`createBrowserRouter`API 跟 Vue Router 提供的`createWebHistory`一样，允许我们创建 History 模式路由，Hash 模式 React 与 Vue 分别对应`createHashRouter`与`createWebHashHistory`，如果记混了可以自行查文档。\n\n```js\n// app.jsx\nimport \"./App.css\";\nimport { RouterProvider } from \"react-router-dom\";\nimport router from \"./router\";\n\nfunction App() {\n  return <RouterProvider router={router}></RouterProvider>;\n}\n\nexport default App;\n```\n\n创建好了就该使用了，在 Vue 中是直接在`main.js`中 App 根组件直接`use`掉，而在 React 中则有所不同， React Router 专门提供一个组件 `RouterProvider`，用于将路由配置传递给应用。它接受一个`router`prop，该 prop 是在刚刚创建的路由实例。\n\n### 导航跳转\n\n#### 声明式导航\n\n通过在模板中使用`<Link />`组件，通过`to`属性指定要跳转的路径，跟 Vue 的`router-link`很类似，\n\n🌰 现在我们要实现从登录页跳转至首页：\n\n```js\nimport React from \"react\";\nimport { Link } from \"react-router-dom\";\n\nconst Login = () => {\n  return (\n    <div>\n      Login\n      <Link to=\"/home\">跳转至首页</Link>\n    </div>\n  );\n};\n\nexport default Login;\n```\n\n我们先手动去到`/login`路径。\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6feb8ec6848414e84874849c93a663c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=657&h=364&s=25231&e=gif&f=6&b=fefefe\" alt=\"GIF 2024-6-12 10-42-24.gif\" width=\"50%\" />\n\n#### 编程式导航\n\n通过`useNavigate`钩子拿到导航方法，再通过调用命令式进行跳转。类似于 Vue 的`router.push()`\n\n🌰 一样的场景:\n\n```jsx\nimport React from \"react\";\nimport { useNavigate } from \"react-router-dom\";\n\nconst Login = () => {\n  const navigate = useNavigate();\n  return (\n    <div>\n      <h1>Login</h1>\n      <button onClick={() => navigate(\"/home\")}>跳转</button>\n    </div>\n  );\n};\n\nexport default Login;\n```\n\n通过事件驱动跳转，更加灵活。\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f6cfd379e4b4af28cedbeccd34e2914~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=620&h=402&s=15187&e=gif&f=4&b=fefefe\" alt=\"GIF 2024-6-12 10-51-15.gif\" width=\"50%\" />\n\n### 导航传参\n\nReact 提供了两个钩子允许我们进行导航传参。\n\n#### useSearchParams 传参\n\n这里我们在 Login 页面进行跳转，并用`?`+`参数名`=`参数`拼接，多个参数用`&`拼接。\n\n```jsx\n// login.jsx\nimport React from \"react\";\nimport { useNavigate } from \"react-router-dom\";\n\nconst Login = () => {\n  const navigate = useNavigate();\n  return (\n    <div>\n      <h1>Login</h1>\n      <button onClick={() => navigate(\"/home?id=1&name=yangyang\")}>\n        跳转传参\n      </button>\n    </div>\n  );\n};\n\nexport default Login;\n```\n\n`useSearchParams`运行我们解构出一个对象，这个对象包含了所有通过`?`后的参数\n\n```jsx\n// home.jsx\nimport React from \"react\";\nimport { useSearchParams } from \"react-router-dom\";\n\nconst Home = () => {\n  const [params] = useSearchParams();\n  console.log(params);\n  return (\n    <div>\n      <h1>Home</h1>\n      <div>id:{params.get(\"id\")}</div>\n      <div>name:{params.get(\"name\")}</div>\n    </div>\n  );\n};\n\nexport default Home;\n```\n\n我们打印 params 对象看看\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70e2dac1326f474990f1a4f45d64c293~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=931&h=692&s=98095&e=png&b=ffffff\" alt=\"image.png\" width=\"70%\" />\n\n它是一个`URLSearchParams` 对象，包含了一系列方法，我们可以使用`get`方法查询参数\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f193eca1b6147709683f5f511bfeab0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=975&h=431&s=59017&e=gif&f=10&b=fefefe\" alt=\"GIF 2024-6-12 12-16-59.gif\" width=\"50%\" />\n\n#### useParams\n\n这里我们还是在 Login 页面进行跳转，我们直接在路径后面继续接`/`+`参数`，\n\n```jsx\n// login.jsx\nimport React from \"react\";\nimport { useNavigate } from \"react-router-dom\";\n\nconst Login = () => {\n  const navigate = useNavigate();\n  return (\n    <div>\n      <h1>Login</h1>\n      <button onClick={() => navigate(\"/home/1/yangyang\")}>跳转传参</button>\n    </div>\n  );\n};\n\nexport default Login;\n```\n\n不仅如此，还需要修改`router`配置，将补全`path`用`:`+`参数名`，这样才能一一匹配。\n\n```jsx\n{\n    path: '/home/:id/:name',\n    element: <Home />,\n},\n```\n\n最后，在 Home 页面接收参数，调用`useParams`得到一个对象，对象的每个属性就是我们传递的参数\n\n```jsx\n// home.jsx\nimport { useParams } from \"react-router-dom\";\n\nconst Home = () => {\n  const params = useParams();\n  console.log(params);\n  return (\n    <div>\n      <h1>Home</h1>\n      <div>id:{params.id}</div>\n      <div>name:{params.name}</div>\n    </div>\n  );\n};\n\nexport default Home;\n```\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cf0aba3e4f04eb2a44b825b255ab089~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=930&h=146&s=15495&e=png&b=ffffff\" alt=\"image.png\" width=\"70%\" />\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/122da242b0d642c8a54c722b65722c58~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=819&h=431&s=22894&e=gif&f=3&b=fefefe\" alt=\"GIF 2024-6-12 12-30-26.gif\" width=\"50%\" />\n\n### 嵌套路由\n\n跟 Vue 一样，React 同样允许你在一个路由组件的`children`属性中配置子路由。\n\n```js\n// router/index.js\nconst router = createBrowserRouter([\n  {\n    path: \"/home\",\n    element: <Home />,\n    children: [\n      {\n        index: true, //默认二级路由\n        path: \"board\",\n        element: <Board />,\n      },\n      {\n        path: \"about\",\n        element: <About />,\n      },\n    ],\n  },\n  {\n    path: \"/login\",\n    element: <Login />,\n  },\n]);\n```\n\n二级路由的`path`如果不写`/`，会默认拼接在父级路由后面，配置`index:true`表示默认显示该路由。\n\n```js\n// home.js\nimport { Link, Outlet } from \"react-router-dom\";\n\nconst Home = () => {\n  return (\n    <div>\n      <h1>Home</h1>\n      <Link to=\"board\">面板</Link>|<Link to=\"about\">关于</Link>\n      <Outlet />\n    </div>\n  );\n};\n\nexport default Home;\n```\n\n我们通过`Link`组件进行跳转，`Outlet`组件是二级路由的出口，你定义在哪，那么组件就会在哪显示，跟 Vue 的`router-view`类似。\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dea9a7b1b404ce2883e79efc33d5304~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=719&h=437&s=38430&e=gif&f=16&b=fefefe\" alt=\"GIF 2024-6-12 15-00-00.gif\" width=\"50%\" />\n\n### 懒加载\n\nReact 提供了`React.lazy`和`Suspense`组件来实现懒加载。`React.lazy`用于定义懒加载的组件，`Suspense`用于在组件加载时显示。\n\n```js\nimport { createBrowserRouter } from \"react-router-dom\";\nimport { Suspense, lazy } from \"react\";\n\nconst Home = lazy(() => import(\"@/pages/Home\"));\nconst Login = lazy(() => import(\"@/pages/Login\"));\nconst Board = lazy(() => import(\"@/pages/Board\"));\nconst About = lazy(() => import(\"@/pages/About\"));\n\nconst router = createBrowserRouter([\n  {\n    path: \"/login\",\n    element: (\n      <Suspense fallback={\"加载中\"}>\n        <Login />\n      </Suspense>\n    ),\n  },\n  {\n    path: \"/home\",\n    element: (\n      <Suspense fallback={\"加载中\"}>\n        <Home />\n      </Suspense>\n    ),\n    children: [\n      {\n        index: true,\n        path: \"board\",\n        element: (\n          <Suspense fallback={\"加载中\"}>\n            <Board />\n          </Suspense>\n        ),\n      },\n      {\n        path: \"about\",\n        element: (\n          <Suspense fallback={\"加载中\"}>\n            <About />\n          </Suspense>\n        ),\n      },\n    ],\n  },\n]);\n\nexport default router;\n```\n\n通过套一层`lazy`就可以实现懒加载，`Suspense`提供 loading 内容。\n\n## 总结\n\n不管是 Vue 还是 React ，前端路由的大致理念都是一样的，我们如果知道一个，很容易融汇贯通。还是那句话，多看文档，多敲代码，多实践！\n\n## 参考\n\n- [React-中文官网](https://zh-hans.react.dev/learn)\n- [React-Router-官网](https://reactrouter.com/en/main/start/overview)\n\n## 最后\n\n已将学习代码上传至 [github](https://github.com/YangyangU/CodeSpace)，欢迎大家学习指正！\n","source":"_posts/只会Vue，快速上手React（React Router篇）.md","raw":"---\ntitle: 只会Vue，快速上手React（React Router篇）\ndate: 2024-06-12 16:00:00\ntags: [React]\ncategories: React\nindex_img: /img/react路由.jpg\nbanner_img: /img/default.png\n---\n\n## 前言\n\n在上文中（[只会 Vue 的我，上班第一天就要我写 React+TS，是种什么样的体验？](https://juejin.cn/post/7377320107929829388)），我们讲述了 React 从项目创建到如何实现自定义 Hooks ，比较偏基础，今天这篇文章将带大家学习 React Router。\n\n## React Router\n\n如果你对 Vue Router 有了解的话，那么 React Router 肯定也不在话下，因为他们实在太相似了。我们知道前端路由是一个在单页应用中管理不同页面的导航，无需向服务器发送请求重新加载整个页面。即一个`path`对应一个`component`。所以 Router 在不管是 Vue 还是 React 亦或是 Angular 都是前端单页应用不可或缺的一部分。\n\n### 安装\n\n选择自己喜欢的包管理工具，这里需要注意安装的是 `react-router-dom`，后面有个 dom，跟 `react-dom` 一个道理，React Router 库分为多个包，其中`react-router-dom`是专门用于在浏览器中运行 React 的路由方案，适合 Web 开发。如果是移动端开发应该用`react-router-native`。\n\n```bash\nnpm install react-router-dom\n```\n\n### 路由模式\n\n我们知道在 Vue 中有两种路由模式 History 跟 Hash 模式，React 同样。下表是我对这两者的简单对比，想必大家背八股的时候就已经熟记于心了。\n\n| 模式    | url         | 原理                          | 后端支持 |\n| ------- | ----------- | ----------------------------- | -------- |\n| history | url/login   | history 对象 + pushState 事件 | 需要     |\n| hash    | url/#/login | hashChange 事件               | 不需要   |\n\n### 基本使用\n\n主要文件目录如下\n\n```lua\nsrc/\n|-- pages/\n|   |-- Login.jsx\n|   |-- About.jsx\n|-- router/\n|   |-- index.jsx\n|-- App.jsx\n|-- main.jsx\n```\n\n我们一般都在`src`下新建目录`router`，然后在`index.jsx`中创建路由。\n\n```jsx\n// router/index.jsx\nimport { createBrowserRouter } from \"react-router-dom\";\nimport Login from \"@/views/Login\";\nimport Home from \"@/views/Home\";\n\nconst router = createBrowserRouter([\n  //创建 history 路由\n  {\n    path: \"/home\",\n    element: <Home />,\n  },\n  {\n    path: \"/login\",\n    element: <Login />,\n  },\n]);\n\nexport default router;\n```\n\n`react-router-dom`提供`createBrowserRouter`API 跟 Vue Router 提供的`createWebHistory`一样，允许我们创建 History 模式路由，Hash 模式 React 与 Vue 分别对应`createHashRouter`与`createWebHashHistory`，如果记混了可以自行查文档。\n\n```js\n// app.jsx\nimport \"./App.css\";\nimport { RouterProvider } from \"react-router-dom\";\nimport router from \"./router\";\n\nfunction App() {\n  return <RouterProvider router={router}></RouterProvider>;\n}\n\nexport default App;\n```\n\n创建好了就该使用了，在 Vue 中是直接在`main.js`中 App 根组件直接`use`掉，而在 React 中则有所不同， React Router 专门提供一个组件 `RouterProvider`，用于将路由配置传递给应用。它接受一个`router`prop，该 prop 是在刚刚创建的路由实例。\n\n### 导航跳转\n\n#### 声明式导航\n\n通过在模板中使用`<Link />`组件，通过`to`属性指定要跳转的路径，跟 Vue 的`router-link`很类似，\n\n🌰 现在我们要实现从登录页跳转至首页：\n\n```js\nimport React from \"react\";\nimport { Link } from \"react-router-dom\";\n\nconst Login = () => {\n  return (\n    <div>\n      Login\n      <Link to=\"/home\">跳转至首页</Link>\n    </div>\n  );\n};\n\nexport default Login;\n```\n\n我们先手动去到`/login`路径。\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6feb8ec6848414e84874849c93a663c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=657&h=364&s=25231&e=gif&f=6&b=fefefe\" alt=\"GIF 2024-6-12 10-42-24.gif\" width=\"50%\" />\n\n#### 编程式导航\n\n通过`useNavigate`钩子拿到导航方法，再通过调用命令式进行跳转。类似于 Vue 的`router.push()`\n\n🌰 一样的场景:\n\n```jsx\nimport React from \"react\";\nimport { useNavigate } from \"react-router-dom\";\n\nconst Login = () => {\n  const navigate = useNavigate();\n  return (\n    <div>\n      <h1>Login</h1>\n      <button onClick={() => navigate(\"/home\")}>跳转</button>\n    </div>\n  );\n};\n\nexport default Login;\n```\n\n通过事件驱动跳转，更加灵活。\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f6cfd379e4b4af28cedbeccd34e2914~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=620&h=402&s=15187&e=gif&f=4&b=fefefe\" alt=\"GIF 2024-6-12 10-51-15.gif\" width=\"50%\" />\n\n### 导航传参\n\nReact 提供了两个钩子允许我们进行导航传参。\n\n#### useSearchParams 传参\n\n这里我们在 Login 页面进行跳转，并用`?`+`参数名`=`参数`拼接，多个参数用`&`拼接。\n\n```jsx\n// login.jsx\nimport React from \"react\";\nimport { useNavigate } from \"react-router-dom\";\n\nconst Login = () => {\n  const navigate = useNavigate();\n  return (\n    <div>\n      <h1>Login</h1>\n      <button onClick={() => navigate(\"/home?id=1&name=yangyang\")}>\n        跳转传参\n      </button>\n    </div>\n  );\n};\n\nexport default Login;\n```\n\n`useSearchParams`运行我们解构出一个对象，这个对象包含了所有通过`?`后的参数\n\n```jsx\n// home.jsx\nimport React from \"react\";\nimport { useSearchParams } from \"react-router-dom\";\n\nconst Home = () => {\n  const [params] = useSearchParams();\n  console.log(params);\n  return (\n    <div>\n      <h1>Home</h1>\n      <div>id:{params.get(\"id\")}</div>\n      <div>name:{params.get(\"name\")}</div>\n    </div>\n  );\n};\n\nexport default Home;\n```\n\n我们打印 params 对象看看\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70e2dac1326f474990f1a4f45d64c293~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=931&h=692&s=98095&e=png&b=ffffff\" alt=\"image.png\" width=\"70%\" />\n\n它是一个`URLSearchParams` 对象，包含了一系列方法，我们可以使用`get`方法查询参数\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f193eca1b6147709683f5f511bfeab0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=975&h=431&s=59017&e=gif&f=10&b=fefefe\" alt=\"GIF 2024-6-12 12-16-59.gif\" width=\"50%\" />\n\n#### useParams\n\n这里我们还是在 Login 页面进行跳转，我们直接在路径后面继续接`/`+`参数`，\n\n```jsx\n// login.jsx\nimport React from \"react\";\nimport { useNavigate } from \"react-router-dom\";\n\nconst Login = () => {\n  const navigate = useNavigate();\n  return (\n    <div>\n      <h1>Login</h1>\n      <button onClick={() => navigate(\"/home/1/yangyang\")}>跳转传参</button>\n    </div>\n  );\n};\n\nexport default Login;\n```\n\n不仅如此，还需要修改`router`配置，将补全`path`用`:`+`参数名`，这样才能一一匹配。\n\n```jsx\n{\n    path: '/home/:id/:name',\n    element: <Home />,\n},\n```\n\n最后，在 Home 页面接收参数，调用`useParams`得到一个对象，对象的每个属性就是我们传递的参数\n\n```jsx\n// home.jsx\nimport { useParams } from \"react-router-dom\";\n\nconst Home = () => {\n  const params = useParams();\n  console.log(params);\n  return (\n    <div>\n      <h1>Home</h1>\n      <div>id:{params.id}</div>\n      <div>name:{params.name}</div>\n    </div>\n  );\n};\n\nexport default Home;\n```\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cf0aba3e4f04eb2a44b825b255ab089~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=930&h=146&s=15495&e=png&b=ffffff\" alt=\"image.png\" width=\"70%\" />\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/122da242b0d642c8a54c722b65722c58~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=819&h=431&s=22894&e=gif&f=3&b=fefefe\" alt=\"GIF 2024-6-12 12-30-26.gif\" width=\"50%\" />\n\n### 嵌套路由\n\n跟 Vue 一样，React 同样允许你在一个路由组件的`children`属性中配置子路由。\n\n```js\n// router/index.js\nconst router = createBrowserRouter([\n  {\n    path: \"/home\",\n    element: <Home />,\n    children: [\n      {\n        index: true, //默认二级路由\n        path: \"board\",\n        element: <Board />,\n      },\n      {\n        path: \"about\",\n        element: <About />,\n      },\n    ],\n  },\n  {\n    path: \"/login\",\n    element: <Login />,\n  },\n]);\n```\n\n二级路由的`path`如果不写`/`，会默认拼接在父级路由后面，配置`index:true`表示默认显示该路由。\n\n```js\n// home.js\nimport { Link, Outlet } from \"react-router-dom\";\n\nconst Home = () => {\n  return (\n    <div>\n      <h1>Home</h1>\n      <Link to=\"board\">面板</Link>|<Link to=\"about\">关于</Link>\n      <Outlet />\n    </div>\n  );\n};\n\nexport default Home;\n```\n\n我们通过`Link`组件进行跳转，`Outlet`组件是二级路由的出口，你定义在哪，那么组件就会在哪显示，跟 Vue 的`router-view`类似。\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dea9a7b1b404ce2883e79efc33d5304~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=719&h=437&s=38430&e=gif&f=16&b=fefefe\" alt=\"GIF 2024-6-12 15-00-00.gif\" width=\"50%\" />\n\n### 懒加载\n\nReact 提供了`React.lazy`和`Suspense`组件来实现懒加载。`React.lazy`用于定义懒加载的组件，`Suspense`用于在组件加载时显示。\n\n```js\nimport { createBrowserRouter } from \"react-router-dom\";\nimport { Suspense, lazy } from \"react\";\n\nconst Home = lazy(() => import(\"@/pages/Home\"));\nconst Login = lazy(() => import(\"@/pages/Login\"));\nconst Board = lazy(() => import(\"@/pages/Board\"));\nconst About = lazy(() => import(\"@/pages/About\"));\n\nconst router = createBrowserRouter([\n  {\n    path: \"/login\",\n    element: (\n      <Suspense fallback={\"加载中\"}>\n        <Login />\n      </Suspense>\n    ),\n  },\n  {\n    path: \"/home\",\n    element: (\n      <Suspense fallback={\"加载中\"}>\n        <Home />\n      </Suspense>\n    ),\n    children: [\n      {\n        index: true,\n        path: \"board\",\n        element: (\n          <Suspense fallback={\"加载中\"}>\n            <Board />\n          </Suspense>\n        ),\n      },\n      {\n        path: \"about\",\n        element: (\n          <Suspense fallback={\"加载中\"}>\n            <About />\n          </Suspense>\n        ),\n      },\n    ],\n  },\n]);\n\nexport default router;\n```\n\n通过套一层`lazy`就可以实现懒加载，`Suspense`提供 loading 内容。\n\n## 总结\n\n不管是 Vue 还是 React ，前端路由的大致理念都是一样的，我们如果知道一个，很容易融汇贯通。还是那句话，多看文档，多敲代码，多实践！\n\n## 参考\n\n- [React-中文官网](https://zh-hans.react.dev/learn)\n- [React-Router-官网](https://reactrouter.com/en/main/start/overview)\n\n## 最后\n\n已将学习代码上传至 [github](https://github.com/YangyangU/CodeSpace)，欢迎大家学习指正！\n","slug":"只会Vue，快速上手React（React Router篇）","published":1,"updated":"2024-09-09T15:30:58.060Z","_id":"clywvvey60009cwv654cs7jql","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在上文中（<a href=\"https://juejin.cn/post/7377320107929829388\">只会 Vue 的我，上班第一天就要我写 React+TS，是种什么样的体验？</a>），我们讲述了 React 从项目创建到如何实现自定义 Hooks ，比较偏基础，今天这篇文章将带大家学习 React Router。</p>\n<h2 id=\"React-Router\"><a href=\"#React-Router\" class=\"headerlink\" title=\"React Router\"></a>React Router</h2><p>如果你对 Vue Router 有了解的话，那么 React Router 肯定也不在话下，因为他们实在太相似了。我们知道前端路由是一个在单页应用中管理不同页面的导航，无需向服务器发送请求重新加载整个页面。即一个<code>path</code>对应一个<code>component</code>。所以 Router 在不管是 Vue 还是 React 亦或是 Angular 都是前端单页应用不可或缺的一部分。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>选择自己喜欢的包管理工具，这里需要注意安装的是 <code>react-router-dom</code>，后面有个 dom，跟 <code>react-dom</code> 一个道理，React Router 库分为多个包，其中<code>react-router-dom</code>是专门用于在浏览器中运行 React 的路由方案，适合 Web 开发。如果是移动端开发应该用<code>react-router-native</code>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm install react-router-dom<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"路由模式\"><a href=\"#路由模式\" class=\"headerlink\" title=\"路由模式\"></a>路由模式</h3><p>我们知道在 Vue 中有两种路由模式 History 跟 Hash 模式，React 同样。下表是我对这两者的简单对比，想必大家背八股的时候就已经熟记于心了。</p>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>url</th>\n<th>原理</th>\n<th>后端支持</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>history</td>\n<td>url&#x2F;login</td>\n<td>history 对象 + pushState 事件</td>\n<td>需要</td>\n</tr>\n<tr>\n<td>hash</td>\n<td>url&#x2F;#&#x2F;login</td>\n<td>hashChange 事件</td>\n<td>不需要</td>\n</tr>\n</tbody></table>\n<h3 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h3><p>主要文件目录如下</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lua\">src/<br>|<span class=\"hljs-comment\">-- pages/</span><br>|   |<span class=\"hljs-comment\">-- Login.jsx</span><br>|   |<span class=\"hljs-comment\">-- About.jsx</span><br>|<span class=\"hljs-comment\">-- router/</span><br>|   |<span class=\"hljs-comment\">-- index.jsx</span><br>|<span class=\"hljs-comment\">-- App.jsx</span><br>|<span class=\"hljs-comment\">-- main.jsx</span><br></code></pre></td></tr></table></figure>\n\n<p>我们一般都在<code>src</code>下新建目录<code>router</code>，然后在<code>index.jsx</code>中创建路由。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// router/index.jsx</span><br><span class=\"hljs-keyword\">import</span> &#123; createBrowserRouter &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Login</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/views/Login&quot;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Home</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/views/Home&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-title function_\">createBrowserRouter</span>([<br>  <span class=\"hljs-comment\">//创建 history 路由</span><br>  &#123;<br>    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/home&quot;</span>,<br>    <span class=\"hljs-attr\">element</span>: <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Home</span> /&gt;</span></span>,<br>  &#125;,<br>  &#123;<br>    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/login&quot;</span>,<br>    <span class=\"hljs-attr\">element</span>: <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Login</span> /&gt;</span></span>,<br>  &#125;,<br>]);<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> router;<br></code></pre></td></tr></table></figure>\n\n<p><code>react-router-dom</code>提供<code>createBrowserRouter</code>API 跟 Vue Router 提供的<code>createWebHistory</code>一样，允许我们创建 History 模式路由，Hash 模式 React 与 Vue 分别对应<code>createHashRouter</code>与<code>createWebHashHistory</code>，如果记混了可以自行查文档。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// app.jsx</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;./App.css&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">RouterProvider</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;<br><span class=\"hljs-keyword\">import</span> router <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./router&quot;</span>;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">App</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">RouterProvider</span> <span class=\"hljs-attr\">router</span>=<span class=\"hljs-string\">&#123;router&#125;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">RouterProvider</span>&gt;</span></span>;<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;<br></code></pre></td></tr></table></figure>\n\n<p>创建好了就该使用了，在 Vue 中是直接在<code>main.js</code>中 App 根组件直接<code>use</code>掉，而在 React 中则有所不同， React Router 专门提供一个组件 <code>RouterProvider</code>，用于将路由配置传递给应用。它接受一个<code>router</code>prop，该 prop 是在刚刚创建的路由实例。</p>\n<h3 id=\"导航跳转\"><a href=\"#导航跳转\" class=\"headerlink\" title=\"导航跳转\"></a>导航跳转</h3><h4 id=\"声明式导航\"><a href=\"#声明式导航\" class=\"headerlink\" title=\"声明式导航\"></a>声明式导航</h4><p>通过在模板中使用<code>&lt;Link /&gt;</code>组件，通过<code>to</code>属性指定要跳转的路径，跟 Vue 的<code>router-link</code>很类似，</p>\n<p>🌰 现在我们要实现从登录页跳转至首页：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Link</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Login</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      Login</span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Link</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">&quot;/home&quot;</span>&gt;</span>跳转至首页<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Link</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Login</span>;<br></code></pre></td></tr></table></figure>\n\n<p>我们先手动去到<code>/login</code>路径。</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6feb8ec6848414e84874849c93a663c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=657&h=364&s=25231&e=gif&f=6&b=fefefe\" alt=\"GIF 2024-6-12 10-42-24.gif\" width=\"50%\" />\n\n<h4 id=\"编程式导航\"><a href=\"#编程式导航\" class=\"headerlink\" title=\"编程式导航\"></a>编程式导航</h4><p>通过<code>useNavigate</code>钩子拿到导航方法，再通过调用命令式进行跳转。类似于 Vue 的<code>router.push()</code></p>\n<p>🌰 一样的场景:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; useNavigate &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Login</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> navigate = <span class=\"hljs-title function_\">useNavigate</span>();<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Login<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> navigate(&quot;/home&quot;)&#125;&gt;跳转<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Login</span>;<br></code></pre></td></tr></table></figure>\n\n<p>通过事件驱动跳转，更加灵活。</p>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f6cfd379e4b4af28cedbeccd34e2914~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=620&h=402&s=15187&e=gif&f=4&b=fefefe\" alt=\"GIF 2024-6-12 10-51-15.gif\" width=\"50%\" />\n\n<h3 id=\"导航传参\"><a href=\"#导航传参\" class=\"headerlink\" title=\"导航传参\"></a>导航传参</h3><p>React 提供了两个钩子允许我们进行导航传参。</p>\n<h4 id=\"useSearchParams-传参\"><a href=\"#useSearchParams-传参\" class=\"headerlink\" title=\"useSearchParams 传参\"></a>useSearchParams 传参</h4><p>这里我们在 Login 页面进行跳转，并用<code>?</code>+<code>参数名</code>&#x3D;<code>参数</code>拼接，多个参数用<code>&amp;</code>拼接。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// login.jsx</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; useNavigate &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Login</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> navigate = <span class=\"hljs-title function_\">useNavigate</span>();<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Login<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> navigate(&quot;/home?id=1&amp;name=yangyang&quot;)&#125;&gt;</span><br><span class=\"language-xml\">        跳转传参</span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Login</span>;<br></code></pre></td></tr></table></figure>\n\n<p><code>useSearchParams</code>运行我们解构出一个对象，这个对象包含了所有通过<code>?</code>后的参数</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// home.jsx</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; useSearchParams &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Home</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> [params] = <span class=\"hljs-title function_\">useSearchParams</span>();<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(params);<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Home<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>id:&#123;params.get(&quot;id&quot;)&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>name:&#123;params.get(&quot;name&quot;)&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Home</span>;<br></code></pre></td></tr></table></figure>\n\n<p>我们打印 params 对象看看</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70e2dac1326f474990f1a4f45d64c293~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=931&h=692&s=98095&e=png&b=ffffff\" alt=\"image.png\" width=\"70%\" />\n\n<p>它是一个<code>URLSearchParams</code> 对象，包含了一系列方法，我们可以使用<code>get</code>方法查询参数</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f193eca1b6147709683f5f511bfeab0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=975&h=431&s=59017&e=gif&f=10&b=fefefe\" alt=\"GIF 2024-6-12 12-16-59.gif\" width=\"50%\" />\n\n<h4 id=\"useParams\"><a href=\"#useParams\" class=\"headerlink\" title=\"useParams\"></a>useParams</h4><p>这里我们还是在 Login 页面进行跳转，我们直接在路径后面继续接<code>/</code>+<code>参数</code>，</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// login.jsx</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; useNavigate &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Login</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> navigate = <span class=\"hljs-title function_\">useNavigate</span>();<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Login<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> navigate(&quot;/home/1/yangyang&quot;)&#125;&gt;跳转传参<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Login</span>;<br></code></pre></td></tr></table></figure>\n\n<p>不仅如此，还需要修改<code>router</code>配置，将补全<code>path</code>用<code>:</code>+<code>参数名</code>，这样才能一一匹配。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\">&#123;<br>    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/home/:id/:name&#x27;</span>,<br>    <span class=\"hljs-attr\">element</span>: <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Home</span> /&gt;</span></span>,<br>&#125;,<br></code></pre></td></tr></table></figure>\n\n<p>最后，在 Home 页面接收参数，调用<code>useParams</code>得到一个对象，对象的每个属性就是我们传递的参数</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// home.jsx</span><br><span class=\"hljs-keyword\">import</span> &#123; useParams &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Home</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> params = <span class=\"hljs-title function_\">useParams</span>();<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(params);<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Home<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>id:&#123;params.id&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>name:&#123;params.name&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Home</span>;<br></code></pre></td></tr></table></figure>\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cf0aba3e4f04eb2a44b825b255ab089~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=930&h=146&s=15495&e=png&b=ffffff\" alt=\"image.png\" width=\"70%\" />\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/122da242b0d642c8a54c722b65722c58~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=819&h=431&s=22894&e=gif&f=3&b=fefefe\" alt=\"GIF 2024-6-12 12-30-26.gif\" width=\"50%\" />\n\n<h3 id=\"嵌套路由\"><a href=\"#嵌套路由\" class=\"headerlink\" title=\"嵌套路由\"></a>嵌套路由</h3><p>跟 Vue 一样，React 同样允许你在一个路由组件的<code>children</code>属性中配置子路由。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// router/index.js</span><br><span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-title function_\">createBrowserRouter</span>([<br>  &#123;<br>    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/home&quot;</span>,<br>    <span class=\"hljs-attr\">element</span>: <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Home</span> /&gt;</span></span>,<br>    <span class=\"hljs-attr\">children</span>: [<br>      &#123;<br>        <span class=\"hljs-attr\">index</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-comment\">//默认二级路由</span><br>        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;board&quot;</span>,<br>        <span class=\"hljs-attr\">element</span>: <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Board</span> /&gt;</span></span>,<br>      &#125;,<br>      &#123;<br>        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;about&quot;</span>,<br>        <span class=\"hljs-attr\">element</span>: <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">About</span> /&gt;</span></span>,<br>      &#125;,<br>    ],<br>  &#125;,<br>  &#123;<br>    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/login&quot;</span>,<br>    <span class=\"hljs-attr\">element</span>: <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Login</span> /&gt;</span></span>,<br>  &#125;,<br>]);<br></code></pre></td></tr></table></figure>\n\n<p>二级路由的<code>path</code>如果不写<code>/</code>，会默认拼接在父级路由后面，配置<code>index:true</code>表示默认显示该路由。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// home.js</span><br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Link</span>, <span class=\"hljs-title class_\">Outlet</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Home</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Home<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Link</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">&quot;board&quot;</span>&gt;</span>面板<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Link</span>&gt;</span>|<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Link</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">&quot;about&quot;</span>&gt;</span>关于<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Link</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Outlet</span> /&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Home</span>;<br></code></pre></td></tr></table></figure>\n\n<p>我们通过<code>Link</code>组件进行跳转，<code>Outlet</code>组件是二级路由的出口，你定义在哪，那么组件就会在哪显示，跟 Vue 的<code>router-view</code>类似。</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dea9a7b1b404ce2883e79efc33d5304~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=719&h=437&s=38430&e=gif&f=16&b=fefefe\" alt=\"GIF 2024-6-12 15-00-00.gif\" width=\"50%\" />\n\n<h3 id=\"懒加载\"><a href=\"#懒加载\" class=\"headerlink\" title=\"懒加载\"></a>懒加载</h3><p>React 提供了<code>React.lazy</code>和<code>Suspense</code>组件来实现懒加载。<code>React.lazy</code>用于定义懒加载的组件，<code>Suspense</code>用于在组件加载时显示。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123; createBrowserRouter &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Suspense</span>, lazy &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Home</span> = <span class=\"hljs-title function_\">lazy</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&quot;@/pages/Home&quot;</span>));<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Login</span> = <span class=\"hljs-title function_\">lazy</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&quot;@/pages/Login&quot;</span>));<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Board</span> = <span class=\"hljs-title function_\">lazy</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&quot;@/pages/Board&quot;</span>));<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">About</span> = <span class=\"hljs-title function_\">lazy</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&quot;@/pages/About&quot;</span>));<br><br><span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-title function_\">createBrowserRouter</span>([<br>  &#123;<br>    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/login&quot;</span>,<br>    <span class=\"hljs-attr\">element</span>: (<br>      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Suspense</span> <span class=\"hljs-attr\">fallback</span>=<span class=\"hljs-string\">&#123;</span>&quot;<span class=\"hljs-attr\">加载中</span>&quot;&#125;&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Login</span> /&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Suspense</span>&gt;</span></span><br>    ),<br>  &#125;,<br>  &#123;<br>    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/home&quot;</span>,<br>    <span class=\"hljs-attr\">element</span>: (<br>      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Suspense</span> <span class=\"hljs-attr\">fallback</span>=<span class=\"hljs-string\">&#123;</span>&quot;<span class=\"hljs-attr\">加载中</span>&quot;&#125;&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Home</span> /&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Suspense</span>&gt;</span></span><br>    ),<br>    <span class=\"hljs-attr\">children</span>: [<br>      &#123;<br>        <span class=\"hljs-attr\">index</span>: <span class=\"hljs-literal\">true</span>,<br>        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;board&quot;</span>,<br>        <span class=\"hljs-attr\">element</span>: (<br>          <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Suspense</span> <span class=\"hljs-attr\">fallback</span>=<span class=\"hljs-string\">&#123;</span>&quot;<span class=\"hljs-attr\">加载中</span>&quot;&#125;&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Board</span> /&gt;</span></span><br><span class=\"language-xml\">          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Suspense</span>&gt;</span></span><br>        ),<br>      &#125;,<br>      &#123;<br>        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;about&quot;</span>,<br>        <span class=\"hljs-attr\">element</span>: (<br>          <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Suspense</span> <span class=\"hljs-attr\">fallback</span>=<span class=\"hljs-string\">&#123;</span>&quot;<span class=\"hljs-attr\">加载中</span>&quot;&#125;&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">About</span> /&gt;</span></span><br><span class=\"language-xml\">          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Suspense</span>&gt;</span></span><br>        ),<br>      &#125;,<br>    ],<br>  &#125;,<br>]);<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> router;<br></code></pre></td></tr></table></figure>\n\n<p>通过套一层<code>lazy</code>就可以实现懒加载，<code>Suspense</code>提供 loading 内容。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>不管是 Vue 还是 React ，前端路由的大致理念都是一样的，我们如果知道一个，很容易融汇贯通。还是那句话，多看文档，多敲代码，多实践！</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://zh-hans.react.dev/learn\">React-中文官网</a></li>\n<li><a href=\"https://reactrouter.com/en/main/start/overview\">React-Router-官网</a></li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>已将学习代码上传至 <a href=\"https://github.com/YangyangU/CodeSpace\">github</a>，欢迎大家学习指正！</p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在上文中（<a href=\"https://juejin.cn/post/7377320107929829388\">只会 Vue 的我，上班第一天就要我写 React+TS，是种什么样的体验？</a>），我们讲述了 React 从项目创建到如何实现自定义 Hooks ，比较偏基础，今天这篇文章将带大家学习 React Router。</p>\n<h2 id=\"React-Router\"><a href=\"#React-Router\" class=\"headerlink\" title=\"React Router\"></a>React Router</h2><p>如果你对 Vue Router 有了解的话，那么 React Router 肯定也不在话下，因为他们实在太相似了。我们知道前端路由是一个在单页应用中管理不同页面的导航，无需向服务器发送请求重新加载整个页面。即一个<code>path</code>对应一个<code>component</code>。所以 Router 在不管是 Vue 还是 React 亦或是 Angular 都是前端单页应用不可或缺的一部分。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>选择自己喜欢的包管理工具，这里需要注意安装的是 <code>react-router-dom</code>，后面有个 dom，跟 <code>react-dom</code> 一个道理，React Router 库分为多个包，其中<code>react-router-dom</code>是专门用于在浏览器中运行 React 的路由方案，适合 Web 开发。如果是移动端开发应该用<code>react-router-native</code>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm install react-router-dom<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"路由模式\"><a href=\"#路由模式\" class=\"headerlink\" title=\"路由模式\"></a>路由模式</h3><p>我们知道在 Vue 中有两种路由模式 History 跟 Hash 模式，React 同样。下表是我对这两者的简单对比，想必大家背八股的时候就已经熟记于心了。</p>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>url</th>\n<th>原理</th>\n<th>后端支持</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>history</td>\n<td>url&#x2F;login</td>\n<td>history 对象 + pushState 事件</td>\n<td>需要</td>\n</tr>\n<tr>\n<td>hash</td>\n<td>url&#x2F;#&#x2F;login</td>\n<td>hashChange 事件</td>\n<td>不需要</td>\n</tr>\n</tbody></table>\n<h3 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h3><p>主要文件目录如下</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lua\">src/<br>|<span class=\"hljs-comment\">-- pages/</span><br>|   |<span class=\"hljs-comment\">-- Login.jsx</span><br>|   |<span class=\"hljs-comment\">-- About.jsx</span><br>|<span class=\"hljs-comment\">-- router/</span><br>|   |<span class=\"hljs-comment\">-- index.jsx</span><br>|<span class=\"hljs-comment\">-- App.jsx</span><br>|<span class=\"hljs-comment\">-- main.jsx</span><br></code></pre></td></tr></table></figure>\n\n<p>我们一般都在<code>src</code>下新建目录<code>router</code>，然后在<code>index.jsx</code>中创建路由。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// router/index.jsx</span><br><span class=\"hljs-keyword\">import</span> &#123; createBrowserRouter &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Login</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/views/Login&quot;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Home</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@/views/Home&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-title function_\">createBrowserRouter</span>([<br>  <span class=\"hljs-comment\">//创建 history 路由</span><br>  &#123;<br>    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/home&quot;</span>,<br>    <span class=\"hljs-attr\">element</span>: <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Home</span> /&gt;</span></span>,<br>  &#125;,<br>  &#123;<br>    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/login&quot;</span>,<br>    <span class=\"hljs-attr\">element</span>: <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Login</span> /&gt;</span></span>,<br>  &#125;,<br>]);<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> router;<br></code></pre></td></tr></table></figure>\n\n<p><code>react-router-dom</code>提供<code>createBrowserRouter</code>API 跟 Vue Router 提供的<code>createWebHistory</code>一样，允许我们创建 History 模式路由，Hash 模式 React 与 Vue 分别对应<code>createHashRouter</code>与<code>createWebHashHistory</code>，如果记混了可以自行查文档。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// app.jsx</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;./App.css&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">RouterProvider</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;<br><span class=\"hljs-keyword\">import</span> router <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./router&quot;</span>;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">App</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">RouterProvider</span> <span class=\"hljs-attr\">router</span>=<span class=\"hljs-string\">&#123;router&#125;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">RouterProvider</span>&gt;</span></span>;<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;<br></code></pre></td></tr></table></figure>\n\n<p>创建好了就该使用了，在 Vue 中是直接在<code>main.js</code>中 App 根组件直接<code>use</code>掉，而在 React 中则有所不同， React Router 专门提供一个组件 <code>RouterProvider</code>，用于将路由配置传递给应用。它接受一个<code>router</code>prop，该 prop 是在刚刚创建的路由实例。</p>\n<h3 id=\"导航跳转\"><a href=\"#导航跳转\" class=\"headerlink\" title=\"导航跳转\"></a>导航跳转</h3><h4 id=\"声明式导航\"><a href=\"#声明式导航\" class=\"headerlink\" title=\"声明式导航\"></a>声明式导航</h4><p>通过在模板中使用<code>&lt;Link /&gt;</code>组件，通过<code>to</code>属性指定要跳转的路径，跟 Vue 的<code>router-link</code>很类似，</p>\n<p>🌰 现在我们要实现从登录页跳转至首页：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Link</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Login</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      Login</span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Link</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">&quot;/home&quot;</span>&gt;</span>跳转至首页<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Link</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Login</span>;<br></code></pre></td></tr></table></figure>\n\n<p>我们先手动去到<code>/login</code>路径。</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6feb8ec6848414e84874849c93a663c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=657&h=364&s=25231&e=gif&f=6&b=fefefe\" alt=\"GIF 2024-6-12 10-42-24.gif\" width=\"50%\" />\n\n<h4 id=\"编程式导航\"><a href=\"#编程式导航\" class=\"headerlink\" title=\"编程式导航\"></a>编程式导航</h4><p>通过<code>useNavigate</code>钩子拿到导航方法，再通过调用命令式进行跳转。类似于 Vue 的<code>router.push()</code></p>\n<p>🌰 一样的场景:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; useNavigate &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Login</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> navigate = <span class=\"hljs-title function_\">useNavigate</span>();<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Login<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> navigate(&quot;/home&quot;)&#125;&gt;跳转<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Login</span>;<br></code></pre></td></tr></table></figure>\n\n<p>通过事件驱动跳转，更加灵活。</p>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f6cfd379e4b4af28cedbeccd34e2914~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=620&h=402&s=15187&e=gif&f=4&b=fefefe\" alt=\"GIF 2024-6-12 10-51-15.gif\" width=\"50%\" />\n\n<h3 id=\"导航传参\"><a href=\"#导航传参\" class=\"headerlink\" title=\"导航传参\"></a>导航传参</h3><p>React 提供了两个钩子允许我们进行导航传参。</p>\n<h4 id=\"useSearchParams-传参\"><a href=\"#useSearchParams-传参\" class=\"headerlink\" title=\"useSearchParams 传参\"></a>useSearchParams 传参</h4><p>这里我们在 Login 页面进行跳转，并用<code>?</code>+<code>参数名</code>&#x3D;<code>参数</code>拼接，多个参数用<code>&amp;</code>拼接。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// login.jsx</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; useNavigate &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Login</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> navigate = <span class=\"hljs-title function_\">useNavigate</span>();<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Login<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> navigate(&quot;/home?id=1&amp;name=yangyang&quot;)&#125;&gt;</span><br><span class=\"language-xml\">        跳转传参</span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Login</span>;<br></code></pre></td></tr></table></figure>\n\n<p><code>useSearchParams</code>运行我们解构出一个对象，这个对象包含了所有通过<code>?</code>后的参数</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// home.jsx</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; useSearchParams &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Home</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> [params] = <span class=\"hljs-title function_\">useSearchParams</span>();<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(params);<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Home<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>id:&#123;params.get(&quot;id&quot;)&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>name:&#123;params.get(&quot;name&quot;)&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Home</span>;<br></code></pre></td></tr></table></figure>\n\n<p>我们打印 params 对象看看</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70e2dac1326f474990f1a4f45d64c293~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=931&h=692&s=98095&e=png&b=ffffff\" alt=\"image.png\" width=\"70%\" />\n\n<p>它是一个<code>URLSearchParams</code> 对象，包含了一系列方法，我们可以使用<code>get</code>方法查询参数</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f193eca1b6147709683f5f511bfeab0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=975&h=431&s=59017&e=gif&f=10&b=fefefe\" alt=\"GIF 2024-6-12 12-16-59.gif\" width=\"50%\" />\n\n<h4 id=\"useParams\"><a href=\"#useParams\" class=\"headerlink\" title=\"useParams\"></a>useParams</h4><p>这里我们还是在 Login 页面进行跳转，我们直接在路径后面继续接<code>/</code>+<code>参数</code>，</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// login.jsx</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; useNavigate &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Login</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> navigate = <span class=\"hljs-title function_\">useNavigate</span>();<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Login<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> navigate(&quot;/home/1/yangyang&quot;)&#125;&gt;跳转传参<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Login</span>;<br></code></pre></td></tr></table></figure>\n\n<p>不仅如此，还需要修改<code>router</code>配置，将补全<code>path</code>用<code>:</code>+<code>参数名</code>，这样才能一一匹配。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\">&#123;<br>    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/home/:id/:name&#x27;</span>,<br>    <span class=\"hljs-attr\">element</span>: <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Home</span> /&gt;</span></span>,<br>&#125;,<br></code></pre></td></tr></table></figure>\n\n<p>最后，在 Home 页面接收参数，调用<code>useParams</code>得到一个对象，对象的每个属性就是我们传递的参数</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// home.jsx</span><br><span class=\"hljs-keyword\">import</span> &#123; useParams &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Home</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> params = <span class=\"hljs-title function_\">useParams</span>();<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(params);<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Home<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>id:&#123;params.id&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>name:&#123;params.name&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Home</span>;<br></code></pre></td></tr></table></figure>\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cf0aba3e4f04eb2a44b825b255ab089~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=930&h=146&s=15495&e=png&b=ffffff\" alt=\"image.png\" width=\"70%\" />\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/122da242b0d642c8a54c722b65722c58~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=819&h=431&s=22894&e=gif&f=3&b=fefefe\" alt=\"GIF 2024-6-12 12-30-26.gif\" width=\"50%\" />\n\n<h3 id=\"嵌套路由\"><a href=\"#嵌套路由\" class=\"headerlink\" title=\"嵌套路由\"></a>嵌套路由</h3><p>跟 Vue 一样，React 同样允许你在一个路由组件的<code>children</code>属性中配置子路由。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// router/index.js</span><br><span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-title function_\">createBrowserRouter</span>([<br>  &#123;<br>    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/home&quot;</span>,<br>    <span class=\"hljs-attr\">element</span>: <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Home</span> /&gt;</span></span>,<br>    <span class=\"hljs-attr\">children</span>: [<br>      &#123;<br>        <span class=\"hljs-attr\">index</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-comment\">//默认二级路由</span><br>        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;board&quot;</span>,<br>        <span class=\"hljs-attr\">element</span>: <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Board</span> /&gt;</span></span>,<br>      &#125;,<br>      &#123;<br>        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;about&quot;</span>,<br>        <span class=\"hljs-attr\">element</span>: <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">About</span> /&gt;</span></span>,<br>      &#125;,<br>    ],<br>  &#125;,<br>  &#123;<br>    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/login&quot;</span>,<br>    <span class=\"hljs-attr\">element</span>: <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Login</span> /&gt;</span></span>,<br>  &#125;,<br>]);<br></code></pre></td></tr></table></figure>\n\n<p>二级路由的<code>path</code>如果不写<code>/</code>，会默认拼接在父级路由后面，配置<code>index:true</code>表示默认显示该路由。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// home.js</span><br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Link</span>, <span class=\"hljs-title class_\">Outlet</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Home</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Home<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Link</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">&quot;board&quot;</span>&gt;</span>面板<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Link</span>&gt;</span>|<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Link</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">&quot;about&quot;</span>&gt;</span>关于<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Link</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Outlet</span> /&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Home</span>;<br></code></pre></td></tr></table></figure>\n\n<p>我们通过<code>Link</code>组件进行跳转，<code>Outlet</code>组件是二级路由的出口，你定义在哪，那么组件就会在哪显示，跟 Vue 的<code>router-view</code>类似。</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dea9a7b1b404ce2883e79efc33d5304~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=719&h=437&s=38430&e=gif&f=16&b=fefefe\" alt=\"GIF 2024-6-12 15-00-00.gif\" width=\"50%\" />\n\n<h3 id=\"懒加载\"><a href=\"#懒加载\" class=\"headerlink\" title=\"懒加载\"></a>懒加载</h3><p>React 提供了<code>React.lazy</code>和<code>Suspense</code>组件来实现懒加载。<code>React.lazy</code>用于定义懒加载的组件，<code>Suspense</code>用于在组件加载时显示。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123; createBrowserRouter &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Suspense</span>, lazy &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Home</span> = <span class=\"hljs-title function_\">lazy</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&quot;@/pages/Home&quot;</span>));<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Login</span> = <span class=\"hljs-title function_\">lazy</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&quot;@/pages/Login&quot;</span>));<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Board</span> = <span class=\"hljs-title function_\">lazy</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&quot;@/pages/Board&quot;</span>));<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">About</span> = <span class=\"hljs-title function_\">lazy</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&quot;@/pages/About&quot;</span>));<br><br><span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-title function_\">createBrowserRouter</span>([<br>  &#123;<br>    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/login&quot;</span>,<br>    <span class=\"hljs-attr\">element</span>: (<br>      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Suspense</span> <span class=\"hljs-attr\">fallback</span>=<span class=\"hljs-string\">&#123;</span>&quot;<span class=\"hljs-attr\">加载中</span>&quot;&#125;&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Login</span> /&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Suspense</span>&gt;</span></span><br>    ),<br>  &#125;,<br>  &#123;<br>    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/home&quot;</span>,<br>    <span class=\"hljs-attr\">element</span>: (<br>      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Suspense</span> <span class=\"hljs-attr\">fallback</span>=<span class=\"hljs-string\">&#123;</span>&quot;<span class=\"hljs-attr\">加载中</span>&quot;&#125;&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Home</span> /&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Suspense</span>&gt;</span></span><br>    ),<br>    <span class=\"hljs-attr\">children</span>: [<br>      &#123;<br>        <span class=\"hljs-attr\">index</span>: <span class=\"hljs-literal\">true</span>,<br>        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;board&quot;</span>,<br>        <span class=\"hljs-attr\">element</span>: (<br>          <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Suspense</span> <span class=\"hljs-attr\">fallback</span>=<span class=\"hljs-string\">&#123;</span>&quot;<span class=\"hljs-attr\">加载中</span>&quot;&#125;&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Board</span> /&gt;</span></span><br><span class=\"language-xml\">          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Suspense</span>&gt;</span></span><br>        ),<br>      &#125;,<br>      &#123;<br>        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;about&quot;</span>,<br>        <span class=\"hljs-attr\">element</span>: (<br>          <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Suspense</span> <span class=\"hljs-attr\">fallback</span>=<span class=\"hljs-string\">&#123;</span>&quot;<span class=\"hljs-attr\">加载中</span>&quot;&#125;&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">About</span> /&gt;</span></span><br><span class=\"language-xml\">          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Suspense</span>&gt;</span></span><br>        ),<br>      &#125;,<br>    ],<br>  &#125;,<br>]);<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> router;<br></code></pre></td></tr></table></figure>\n\n<p>通过套一层<code>lazy</code>就可以实现懒加载，<code>Suspense</code>提供 loading 内容。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>不管是 Vue 还是 React ，前端路由的大致理念都是一样的，我们如果知道一个，很容易融汇贯通。还是那句话，多看文档，多敲代码，多实践！</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://zh-hans.react.dev/learn\">React-中文官网</a></li>\n<li><a href=\"https://reactrouter.com/en/main/start/overview\">React-Router-官网</a></li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>已将学习代码上传至 <a href=\"https://github.com/YangyangU/CodeSpace\">github</a>，欢迎大家学习指正！</p>\n"},{"title":"只会Vue的我，上班第一天就要我写React+TS，是种什么样的体验？","date":"2024-06-07T08:00:00.000Z","index_img":"/img/react.png","banner_img":"/img/default.png","_content":"\n## 前言\n\n**只会 Vue 的我，上班第一天就要我写 React+TS，是种什么样的体验？**\n\n入职第一天，坐公交来到指定报道处，拿号排队准备办理入职，拿装备去工位，认识 Leader 跟 Mentor，自己看文档装环境，屁股都没坐热，mentor 就问我技术栈是什么，我说 Vue，他又问 React 用过吗？我开始有不祥的预感，他反手就甩了个链接，叫我装完环境看一下，装完 vscode、node、git，我直接 pull 下来，看了一下目录 pnpm 咱也没用过啊，怎么全是 ts ，用的 Vite？这个我熟，直接安装依赖 run dev！\n\n首先，这个项目就两个页面，我第一感觉是：怎么看着还不如我自己的项目好看 😢，但是当我打开代码，脑子直接缺氧，啥都看不懂。什么 type 什么 useMemo，闻所未闻。\n\n赶紧开始自学 React + TS ……\n\n晚上回到出租屋，突然有一种压力油然而生，我是不是太蠢了，Mentor 会不会看不起我 ……\n\n看了一天视频，文章，我觉得我已经了解了 React ，至少不会看不懂了。\n\n这篇文章就来总结一下我是如何快速上手的，分享一下我心得体会。如果你也跟我一样，下面我分享一些我的经验，希望能够对您有所帮助。\n\n## 项目创建\n\n在 Vue 中，我们常用的脚手架是 Vue-CLI 以及尤大大推荐的 Vite ；在 React 中，我们通常使用 creat-react-app（CRA）创建项目，当然 Vite 同样也支持我们创建 React 项目。\n\n### 使用 CRA\n\n```bash\nnpx create-react-app my-react-app\n```\n\n### 使用 Vite\n\n```bash\nyarn create vite my-react-app --template react\n```\n\n### 其他创建方式\n\n参考 [React | 启动一个新项目](https://zh-hans.react.dev/learn/start-a-new-react-project)\n\n### 注意\n\n值得注意的是使用 cra 创建的项目中，JS 文件就是正常的`.js`后缀，而 Vite 创建项目的文件后缀是`.jsx`。\n\n- Vite 基于 ESModule，它提供了对 JSX 的原生支持，使用`.jsx`作为源文件的后缀，以便我们直接编写 JSX 语法的 React 组件。\n- CRA 默认没有启用 JSX 预处理器，而是通过 Babel 和 Webpack 等工具来处理 JSX 语法。\n\n在写法上没有区别，不用考虑太多。\n\n## 项目目录\n\n以下是 Vite 创建的项目目录结构：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af365556f65d4b75ba8b3656d79b105f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=195&h=338&s=14100&e=png&b=252526)\n\n其中入口文件是`main.jsx`，如果是 CRA 创建的项目则是`index.js`。\n\n让我来看看它的代码：\n\n```jsx\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport App from \"./App.jsx\";\nimport \"./index.css\";\n\nReactDOM.createRoot(document.getElementById(\"root\")).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n```\n\n这跟 Vue 的`main.js`的作用一样，将`App`根组件挂载到`id`为`root`的 DOM 元素上。\n\n**我猜你可能会想，这里引入一个 React 又引入一个 ReactDom 干嘛，它们两个有什么区别？**\n\n我们在`package.json`中也可以看到这两个依赖。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0df638d47a88442e8f77dabd6a41a1c0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=292&h=115&s=5549&e=png&b=1e1e1e)\n\n这是因为 React 作者将 React 源码拆成了两部分：\n\n- `React` 库提供构建用户界面的各种 API 和组件，比如创建 React 组件、处理组件生命周期、状态管理、事件处理等核心功能。\n\n- `ReactDom` 库是 React 的 DOM 渲染器，只负责将 React 组件渲染到浏览器的 DOM 中，提供一些管理组件的更新、挂载和卸载等操作的 API。\n\n## JSX\n\n我们`return`出来的 JSX 模板，如果要换行的话，需要用`()`包裹一下，然后这个 JSX 表达式必须具有一个父元素，什么意思呢？就是下面这种写法会报错，JSX 表达式规定了最外层只能有一个父元素，这种情况下我们一般会在最外面套一个`div`或者空标签`<></>`。\n\n```jsx\nreturn (\n  {/*报错*/}\n  <div>\n    <h1>hello</h1>\n  </div>\n  <div>\n    <h1>你好</h1>\n  </div>\n)\n\nreturn (\n  <>\n   <div>\n    <h1>hello</h1>\n   </div>\n   <div>\n    <h1>你好</h1>\n   </div>\n  </>\n)\n```\n\n在 JSX 表达式允许我们只能在`{}`中写 JS 代码\n\n## 创建组件\n\n在 React 中有两种创建组件的方式，函数组件和类组件，类组件是。现在界内大部分都使用函数组件，函数组件相比于类组件，性能更好，React 18 虽然还支持类组件，但是更推荐使用函数组件。\n\n### 函数组件\n\n#### 语法\n\n函数组件是通过函数来定义的，函数的返回值是 JSX 模板，可以使用 `function` 关键字或箭头函数定义。\n\n```jsx\nconst App = () => {\n  return (\n    <div>\n      <h1>Hello Function Component</h1>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d21eaa75fc34fcaac6638fb39e28de6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=454&h=157&s=8769&e=png&b=ffffff)\n\n#### 状态管理\n\n函数组件通过 React 提供的 Hooks 函数（官方提供的一般以`use`开头的 API），比如我们通常使用`useState` 钩子来管理状态。\n\n`useState` 返回一个由两个值组成的数组：\n\n1.  当前的`state`，初始值为传递给`useState`的参数。\n2.  `set`  函数，它可以让你将`state`更新为不同的值并触发重新渲染。\n\n🙋‍ 举个例子 🌰，这里我们实现一个计数器，点击`count`自增`1`：\n\n```jsx\nimport { useState } from \"react\";\n\nconst App = () => {\n  let [count, setCount] = useState(0);\n  const handleClick = () => {\n    setCount(count + 1);\n  };\n  return (\n    <div>\n      <h1 onClick={handleClick}>{count}</h1>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n这里我们解构得到`count`跟它的`set`方法，我们每次点击触发`handleClick`函数，函数内部通过`set`方法修改状态并重新渲染。\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91d93bd5149b47a095840c25ac501823~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=538&h=272&s=25427&e=gif&f=27&b=fefefe\" alt=\"GIF 2024-6-6 17-23-01.gif\" width=\"50%\" />\n\n#### 生命周期\n\nReact 16.8 之前，函数组件没有生命周期方法，但是从 React 16.8 开始，可以使用`useEffect` 这个 Hook 函数来执行类似生命周期的逻辑，用于替代 `componentDidMount`、`componentDidUpdate` 和 `componentWillUnmount`这些方法。\n\n##### useEffect\n\n`useEffect`是 React 中用于执行副作用操作的 Hook，并且具有类似于生命周期方法的功能。\n\n`useEffect` 接受两个参数：副作用函数和依赖数组。\n\n1.  **副作用函数**：第一个参数是一个函数，用于执行副作用操作。\n1.  **依赖数组**：第二个参数是一个数组，包含了副作用函数中所依赖的变量。如果省略这个参数，那么副作用函数会在每次组件重新渲染时都执行，可以充当`componentDidUpdate`这个生命周期；如果传入空数组 `[]`，则副作用函数只会在组件挂载时执行，相当于 `componentDidMount`；如果依赖数组中包含了某些变量，则只有这些变量发生变化时，副作用函数才会重新执行。如果我们在其中`return`一个函数，这个函数将会在组件卸载时除非，相当于`componentWillUnmount`。\n\n我总结了一下副作用函数执行时机与依赖项的关系如下：\n\n| 依赖项         | 副作用函数执行时机                  |\n| -------------- | ----------------------------------- |\n| 没有依赖项     | 组件初始渲染 + 组件更新时执行       |\n| 空数组依赖项   | 只在初次渲染时执行一次              |\n| 添加特定依赖项 | 组件初始渲染 + 特定依赖项变化时执行 |\n\n举例说明 🌰：\n\n```jsx\n//没有依赖项数组\nimport React, { useState, useEffect } from \"react\";\n\nconst App = () => {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    console.log(\"组件更新\");\n  });\n\n  return (\n    <div>\n      <p>点击了 {count} 次</p>\n      <button onClick={() => setCount(count + 1)}>点击</button>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n这里我们没有依赖项数组，刷新页面，组件初次渲染打印（打印两次是因为 React 源码自己执行了一次，应该是跟严格模式有关，这里我们不用深究），每次点击都会打印，可以充当`componentDidUpdate`生命周期。\n\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ed443e30b2e45629bbe20cf6064e775~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=696&h=468&s=52307&e=gif&f=21&b=fefefe\" alt=\"GIF 2024-6-6 19-32-33.gif\" width=\"50%\" />\n\n---\n\n依赖项为空数组呢？\n\n```jsx\n//依赖项为空数组呢？\nimport React, { useState, useEffect } from \"react\";\n\nconst App = () => {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    console.log(\"组件挂载\");\n  }, []);\n\n  return (\n    <div>\n      <p>点击了 {count} 次</p>\n      <button onClick={() => setCount(count + 1)}>点击</button>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n这里我们的依赖项数组为空，刷新页面，只在初次渲染时打印，点击不打印，可以充当`componentDidMount`生命周期。\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/746f9e4ce2254e8cbe223791767e28c3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=696&h=468&s=68204&e=gif&f=28&b=fefefe\" alt=\"GIF 2024-6-6 19-33-14.gif\" width=\"50%\" />\n\n---\n\n依赖项数组不为空呢？\n\n很容易联想到，如果数组里面有会发生改变的项，则会触发副作用函数，否则不会触发，这里就不演示了。\n\n---\n\n来看最后一个，在副作用函数中`return`一个函数：\n\n```jsx\nimport React, { useState, useEffect } from \"react\";\n\nconst App = () => {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log(\"组件更新\");\n    return () => {\n      console.log(\"组件卸载\");\n    };\n  }, [count]);\n\n  return (\n    <div>\n      <p>点击了 {count} 次</p>\n      <button onClick={() => setCount(count + 1)}>点击</button>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n这里我们`return`一个函数打印卸载，表示组件卸载时会执行的操作。我们通常在这里进行组件卸载时的执行的操作，可以充当`componentWillUnmount`生命周期。\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84e36073cdfe4f27b271fd53ded4a814~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=800&h=567&s=51838&e=gif&f=22&b=fefefe\" alt=\"GIF 2024-6-6 19-51-19.gif\" width=\"50%\" />\n\n一个很常见的例子 🌰：\n\n我们通常在组件卸载时清除一些副作用函数，如定时器\n\n```jsx\nimport React, { useState, useEffect } from \"react\";\n\nconst App = () => {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    let timer = setInterval(() => {\n      setCount(count + 1);\n    }, 1000);\n    return () => {\n      clearInterval(timer);\n    };\n  }, [count]);\n\n  return (\n    <div>\n      <p>点击了 {count} 次</p>\n      <button onClick={() => setCount(count + 1)}>点击</button>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n如果我们不及时清除定时器，会导致资源浪费。\n\n而且由于 `setCount` 是一个异步操作，它不会立即更新 `count` 的值，而是在下一次渲染时才会生效。因此，即使你设置了定时器每隔一秒钟执行一次，但 `count` 的值并不会每秒增加一次。相反，当定时器触发时，`count` 的值仍然是上一次渲染时的值。等一段时间后就会看到下面这个情况：\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29923fc094d648879b1013c2c93e0f02~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=572&h=324&s=27666&e=gif&f=18&b=fefefe\" alt=\"GIF 2024-6-6 20-06-38.gif\" width=\"50%\" />\n\n### 类组件\n\n😁**可以不用但不能不学！**\n\n#### 语法\n\n类组件通过继承 `React.Component` 或其子类来创建，类组件中有一个 `render()` 方法，用来返回 JSX 语法。\n\n拿代码说事：\n\n```jsx\nimport { Component } from \"react\";\n\nclass App extends Component {\n  constructor() {\n    super();\n  }\n  render() {\n    return (\n      <div>\n        <h1>Hello Class Component</h1>\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n类组件的语法就是声明一个类，这个类继承`React.Component` 或者子类，`render()`方法返回 JSX 模板。然后将我们的 App 组件挂载到页面上就可以了。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04452e5cd75c48dc9e2c1f9cd6f7d1a2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=458&h=167&s=9583&e=png&b=ffffff)\n\n#### 状态管理\n\n类组件拥有内部状态`state`，通过 `this.state` 来访问组件的状态，使用 `setState()`方法来更新状态，触发组件的重新渲染。\n\n```jsx\nimport { Component } from \"react\";\n\nclass App extends Component{\n  constructor(){\n    super();\n    this.state={\n      name:\"张三\"\n    }\n  }\n  handleClick(){\n\n  }\n  render(){\n    return(\n      <div>\n        <h1 onClick={()=>this.setState({name:\"李四\"})>{this.state.name}</h1>\n      </div>\n    )\n  }\n}\n\nexport default App;\n```\n\n我们绑定`onClick`事件，当点击时修改`name`的状态。\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f05edfaefa984490ba816a83af73136d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=467&h=332&s=17537&e=gif&f=5&b=fefefe\" alt=\"GIF 2024-6-6 17-04-25.gif\" width=\"30%\" />\n\n#### 生命周期\n\n类组件中可以使用生命周期方法，常见的有`componentDidMount`、`componentDidUpdate`、=跟`componentWillUnmount`，它们分别对应 Vue3 中的 `onMounted`、`onUpdated` 跟 `onBeforeUnmount`。\n\n这个网站可以很清楚看到 React 的生命周期，[React 生命周期](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)，这里就不过多赘述。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c876571316c4779bf0528aca4cef60a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1180&h=424&s=40943&e=png&b=fbf8f7)\n\n### 组件通讯\n\n在 Vue 中组件传值一般通过`props & emit`、`provide & inject`以及 Vue2 中的`EventBus`，或者我们可以直接使用状态管理工具`Vuex`或`Pinia`，React 其实大差不差，同样也有自己的状态管理工具。\n\n#### 父传子\n\n父组件通过`props`传递任意的数字、字符串、布尔值、数组、对象、函数甚至是 JSX，子组件通过`props`参数接收。\n\n🙋‍♀️🌰：\n\n```jsx\nconst Son = (props) => {\n  return (\n    <>\n      <p>{props.name}</p>\n      <p>{props.age}</p>\n      <p>{props.cb()}</p>\n      <p>{props.child}</p>\n    </>\n  );\n};\n\nconst Father = () => {\n  return (\n    <Son\n      name={\"阳阳羊\"}\n      age={20}\n      cb={function cb() {\n        console.log(123);\n      }}\n      child={<span>i am jsx</span>}\n    ></Son>\n  );\n};\n```\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f7493c702384844b509095a3f5f3972~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=789&h=415&s=27428&e=png&b=fefefe\" alt=\"image.png\" width=\"50%\" />\n\n⚠️ 需要注意的是：子组件只能读取`props`中的数据，不能直接进行修改，父组件的数据只能由父组件修改，或者通过父组件传过来的函数进行修改。如果在子标签中嵌套元素，可以在子组件的`props.children`中获取。\n\n#### 子传父\n\n子传父通过最原始的回调函数方式，父组件给子组件传一个函数，子组件调用这个函数然后传入实参，在函数内部用`set`方法修改父组件的状态。\n\n🙋‍♀️🌰：\n\n```jsx\nconst Son = (props) => {\n  return <button onClick={() => props.cb(\"小羊\")}>点击传递</button>;\n};\n\nconst Father = () => {\n  let [name, setName] = useState(\"阳阳羊\");\n  let cb = (name) => {\n    setName(name);\n  };\n  return (\n    <>\n      <Son cb={cb}></Son>\n      {name}\n    </>\n  );\n};\n```\n\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44f24ffe31fa4c8b84aada591cf2e534~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=549&h=284&s=14214&e=gif&f=3&b=fdfdfd\" alt=\"GIF 2024-6-7 11-20-34.gif\" width=\"50%\" />\n\n⚠️ 这里需要注意：`onClick`事件处理程序是一个函数，写成`onClick={() => props.cb('小羊')}`时，实际上创建了一个匿名函数，当点击按钮时会调用这个函数，然后调用`props.cb('小羊')`，如果直接写成`onClick={props.cb('小羊')}`，在渲染时就会立即调用`props.cb('小羊')`，而不是在点击时调用。\n\n#### 兄弟组件通信\n\n兄弟组件通信贯用手段就是**状态提升**，说白话就是将数据都交给父组件，然后父组件作为中间商派发给大家。\n\n🙋‍♀️🌰：\n\n```jsx\nconst Son1 = (props) => {\n  return (\n    <>\n      子组件1-\n      <button onClick={() => props.cb(\"小羊\")}>传给子组件2</button>\n    </>\n  );\n};\n\nconst Son2 = (props) => {\n  return (\n    <>\n      <p>子组件2-{props.name}</p>\n    </>\n  );\n};\n\nconst Father = () => {\n  let [name, setName] = useState(\"Son2\");\n  const cb = (newName) => {\n    setName(newName);\n  };\n  return (\n    <>\n      <Son1 cb={cb}></Son1>\n      <Son2 name={name}></Son2>\n    </>\n  );\n};\n```\n\n这里子`组件1`通过触发父组件传递过来的函数，并传递参数，然后父组件接收到参数修改数据源，传递给`组件2`。这样就完成了兄弟组件通信。\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eb12209347142b59eea4b418c9507dc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=547&h=273&s=24884&e=gif&f=6&b=fdfcfc\" alt=\"GIF 2024-6-7 11-16-47.gif\" width=\"50%\" />\n\n#### 夸层组件通讯\n\n思路是将两个组件放在同一个上下文中就能实现数据共享。步骤如下：\n\n1. 使用`createContext`方法创建一个上下文对象，将组件`Provider`，`Consumer`抛出\n\n```js\nimport React from \"react\";\nconst { Provider, Consumer } = React.createContext();\n\nexport { Provider, Consumer };\n```\n\n2. 在顶层组件(App)中通过`Provider`组件提供数据\n\n3. 在底层组件(B)中通过`Consumer`组件获取对应数据\n\n```jsx\nimport { Provider, Consumer } from \"./provider\";\n\nconst ComponentB = () => {\n  return (\n    <Consumer>\n      {(value) => (\n        <div>\n          <h1>底层组件——{value}</h1>\n        </div>\n      )}\n    </Consumer>\n  );\n};\n\nconst App = () => {\n  const value = \"顶层组件的数据\";\n  return (\n    <Provider value={value}>\n      <h1>顶层组件</h1>\n      <ComponentB />\n    </Provider>\n  );\n};\n```\n\n效果如下：\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c488273f449470fbfbdccb8e36b31d3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=813&h=369&s=31043&e=png&b=fefefe\" alt=\"image.png\" width=\"50%\" />\n\n#### 状态管理工具\n\n常见的 React 状态管理工具有 Redux、Mobx、Rcoil 等等，如果有感兴趣的同学，我可以单独出一篇文章详细聊聊。本篇就不展开聊了。\n\n## 自定义 Hooks\n\n除了 React 官方提供的一些 Hooks 之外，还允许我们自定义自己的 Hooks，我们需要遵循以下规则：\n\n1. 声明以`use`开头的函数\n2. 在函数体内封装可复用的逻辑\n3. 把组件中使用到的状态`return`出去\n4. 在哪里用到就在里面执行解构\n\n🙋‍♀️🌰：\n\n我们设计来设计一个开关 Hooks，作用是对值取反，从而控制元素的显示隐藏：\n\n```jsx\nimport { useState } from \"react\";\n\nfunction useToggle() {\n  const [value, setValue] = useState(true);\n  const toggle = () => {\n    setValue(!value);\n  };\n  return [value, toggle];\n}\n\nconst App = () => {\n  const [value, toggle] = useToggle();\n  return (\n    <div>\n      <h1>{value ? \"开\" : \"关\"}</h1>\n      <button onClick={toggle}>按钮</button>\n    </div>\n  );\n};\nexport default App;\n```\n\n这里我们借助`useState`进行封装，将需要用到的变量进行抛出，在需要使用的地方解构拿到，通过三目运算符进行显示隐藏。\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c183f8bc55224444b6bb384239bd4c08~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=613&h=369&s=29609&e=gif&f=12&b=fefefe\" alt=\"GIF 2024-6-7 12-07-46.gif\" width=\"50%\" />\n\n### Hooks 使用规则\n\nHooks 并不是然后场景下都能用，像比如在类组件中是不能直接使用 Hooks 的，除非使用高阶函数进行包装，以及其他许多规则：\n\n- 不能在组件外部使用\n- 不能在判断语句中使用\n\n详见 [React 中文官网](https://zh-hans.react.dev/reference/rules/rules-of-hooks)\n\n## 总结\n\n还是那句话，不管是 Vue 跟 React 都有自己的优缺点，我们不能断言说哪个好哪个差，在我看来 Vue 更适合第一次接触前端框架的小白，它封装了许多 API，对新手很友好，上手即用；而 React 相对复杂，更考验开发者的思维，对于一些复杂需求能够自定义进行封装，更接近原生 JS 开发。大家按需求选择就好。\n\n## 参考\n\n[React-中文官网](https://zh-hans.react.dev/learn)\n\n## 最后\n\n已将学习代码上传至 [github](https://github.com/YangyangU/CodeSpace)，欢迎大家学习指正！\n","source":"_posts/只会上班第一天就要我写ReactTS是种.md","raw":"---\ntitle: 只会Vue的我，上班第一天就要我写React+TS，是种什么样的体验？\ndate: 2024-06-07 16:00:00\ntags: [React]\ncategories: React\nindex_img: /img/react.png\nbanner_img: /img/default.png\n---\n\n## 前言\n\n**只会 Vue 的我，上班第一天就要我写 React+TS，是种什么样的体验？**\n\n入职第一天，坐公交来到指定报道处，拿号排队准备办理入职，拿装备去工位，认识 Leader 跟 Mentor，自己看文档装环境，屁股都没坐热，mentor 就问我技术栈是什么，我说 Vue，他又问 React 用过吗？我开始有不祥的预感，他反手就甩了个链接，叫我装完环境看一下，装完 vscode、node、git，我直接 pull 下来，看了一下目录 pnpm 咱也没用过啊，怎么全是 ts ，用的 Vite？这个我熟，直接安装依赖 run dev！\n\n首先，这个项目就两个页面，我第一感觉是：怎么看着还不如我自己的项目好看 😢，但是当我打开代码，脑子直接缺氧，啥都看不懂。什么 type 什么 useMemo，闻所未闻。\n\n赶紧开始自学 React + TS ……\n\n晚上回到出租屋，突然有一种压力油然而生，我是不是太蠢了，Mentor 会不会看不起我 ……\n\n看了一天视频，文章，我觉得我已经了解了 React ，至少不会看不懂了。\n\n这篇文章就来总结一下我是如何快速上手的，分享一下我心得体会。如果你也跟我一样，下面我分享一些我的经验，希望能够对您有所帮助。\n\n## 项目创建\n\n在 Vue 中，我们常用的脚手架是 Vue-CLI 以及尤大大推荐的 Vite ；在 React 中，我们通常使用 creat-react-app（CRA）创建项目，当然 Vite 同样也支持我们创建 React 项目。\n\n### 使用 CRA\n\n```bash\nnpx create-react-app my-react-app\n```\n\n### 使用 Vite\n\n```bash\nyarn create vite my-react-app --template react\n```\n\n### 其他创建方式\n\n参考 [React | 启动一个新项目](https://zh-hans.react.dev/learn/start-a-new-react-project)\n\n### 注意\n\n值得注意的是使用 cra 创建的项目中，JS 文件就是正常的`.js`后缀，而 Vite 创建项目的文件后缀是`.jsx`。\n\n- Vite 基于 ESModule，它提供了对 JSX 的原生支持，使用`.jsx`作为源文件的后缀，以便我们直接编写 JSX 语法的 React 组件。\n- CRA 默认没有启用 JSX 预处理器，而是通过 Babel 和 Webpack 等工具来处理 JSX 语法。\n\n在写法上没有区别，不用考虑太多。\n\n## 项目目录\n\n以下是 Vite 创建的项目目录结构：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af365556f65d4b75ba8b3656d79b105f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=195&h=338&s=14100&e=png&b=252526)\n\n其中入口文件是`main.jsx`，如果是 CRA 创建的项目则是`index.js`。\n\n让我来看看它的代码：\n\n```jsx\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport App from \"./App.jsx\";\nimport \"./index.css\";\n\nReactDOM.createRoot(document.getElementById(\"root\")).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n```\n\n这跟 Vue 的`main.js`的作用一样，将`App`根组件挂载到`id`为`root`的 DOM 元素上。\n\n**我猜你可能会想，这里引入一个 React 又引入一个 ReactDom 干嘛，它们两个有什么区别？**\n\n我们在`package.json`中也可以看到这两个依赖。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0df638d47a88442e8f77dabd6a41a1c0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=292&h=115&s=5549&e=png&b=1e1e1e)\n\n这是因为 React 作者将 React 源码拆成了两部分：\n\n- `React` 库提供构建用户界面的各种 API 和组件，比如创建 React 组件、处理组件生命周期、状态管理、事件处理等核心功能。\n\n- `ReactDom` 库是 React 的 DOM 渲染器，只负责将 React 组件渲染到浏览器的 DOM 中，提供一些管理组件的更新、挂载和卸载等操作的 API。\n\n## JSX\n\n我们`return`出来的 JSX 模板，如果要换行的话，需要用`()`包裹一下，然后这个 JSX 表达式必须具有一个父元素，什么意思呢？就是下面这种写法会报错，JSX 表达式规定了最外层只能有一个父元素，这种情况下我们一般会在最外面套一个`div`或者空标签`<></>`。\n\n```jsx\nreturn (\n  {/*报错*/}\n  <div>\n    <h1>hello</h1>\n  </div>\n  <div>\n    <h1>你好</h1>\n  </div>\n)\n\nreturn (\n  <>\n   <div>\n    <h1>hello</h1>\n   </div>\n   <div>\n    <h1>你好</h1>\n   </div>\n  </>\n)\n```\n\n在 JSX 表达式允许我们只能在`{}`中写 JS 代码\n\n## 创建组件\n\n在 React 中有两种创建组件的方式，函数组件和类组件，类组件是。现在界内大部分都使用函数组件，函数组件相比于类组件，性能更好，React 18 虽然还支持类组件，但是更推荐使用函数组件。\n\n### 函数组件\n\n#### 语法\n\n函数组件是通过函数来定义的，函数的返回值是 JSX 模板，可以使用 `function` 关键字或箭头函数定义。\n\n```jsx\nconst App = () => {\n  return (\n    <div>\n      <h1>Hello Function Component</h1>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d21eaa75fc34fcaac6638fb39e28de6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=454&h=157&s=8769&e=png&b=ffffff)\n\n#### 状态管理\n\n函数组件通过 React 提供的 Hooks 函数（官方提供的一般以`use`开头的 API），比如我们通常使用`useState` 钩子来管理状态。\n\n`useState` 返回一个由两个值组成的数组：\n\n1.  当前的`state`，初始值为传递给`useState`的参数。\n2.  `set`  函数，它可以让你将`state`更新为不同的值并触发重新渲染。\n\n🙋‍ 举个例子 🌰，这里我们实现一个计数器，点击`count`自增`1`：\n\n```jsx\nimport { useState } from \"react\";\n\nconst App = () => {\n  let [count, setCount] = useState(0);\n  const handleClick = () => {\n    setCount(count + 1);\n  };\n  return (\n    <div>\n      <h1 onClick={handleClick}>{count}</h1>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n这里我们解构得到`count`跟它的`set`方法，我们每次点击触发`handleClick`函数，函数内部通过`set`方法修改状态并重新渲染。\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91d93bd5149b47a095840c25ac501823~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=538&h=272&s=25427&e=gif&f=27&b=fefefe\" alt=\"GIF 2024-6-6 17-23-01.gif\" width=\"50%\" />\n\n#### 生命周期\n\nReact 16.8 之前，函数组件没有生命周期方法，但是从 React 16.8 开始，可以使用`useEffect` 这个 Hook 函数来执行类似生命周期的逻辑，用于替代 `componentDidMount`、`componentDidUpdate` 和 `componentWillUnmount`这些方法。\n\n##### useEffect\n\n`useEffect`是 React 中用于执行副作用操作的 Hook，并且具有类似于生命周期方法的功能。\n\n`useEffect` 接受两个参数：副作用函数和依赖数组。\n\n1.  **副作用函数**：第一个参数是一个函数，用于执行副作用操作。\n1.  **依赖数组**：第二个参数是一个数组，包含了副作用函数中所依赖的变量。如果省略这个参数，那么副作用函数会在每次组件重新渲染时都执行，可以充当`componentDidUpdate`这个生命周期；如果传入空数组 `[]`，则副作用函数只会在组件挂载时执行，相当于 `componentDidMount`；如果依赖数组中包含了某些变量，则只有这些变量发生变化时，副作用函数才会重新执行。如果我们在其中`return`一个函数，这个函数将会在组件卸载时除非，相当于`componentWillUnmount`。\n\n我总结了一下副作用函数执行时机与依赖项的关系如下：\n\n| 依赖项         | 副作用函数执行时机                  |\n| -------------- | ----------------------------------- |\n| 没有依赖项     | 组件初始渲染 + 组件更新时执行       |\n| 空数组依赖项   | 只在初次渲染时执行一次              |\n| 添加特定依赖项 | 组件初始渲染 + 特定依赖项变化时执行 |\n\n举例说明 🌰：\n\n```jsx\n//没有依赖项数组\nimport React, { useState, useEffect } from \"react\";\n\nconst App = () => {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    console.log(\"组件更新\");\n  });\n\n  return (\n    <div>\n      <p>点击了 {count} 次</p>\n      <button onClick={() => setCount(count + 1)}>点击</button>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n这里我们没有依赖项数组，刷新页面，组件初次渲染打印（打印两次是因为 React 源码自己执行了一次，应该是跟严格模式有关，这里我们不用深究），每次点击都会打印，可以充当`componentDidUpdate`生命周期。\n\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ed443e30b2e45629bbe20cf6064e775~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=696&h=468&s=52307&e=gif&f=21&b=fefefe\" alt=\"GIF 2024-6-6 19-32-33.gif\" width=\"50%\" />\n\n---\n\n依赖项为空数组呢？\n\n```jsx\n//依赖项为空数组呢？\nimport React, { useState, useEffect } from \"react\";\n\nconst App = () => {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    console.log(\"组件挂载\");\n  }, []);\n\n  return (\n    <div>\n      <p>点击了 {count} 次</p>\n      <button onClick={() => setCount(count + 1)}>点击</button>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n这里我们的依赖项数组为空，刷新页面，只在初次渲染时打印，点击不打印，可以充当`componentDidMount`生命周期。\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/746f9e4ce2254e8cbe223791767e28c3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=696&h=468&s=68204&e=gif&f=28&b=fefefe\" alt=\"GIF 2024-6-6 19-33-14.gif\" width=\"50%\" />\n\n---\n\n依赖项数组不为空呢？\n\n很容易联想到，如果数组里面有会发生改变的项，则会触发副作用函数，否则不会触发，这里就不演示了。\n\n---\n\n来看最后一个，在副作用函数中`return`一个函数：\n\n```jsx\nimport React, { useState, useEffect } from \"react\";\n\nconst App = () => {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log(\"组件更新\");\n    return () => {\n      console.log(\"组件卸载\");\n    };\n  }, [count]);\n\n  return (\n    <div>\n      <p>点击了 {count} 次</p>\n      <button onClick={() => setCount(count + 1)}>点击</button>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n这里我们`return`一个函数打印卸载，表示组件卸载时会执行的操作。我们通常在这里进行组件卸载时的执行的操作，可以充当`componentWillUnmount`生命周期。\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84e36073cdfe4f27b271fd53ded4a814~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=800&h=567&s=51838&e=gif&f=22&b=fefefe\" alt=\"GIF 2024-6-6 19-51-19.gif\" width=\"50%\" />\n\n一个很常见的例子 🌰：\n\n我们通常在组件卸载时清除一些副作用函数，如定时器\n\n```jsx\nimport React, { useState, useEffect } from \"react\";\n\nconst App = () => {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    let timer = setInterval(() => {\n      setCount(count + 1);\n    }, 1000);\n    return () => {\n      clearInterval(timer);\n    };\n  }, [count]);\n\n  return (\n    <div>\n      <p>点击了 {count} 次</p>\n      <button onClick={() => setCount(count + 1)}>点击</button>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n如果我们不及时清除定时器，会导致资源浪费。\n\n而且由于 `setCount` 是一个异步操作，它不会立即更新 `count` 的值，而是在下一次渲染时才会生效。因此，即使你设置了定时器每隔一秒钟执行一次，但 `count` 的值并不会每秒增加一次。相反，当定时器触发时，`count` 的值仍然是上一次渲染时的值。等一段时间后就会看到下面这个情况：\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29923fc094d648879b1013c2c93e0f02~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=572&h=324&s=27666&e=gif&f=18&b=fefefe\" alt=\"GIF 2024-6-6 20-06-38.gif\" width=\"50%\" />\n\n### 类组件\n\n😁**可以不用但不能不学！**\n\n#### 语法\n\n类组件通过继承 `React.Component` 或其子类来创建，类组件中有一个 `render()` 方法，用来返回 JSX 语法。\n\n拿代码说事：\n\n```jsx\nimport { Component } from \"react\";\n\nclass App extends Component {\n  constructor() {\n    super();\n  }\n  render() {\n    return (\n      <div>\n        <h1>Hello Class Component</h1>\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n类组件的语法就是声明一个类，这个类继承`React.Component` 或者子类，`render()`方法返回 JSX 模板。然后将我们的 App 组件挂载到页面上就可以了。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04452e5cd75c48dc9e2c1f9cd6f7d1a2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=458&h=167&s=9583&e=png&b=ffffff)\n\n#### 状态管理\n\n类组件拥有内部状态`state`，通过 `this.state` 来访问组件的状态，使用 `setState()`方法来更新状态，触发组件的重新渲染。\n\n```jsx\nimport { Component } from \"react\";\n\nclass App extends Component{\n  constructor(){\n    super();\n    this.state={\n      name:\"张三\"\n    }\n  }\n  handleClick(){\n\n  }\n  render(){\n    return(\n      <div>\n        <h1 onClick={()=>this.setState({name:\"李四\"})>{this.state.name}</h1>\n      </div>\n    )\n  }\n}\n\nexport default App;\n```\n\n我们绑定`onClick`事件，当点击时修改`name`的状态。\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f05edfaefa984490ba816a83af73136d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=467&h=332&s=17537&e=gif&f=5&b=fefefe\" alt=\"GIF 2024-6-6 17-04-25.gif\" width=\"30%\" />\n\n#### 生命周期\n\n类组件中可以使用生命周期方法，常见的有`componentDidMount`、`componentDidUpdate`、=跟`componentWillUnmount`，它们分别对应 Vue3 中的 `onMounted`、`onUpdated` 跟 `onBeforeUnmount`。\n\n这个网站可以很清楚看到 React 的生命周期，[React 生命周期](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)，这里就不过多赘述。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c876571316c4779bf0528aca4cef60a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1180&h=424&s=40943&e=png&b=fbf8f7)\n\n### 组件通讯\n\n在 Vue 中组件传值一般通过`props & emit`、`provide & inject`以及 Vue2 中的`EventBus`，或者我们可以直接使用状态管理工具`Vuex`或`Pinia`，React 其实大差不差，同样也有自己的状态管理工具。\n\n#### 父传子\n\n父组件通过`props`传递任意的数字、字符串、布尔值、数组、对象、函数甚至是 JSX，子组件通过`props`参数接收。\n\n🙋‍♀️🌰：\n\n```jsx\nconst Son = (props) => {\n  return (\n    <>\n      <p>{props.name}</p>\n      <p>{props.age}</p>\n      <p>{props.cb()}</p>\n      <p>{props.child}</p>\n    </>\n  );\n};\n\nconst Father = () => {\n  return (\n    <Son\n      name={\"阳阳羊\"}\n      age={20}\n      cb={function cb() {\n        console.log(123);\n      }}\n      child={<span>i am jsx</span>}\n    ></Son>\n  );\n};\n```\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f7493c702384844b509095a3f5f3972~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=789&h=415&s=27428&e=png&b=fefefe\" alt=\"image.png\" width=\"50%\" />\n\n⚠️ 需要注意的是：子组件只能读取`props`中的数据，不能直接进行修改，父组件的数据只能由父组件修改，或者通过父组件传过来的函数进行修改。如果在子标签中嵌套元素，可以在子组件的`props.children`中获取。\n\n#### 子传父\n\n子传父通过最原始的回调函数方式，父组件给子组件传一个函数，子组件调用这个函数然后传入实参，在函数内部用`set`方法修改父组件的状态。\n\n🙋‍♀️🌰：\n\n```jsx\nconst Son = (props) => {\n  return <button onClick={() => props.cb(\"小羊\")}>点击传递</button>;\n};\n\nconst Father = () => {\n  let [name, setName] = useState(\"阳阳羊\");\n  let cb = (name) => {\n    setName(name);\n  };\n  return (\n    <>\n      <Son cb={cb}></Son>\n      {name}\n    </>\n  );\n};\n```\n\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44f24ffe31fa4c8b84aada591cf2e534~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=549&h=284&s=14214&e=gif&f=3&b=fdfdfd\" alt=\"GIF 2024-6-7 11-20-34.gif\" width=\"50%\" />\n\n⚠️ 这里需要注意：`onClick`事件处理程序是一个函数，写成`onClick={() => props.cb('小羊')}`时，实际上创建了一个匿名函数，当点击按钮时会调用这个函数，然后调用`props.cb('小羊')`，如果直接写成`onClick={props.cb('小羊')}`，在渲染时就会立即调用`props.cb('小羊')`，而不是在点击时调用。\n\n#### 兄弟组件通信\n\n兄弟组件通信贯用手段就是**状态提升**，说白话就是将数据都交给父组件，然后父组件作为中间商派发给大家。\n\n🙋‍♀️🌰：\n\n```jsx\nconst Son1 = (props) => {\n  return (\n    <>\n      子组件1-\n      <button onClick={() => props.cb(\"小羊\")}>传给子组件2</button>\n    </>\n  );\n};\n\nconst Son2 = (props) => {\n  return (\n    <>\n      <p>子组件2-{props.name}</p>\n    </>\n  );\n};\n\nconst Father = () => {\n  let [name, setName] = useState(\"Son2\");\n  const cb = (newName) => {\n    setName(newName);\n  };\n  return (\n    <>\n      <Son1 cb={cb}></Son1>\n      <Son2 name={name}></Son2>\n    </>\n  );\n};\n```\n\n这里子`组件1`通过触发父组件传递过来的函数，并传递参数，然后父组件接收到参数修改数据源，传递给`组件2`。这样就完成了兄弟组件通信。\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eb12209347142b59eea4b418c9507dc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=547&h=273&s=24884&e=gif&f=6&b=fdfcfc\" alt=\"GIF 2024-6-7 11-16-47.gif\" width=\"50%\" />\n\n#### 夸层组件通讯\n\n思路是将两个组件放在同一个上下文中就能实现数据共享。步骤如下：\n\n1. 使用`createContext`方法创建一个上下文对象，将组件`Provider`，`Consumer`抛出\n\n```js\nimport React from \"react\";\nconst { Provider, Consumer } = React.createContext();\n\nexport { Provider, Consumer };\n```\n\n2. 在顶层组件(App)中通过`Provider`组件提供数据\n\n3. 在底层组件(B)中通过`Consumer`组件获取对应数据\n\n```jsx\nimport { Provider, Consumer } from \"./provider\";\n\nconst ComponentB = () => {\n  return (\n    <Consumer>\n      {(value) => (\n        <div>\n          <h1>底层组件——{value}</h1>\n        </div>\n      )}\n    </Consumer>\n  );\n};\n\nconst App = () => {\n  const value = \"顶层组件的数据\";\n  return (\n    <Provider value={value}>\n      <h1>顶层组件</h1>\n      <ComponentB />\n    </Provider>\n  );\n};\n```\n\n效果如下：\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c488273f449470fbfbdccb8e36b31d3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=813&h=369&s=31043&e=png&b=fefefe\" alt=\"image.png\" width=\"50%\" />\n\n#### 状态管理工具\n\n常见的 React 状态管理工具有 Redux、Mobx、Rcoil 等等，如果有感兴趣的同学，我可以单独出一篇文章详细聊聊。本篇就不展开聊了。\n\n## 自定义 Hooks\n\n除了 React 官方提供的一些 Hooks 之外，还允许我们自定义自己的 Hooks，我们需要遵循以下规则：\n\n1. 声明以`use`开头的函数\n2. 在函数体内封装可复用的逻辑\n3. 把组件中使用到的状态`return`出去\n4. 在哪里用到就在里面执行解构\n\n🙋‍♀️🌰：\n\n我们设计来设计一个开关 Hooks，作用是对值取反，从而控制元素的显示隐藏：\n\n```jsx\nimport { useState } from \"react\";\n\nfunction useToggle() {\n  const [value, setValue] = useState(true);\n  const toggle = () => {\n    setValue(!value);\n  };\n  return [value, toggle];\n}\n\nconst App = () => {\n  const [value, toggle] = useToggle();\n  return (\n    <div>\n      <h1>{value ? \"开\" : \"关\"}</h1>\n      <button onClick={toggle}>按钮</button>\n    </div>\n  );\n};\nexport default App;\n```\n\n这里我们借助`useState`进行封装，将需要用到的变量进行抛出，在需要使用的地方解构拿到，通过三目运算符进行显示隐藏。\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c183f8bc55224444b6bb384239bd4c08~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=613&h=369&s=29609&e=gif&f=12&b=fefefe\" alt=\"GIF 2024-6-7 12-07-46.gif\" width=\"50%\" />\n\n### Hooks 使用规则\n\nHooks 并不是然后场景下都能用，像比如在类组件中是不能直接使用 Hooks 的，除非使用高阶函数进行包装，以及其他许多规则：\n\n- 不能在组件外部使用\n- 不能在判断语句中使用\n\n详见 [React 中文官网](https://zh-hans.react.dev/reference/rules/rules-of-hooks)\n\n## 总结\n\n还是那句话，不管是 Vue 跟 React 都有自己的优缺点，我们不能断言说哪个好哪个差，在我看来 Vue 更适合第一次接触前端框架的小白，它封装了许多 API，对新手很友好，上手即用；而 React 相对复杂，更考验开发者的思维，对于一些复杂需求能够自定义进行封装，更接近原生 JS 开发。大家按需求选择就好。\n\n## 参考\n\n[React-中文官网](https://zh-hans.react.dev/learn)\n\n## 最后\n\n已将学习代码上传至 [github](https://github.com/YangyangU/CodeSpace)，欢迎大家学习指正！\n","slug":"只会上班第一天就要我写ReactTS是种","published":1,"updated":"2024-09-09T15:30:52.201Z","_id":"clyww044t000fcwv609u7ar1q","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><strong>只会 Vue 的我，上班第一天就要我写 React+TS，是种什么样的体验？</strong></p>\n<p>入职第一天，坐公交来到指定报道处，拿号排队准备办理入职，拿装备去工位，认识 Leader 跟 Mentor，自己看文档装环境，屁股都没坐热，mentor 就问我技术栈是什么，我说 Vue，他又问 React 用过吗？我开始有不祥的预感，他反手就甩了个链接，叫我装完环境看一下，装完 vscode、node、git，我直接 pull 下来，看了一下目录 pnpm 咱也没用过啊，怎么全是 ts ，用的 Vite？这个我熟，直接安装依赖 run dev！</p>\n<p>首先，这个项目就两个页面，我第一感觉是：怎么看着还不如我自己的项目好看 😢，但是当我打开代码，脑子直接缺氧，啥都看不懂。什么 type 什么 useMemo，闻所未闻。</p>\n<p>赶紧开始自学 React + TS ……</p>\n<p>晚上回到出租屋，突然有一种压力油然而生，我是不是太蠢了，Mentor 会不会看不起我 ……</p>\n<p>看了一天视频，文章，我觉得我已经了解了 React ，至少不会看不懂了。</p>\n<p>这篇文章就来总结一下我是如何快速上手的，分享一下我心得体会。如果你也跟我一样，下面我分享一些我的经验，希望能够对您有所帮助。</p>\n<h2 id=\"项目创建\"><a href=\"#项目创建\" class=\"headerlink\" title=\"项目创建\"></a>项目创建</h2><p>在 Vue 中，我们常用的脚手架是 Vue-CLI 以及尤大大推荐的 Vite ；在 React 中，我们通常使用 creat-react-app（CRA）创建项目，当然 Vite 同样也支持我们创建 React 项目。</p>\n<h3 id=\"使用-CRA\"><a href=\"#使用-CRA\" class=\"headerlink\" title=\"使用 CRA\"></a>使用 CRA</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npx create-react-app my-react-app<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用-Vite\"><a href=\"#使用-Vite\" class=\"headerlink\" title=\"使用 Vite\"></a>使用 Vite</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn create vite my-react-app --template react<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"其他创建方式\"><a href=\"#其他创建方式\" class=\"headerlink\" title=\"其他创建方式\"></a>其他创建方式</h3><p>参考 <a href=\"https://zh-hans.react.dev/learn/start-a-new-react-project\">React | 启动一个新项目</a></p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>值得注意的是使用 cra 创建的项目中，JS 文件就是正常的<code>.js</code>后缀，而 Vite 创建项目的文件后缀是<code>.jsx</code>。</p>\n<ul>\n<li>Vite 基于 ESModule，它提供了对 JSX 的原生支持，使用<code>.jsx</code>作为源文件的后缀，以便我们直接编写 JSX 语法的 React 组件。</li>\n<li>CRA 默认没有启用 JSX 预处理器，而是通过 Babel 和 Webpack 等工具来处理 JSX 语法。</li>\n</ul>\n<p>在写法上没有区别，不用考虑太多。</p>\n<h2 id=\"项目目录\"><a href=\"#项目目录\" class=\"headerlink\" title=\"项目目录\"></a>项目目录</h2><p>以下是 Vite 创建的项目目录结构：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af365556f65d4b75ba8b3656d79b105f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=195&h=338&s=14100&e=png&b=252526\" alt=\"image.png\"></p>\n<p>其中入口文件是<code>main.jsx</code>，如果是 CRA 创建的项目则是<code>index.js</code>。</p>\n<p>让我来看看它的代码：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ReactDOM</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-dom/client&quot;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">App</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./App.jsx&quot;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;./index.css&quot;</span>;<br><br><span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">createRoot</span>(<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;root&quot;</span>)).<span class=\"hljs-title function_\">render</span>(<br>  <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">React.StrictMode</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> /&gt;</span></span><br><span class=\"language-xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">React.StrictMode</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure>\n\n<p>这跟 Vue 的<code>main.js</code>的作用一样，将<code>App</code>根组件挂载到<code>id</code>为<code>root</code>的 DOM 元素上。</p>\n<p><strong>我猜你可能会想，这里引入一个 React 又引入一个 ReactDom 干嘛，它们两个有什么区别？</strong></p>\n<p>我们在<code>package.json</code>中也可以看到这两个依赖。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0df638d47a88442e8f77dabd6a41a1c0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=292&h=115&s=5549&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>这是因为 React 作者将 React 源码拆成了两部分：</p>\n<ul>\n<li><p><code>React</code> 库提供构建用户界面的各种 API 和组件，比如创建 React 组件、处理组件生命周期、状态管理、事件处理等核心功能。</p>\n</li>\n<li><p><code>ReactDom</code> 库是 React 的 DOM 渲染器，只负责将 React 组件渲染到浏览器的 DOM 中，提供一些管理组件的更新、挂载和卸载等操作的 API。</p>\n</li>\n</ul>\n<h2 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h2><p>我们<code>return</code>出来的 JSX 模板，如果要换行的话，需要用<code>()</code>包裹一下，然后这个 JSX 表达式必须具有一个父元素，什么意思呢？就是下面这种写法会报错，JSX 表达式规定了最外层只能有一个父元素，这种情况下我们一般会在最外面套一个<code>div</code>或者空标签<code>&lt;&gt;&lt;/&gt;</code>。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">return</span> (<br>  &#123;<span class=\"hljs-comment\">/*报错*/</span>&#125;<br>  &lt;div&gt;<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br>  &lt;/div&gt;<br>  <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>你好<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>)<br><br><span class=\"hljs-keyword\">return</span> (<br>  <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>你好<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">  <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>)<br></code></pre></td></tr></table></figure>\n\n<p>在 JSX 表达式允许我们只能在<code>&#123;&#125;</code>中写 JS 代码</p>\n<h2 id=\"创建组件\"><a href=\"#创建组件\" class=\"headerlink\" title=\"创建组件\"></a>创建组件</h2><p>在 React 中有两种创建组件的方式，函数组件和类组件，类组件是。现在界内大部分都使用函数组件，函数组件相比于类组件，性能更好，React 18 虽然还支持类组件，但是更推荐使用函数组件。</p>\n<h3 id=\"函数组件\"><a href=\"#函数组件\" class=\"headerlink\" title=\"函数组件\"></a>函数组件</h3><h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><p>函数组件是通过函数来定义的，函数的返回值是 JSX 模板，可以使用 <code>function</code> 关键字或箭头函数定义。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello Function Component<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d21eaa75fc34fcaac6638fb39e28de6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=454&h=157&s=8769&e=png&b=ffffff\" alt=\"image.png\"></p>\n<h4 id=\"状态管理\"><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h4><p>函数组件通过 React 提供的 Hooks 函数（官方提供的一般以<code>use</code>开头的 API），比如我们通常使用<code>useState</code> 钩子来管理状态。</p>\n<p><code>useState</code> 返回一个由两个值组成的数组：</p>\n<ol>\n<li>当前的<code>state</code>，初始值为传递给<code>useState</code>的参数。</li>\n<li><code>set</code>  函数，它可以让你将<code>state</code>更新为不同的值并触发重新渲染。</li>\n</ol>\n<p>🙋‍ 举个例子 🌰，这里我们实现一个计数器，点击<code>count</code>自增<code>1</code>：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; useState &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">let</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);<br>  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handleClick</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>    <span class=\"hljs-title function_\">setCount</span>(count + <span class=\"hljs-number\">1</span>);<br>  &#125;;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;handleClick&#125;</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这里我们解构得到<code>count</code>跟它的<code>set</code>方法，我们每次点击触发<code>handleClick</code>函数，函数内部通过<code>set</code>方法修改状态并重新渲染。</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91d93bd5149b47a095840c25ac501823~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=538&h=272&s=25427&e=gif&f=27&b=fefefe\" alt=\"GIF 2024-6-6 17-23-01.gif\" width=\"50%\" />\n\n<h4 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h4><p>React 16.8 之前，函数组件没有生命周期方法，但是从 React 16.8 开始，可以使用<code>useEffect</code> 这个 Hook 函数来执行类似生命周期的逻辑，用于替代 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code>这些方法。</p>\n<h5 id=\"useEffect\"><a href=\"#useEffect\" class=\"headerlink\" title=\"useEffect\"></a>useEffect</h5><p><code>useEffect</code>是 React 中用于执行副作用操作的 Hook，并且具有类似于生命周期方法的功能。</p>\n<p><code>useEffect</code> 接受两个参数：副作用函数和依赖数组。</p>\n<ol>\n<li><strong>副作用函数</strong>：第一个参数是一个函数，用于执行副作用操作。</li>\n<li><strong>依赖数组</strong>：第二个参数是一个数组，包含了副作用函数中所依赖的变量。如果省略这个参数，那么副作用函数会在每次组件重新渲染时都执行，可以充当<code>componentDidUpdate</code>这个生命周期；如果传入空数组 <code>[]</code>，则副作用函数只会在组件挂载时执行，相当于 <code>componentDidMount</code>；如果依赖数组中包含了某些变量，则只有这些变量发生变化时，副作用函数才会重新执行。如果我们在其中<code>return</code>一个函数，这个函数将会在组件卸载时除非，相当于<code>componentWillUnmount</code>。</li>\n</ol>\n<p>我总结了一下副作用函数执行时机与依赖项的关系如下：</p>\n<table>\n<thead>\n<tr>\n<th>依赖项</th>\n<th>副作用函数执行时机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>没有依赖项</td>\n<td>组件初始渲染 + 组件更新时执行</td>\n</tr>\n<tr>\n<td>空数组依赖项</td>\n<td>只在初次渲染时执行一次</td>\n</tr>\n<tr>\n<td>添加特定依赖项</td>\n<td>组件初始渲染 + 特定依赖项变化时执行</td>\n</tr>\n</tbody></table>\n<p>举例说明 🌰：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">//没有依赖项数组</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, &#123; useState, useEffect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);<br>  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;组件更新&quot;</span>);<br>  &#125;);<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>点击了 &#123;count&#125; 次<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;点击<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这里我们没有依赖项数组，刷新页面，组件初次渲染打印（打印两次是因为 React 源码自己执行了一次，应该是跟严格模式有关，这里我们不用深究），每次点击都会打印，可以充当<code>componentDidUpdate</code>生命周期。</p>\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ed443e30b2e45629bbe20cf6064e775~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=696&h=468&s=52307&e=gif&f=21&b=fefefe\" alt=\"GIF 2024-6-6 19-32-33.gif\" width=\"50%\" />\n\n<hr>\n<p>依赖项为空数组呢？</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">//依赖项为空数组呢？</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, &#123; useState, useEffect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);<br>  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;组件挂载&quot;</span>);<br>  &#125;, []);<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>点击了 &#123;count&#125; 次<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;点击<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这里我们的依赖项数组为空，刷新页面，只在初次渲染时打印，点击不打印，可以充当<code>componentDidMount</code>生命周期。</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/746f9e4ce2254e8cbe223791767e28c3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=696&h=468&s=68204&e=gif&f=28&b=fefefe\" alt=\"GIF 2024-6-6 19-33-14.gif\" width=\"50%\" />\n\n<hr>\n<p>依赖项数组不为空呢？</p>\n<p>很容易联想到，如果数组里面有会发生改变的项，则会触发副作用函数，否则不会触发，这里就不演示了。</p>\n<hr>\n<p>来看最后一个，在副作用函数中<code>return</code>一个函数：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, &#123; useState, useEffect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);<br><br>  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;组件更新&quot;</span>);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;组件卸载&quot;</span>);<br>    &#125;;<br>  &#125;, [count]);<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>点击了 &#123;count&#125; 次<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;点击<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这里我们<code>return</code>一个函数打印卸载，表示组件卸载时会执行的操作。我们通常在这里进行组件卸载时的执行的操作，可以充当<code>componentWillUnmount</code>生命周期。</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84e36073cdfe4f27b271fd53ded4a814~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=800&h=567&s=51838&e=gif&f=22&b=fefefe\" alt=\"GIF 2024-6-6 19-51-19.gif\" width=\"50%\" />\n\n<p>一个很常见的例子 🌰：</p>\n<p>我们通常在组件卸载时清除一些副作用函数，如定时器</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, &#123; useState, useEffect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);<br><br>  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> timer = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-title function_\">setCount</span>(count + <span class=\"hljs-number\">1</span>);<br>    &#125;, <span class=\"hljs-number\">1000</span>);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-built_in\">clearInterval</span>(timer);<br>    &#125;;<br>  &#125;, [count]);<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>点击了 &#123;count&#125; 次<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;点击<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;<br></code></pre></td></tr></table></figure>\n\n<p>如果我们不及时清除定时器，会导致资源浪费。</p>\n<p>而且由于 <code>setCount</code> 是一个异步操作，它不会立即更新 <code>count</code> 的值，而是在下一次渲染时才会生效。因此，即使你设置了定时器每隔一秒钟执行一次，但 <code>count</code> 的值并不会每秒增加一次。相反，当定时器触发时，<code>count</code> 的值仍然是上一次渲染时的值。等一段时间后就会看到下面这个情况：</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29923fc094d648879b1013c2c93e0f02~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=572&h=324&s=27666&e=gif&f=18&b=fefefe\" alt=\"GIF 2024-6-6 20-06-38.gif\" width=\"50%\" />\n\n<h3 id=\"类组件\"><a href=\"#类组件\" class=\"headerlink\" title=\"类组件\"></a>类组件</h3><p>😁<strong>可以不用但不能不学！</strong></p>\n<h4 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h4><p>类组件通过继承 <code>React.Component</code> 或其子类来创建，类组件中有一个 <code>render()</code> 方法，用来返回 JSX 语法。</p>\n<p>拿代码说事：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Component</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">App</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Component</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">super</span>();<br>  &#125;<br>  <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> (<br>      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello Class Component<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;<br></code></pre></td></tr></table></figure>\n\n<p>类组件的语法就是声明一个类，这个类继承<code>React.Component</code> 或者子类，<code>render()</code>方法返回 JSX 模板。然后将我们的 App 组件挂载到页面上就可以了。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04452e5cd75c48dc9e2c1f9cd6f7d1a2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=458&h=167&s=9583&e=png&b=ffffff\" alt=\"image.png\"></p>\n<h4 id=\"状态管理-1\"><a href=\"#状态管理-1\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h4><p>类组件拥有内部状态<code>state</code>，通过 <code>this.state</code> 来访问组件的状态，使用 <code>setState()</code>方法来更新状态，触发组件的重新渲染。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Component</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">App</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Component</span>&#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-variable language_\">super</span>();<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span>=&#123;<br>      <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;张三&quot;</span><br>    &#125;<br>  &#125;<br>  <span class=\"hljs-title function_\">handleClick</span>(<span class=\"hljs-params\"></span>)&#123;<br><br>  &#125;<br>  <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-keyword\">return</span>(<br>      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span>=&gt;</span>this.setState(&#123;name:&quot;李四&quot;&#125;)&gt;&#123;this.state.name&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;<br></code></pre></td></tr></table></figure>\n\n<p>我们绑定<code>onClick</code>事件，当点击时修改<code>name</code>的状态。</p>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f05edfaefa984490ba816a83af73136d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=467&h=332&s=17537&e=gif&f=5&b=fefefe\" alt=\"GIF 2024-6-6 17-04-25.gif\" width=\"30%\" />\n\n<h4 id=\"生命周期-1\"><a href=\"#生命周期-1\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h4><p>类组件中可以使用生命周期方法，常见的有<code>componentDidMount</code>、<code>componentDidUpdate</code>、&#x3D;跟<code>componentWillUnmount</code>，它们分别对应 Vue3 中的 <code>onMounted</code>、<code>onUpdated</code> 跟 <code>onBeforeUnmount</code>。</p>\n<p>这个网站可以很清楚看到 React 的生命周期，<a href=\"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\">React 生命周期</a>，这里就不过多赘述。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c876571316c4779bf0528aca4cef60a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1180&h=424&s=40943&e=png&b=fbf8f7\" alt=\"image.png\"></p>\n<h3 id=\"组件通讯\"><a href=\"#组件通讯\" class=\"headerlink\" title=\"组件通讯\"></a>组件通讯</h3><p>在 Vue 中组件传值一般通过<code>props &amp; emit</code>、<code>provide &amp; inject</code>以及 Vue2 中的<code>EventBus</code>，或者我们可以直接使用状态管理工具<code>Vuex</code>或<code>Pinia</code>，React 其实大差不差，同样也有自己的状态管理工具。</p>\n<h4 id=\"父传子\"><a href=\"#父传子\" class=\"headerlink\" title=\"父传子\"></a>父传子</h4><p>父组件通过<code>props</code>传递任意的数字、字符串、布尔值、数组、对象、函数甚至是 JSX，子组件通过<code>props</code>参数接收。</p>\n<p>🙋‍♀️🌰：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Son</span> = (<span class=\"hljs-params\">props</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;props.name&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;props.age&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;props.cb()&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;props.child&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Father</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Son</span></span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&#123;</span>&quot;<span class=\"hljs-attr\">阳阳羊</span>&quot;&#125;</span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">      <span class=\"hljs-attr\">age</span>=<span class=\"hljs-string\">&#123;20&#125;</span></span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">      <span class=\"hljs-attr\">cb</span>=<span class=\"hljs-string\">&#123;function</span> <span class=\"hljs-attr\">cb</span>() &#123;</span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">        <span class=\"hljs-attr\">console.log</span>(<span class=\"hljs-attr\">123</span>);</span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">      &#125;&#125;</span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">      <span class=\"hljs-attr\">child</span>=<span class=\"hljs-string\">&#123;</span>&lt;<span class=\"hljs-attr\">span</span>&gt;</span>i am jsx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>&#125;</span><br><span class=\"language-xml\">    &gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Son</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f7493c702384844b509095a3f5f3972~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=789&h=415&s=27428&e=png&b=fefefe\" alt=\"image.png\" width=\"50%\" />\n\n<p>⚠️ 需要注意的是：子组件只能读取<code>props</code>中的数据，不能直接进行修改，父组件的数据只能由父组件修改，或者通过父组件传过来的函数进行修改。如果在子标签中嵌套元素，可以在子组件的<code>props.children</code>中获取。</p>\n<h4 id=\"子传父\"><a href=\"#子传父\" class=\"headerlink\" title=\"子传父\"></a>子传父</h4><p>子传父通过最原始的回调函数方式，父组件给子组件传一个函数，子组件调用这个函数然后传入实参，在函数内部用<code>set</code>方法修改父组件的状态。</p>\n<p>🙋‍♀️🌰：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Son</span> = (<span class=\"hljs-params\">props</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> props.cb(&quot;小羊&quot;)&#125;&gt;点击传递<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Father</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">let</span> [name, setName] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-string\">&quot;阳阳羊&quot;</span>);<br>  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-title function_\">cb</span> = (<span class=\"hljs-params\">name</span>) =&gt; &#123;<br>    <span class=\"hljs-title function_\">setName</span>(name);<br>  &#125;;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Son</span> <span class=\"hljs-attr\">cb</span>=<span class=\"hljs-string\">&#123;cb&#125;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Son</span>&gt;</span></span><br><span class=\"language-xml\">      &#123;name&#125;</span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44f24ffe31fa4c8b84aada591cf2e534~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=549&h=284&s=14214&e=gif&f=3&b=fdfdfd\" alt=\"GIF 2024-6-7 11-20-34.gif\" width=\"50%\" />\n\n<p>⚠️ 这里需要注意：<code>onClick</code>事件处理程序是一个函数，写成<code>onClick=&#123;() =&gt; props.cb(&#39;小羊&#39;)&#125;</code>时，实际上创建了一个匿名函数，当点击按钮时会调用这个函数，然后调用<code>props.cb(&#39;小羊&#39;)</code>，如果直接写成<code>onClick=&#123;props.cb(&#39;小羊&#39;)&#125;</code>，在渲染时就会立即调用<code>props.cb(&#39;小羊&#39;)</code>，而不是在点击时调用。</p>\n<h4 id=\"兄弟组件通信\"><a href=\"#兄弟组件通信\" class=\"headerlink\" title=\"兄弟组件通信\"></a>兄弟组件通信</h4><p>兄弟组件通信贯用手段就是<strong>状态提升</strong>，说白话就是将数据都交给父组件，然后父组件作为中间商派发给大家。</p>\n<p>🙋‍♀️🌰：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Son1</span> = (<span class=\"hljs-params\">props</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">      子组件1-</span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> props.cb(&quot;小羊&quot;)&#125;&gt;传给子组件2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Son2</span> = (<span class=\"hljs-params\">props</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>子组件2-&#123;props.name&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Father</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">let</span> [name, setName] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-string\">&quot;Son2&quot;</span>);<br>  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">cb</span> = (<span class=\"hljs-params\">newName</span>) =&gt; &#123;<br>    <span class=\"hljs-title function_\">setName</span>(newName);<br>  &#125;;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Son1</span> <span class=\"hljs-attr\">cb</span>=<span class=\"hljs-string\">&#123;cb&#125;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Son1</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Son2</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&#123;name&#125;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Son2</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>这里子<code>组件1</code>通过触发父组件传递过来的函数，并传递参数，然后父组件接收到参数修改数据源，传递给<code>组件2</code>。这样就完成了兄弟组件通信。</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eb12209347142b59eea4b418c9507dc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=547&h=273&s=24884&e=gif&f=6&b=fdfcfc\" alt=\"GIF 2024-6-7 11-16-47.gif\" width=\"50%\" />\n\n<h4 id=\"夸层组件通讯\"><a href=\"#夸层组件通讯\" class=\"headerlink\" title=\"夸层组件通讯\"></a>夸层组件通讯</h4><p>思路是将两个组件放在同一个上下文中就能实现数据共享。步骤如下：</p>\n<ol>\n<li>使用<code>createContext</code>方法创建一个上下文对象，将组件<code>Provider</code>，<code>Consumer</code>抛出</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-title class_\">Provider</span>, <span class=\"hljs-title class_\">Consumer</span> &#125; = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">createContext</span>();<br><br><span class=\"hljs-keyword\">export</span> &#123; <span class=\"hljs-title class_\">Provider</span>, <span class=\"hljs-title class_\">Consumer</span> &#125;;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>在顶层组件(App)中通过<code>Provider</code>组件提供数据</p>\n</li>\n<li><p>在底层组件(B)中通过<code>Consumer</code>组件获取对应数据</p>\n</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Provider</span>, <span class=\"hljs-title class_\">Consumer</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./provider&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">ComponentB</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Consumer</span>&gt;</span></span><br><span class=\"language-xml\">      &#123;(value) =&gt; (</span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>底层组件——&#123;value&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      )&#125;</span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Consumer</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-string\">&quot;顶层组件的数据&quot;</span>;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;value&#125;</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>顶层组件<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentB</span> /&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Provider</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>效果如下：</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c488273f449470fbfbdccb8e36b31d3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=813&h=369&s=31043&e=png&b=fefefe\" alt=\"image.png\" width=\"50%\" />\n\n<h4 id=\"状态管理工具\"><a href=\"#状态管理工具\" class=\"headerlink\" title=\"状态管理工具\"></a>状态管理工具</h4><p>常见的 React 状态管理工具有 Redux、Mobx、Rcoil 等等，如果有感兴趣的同学，我可以单独出一篇文章详细聊聊。本篇就不展开聊了。</p>\n<h2 id=\"自定义-Hooks\"><a href=\"#自定义-Hooks\" class=\"headerlink\" title=\"自定义 Hooks\"></a>自定义 Hooks</h2><p>除了 React 官方提供的一些 Hooks 之外，还允许我们自定义自己的 Hooks，我们需要遵循以下规则：</p>\n<ol>\n<li>声明以<code>use</code>开头的函数</li>\n<li>在函数体内封装可复用的逻辑</li>\n<li>把组件中使用到的状态<code>return</code>出去</li>\n<li>在哪里用到就在里面执行解构</li>\n</ol>\n<p>🙋‍♀️🌰：</p>\n<p>我们设计来设计一个开关 Hooks，作用是对值取反，从而控制元素的显示隐藏：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; useState &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">useToggle</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> [value, setValue] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">true</span>);<br>  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">toggle</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>    <span class=\"hljs-title function_\">setValue</span>(!value);<br>  &#125;;<br>  <span class=\"hljs-keyword\">return</span> [value, toggle];<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> [value, toggle] = <span class=\"hljs-title function_\">useToggle</span>();<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;value ? &quot;开&quot; : &quot;关&quot;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;toggle&#125;</span>&gt;</span>按钮<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这里我们借助<code>useState</code>进行封装，将需要用到的变量进行抛出，在需要使用的地方解构拿到，通过三目运算符进行显示隐藏。</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c183f8bc55224444b6bb384239bd4c08~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=613&h=369&s=29609&e=gif&f=12&b=fefefe\" alt=\"GIF 2024-6-7 12-07-46.gif\" width=\"50%\" />\n\n<h3 id=\"Hooks-使用规则\"><a href=\"#Hooks-使用规则\" class=\"headerlink\" title=\"Hooks 使用规则\"></a>Hooks 使用规则</h3><p>Hooks 并不是然后场景下都能用，像比如在类组件中是不能直接使用 Hooks 的，除非使用高阶函数进行包装，以及其他许多规则：</p>\n<ul>\n<li>不能在组件外部使用</li>\n<li>不能在判断语句中使用</li>\n</ul>\n<p>详见 <a href=\"https://zh-hans.react.dev/reference/rules/rules-of-hooks\">React 中文官网</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>还是那句话，不管是 Vue 跟 React 都有自己的优缺点，我们不能断言说哪个好哪个差，在我看来 Vue 更适合第一次接触前端框架的小白，它封装了许多 API，对新手很友好，上手即用；而 React 相对复杂，更考验开发者的思维，对于一些复杂需求能够自定义进行封装，更接近原生 JS 开发。大家按需求选择就好。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://zh-hans.react.dev/learn\">React-中文官网</a></p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>已将学习代码上传至 <a href=\"https://github.com/YangyangU/CodeSpace\">github</a>，欢迎大家学习指正！</p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><strong>只会 Vue 的我，上班第一天就要我写 React+TS，是种什么样的体验？</strong></p>\n<p>入职第一天，坐公交来到指定报道处，拿号排队准备办理入职，拿装备去工位，认识 Leader 跟 Mentor，自己看文档装环境，屁股都没坐热，mentor 就问我技术栈是什么，我说 Vue，他又问 React 用过吗？我开始有不祥的预感，他反手就甩了个链接，叫我装完环境看一下，装完 vscode、node、git，我直接 pull 下来，看了一下目录 pnpm 咱也没用过啊，怎么全是 ts ，用的 Vite？这个我熟，直接安装依赖 run dev！</p>\n<p>首先，这个项目就两个页面，我第一感觉是：怎么看着还不如我自己的项目好看 😢，但是当我打开代码，脑子直接缺氧，啥都看不懂。什么 type 什么 useMemo，闻所未闻。</p>\n<p>赶紧开始自学 React + TS ……</p>\n<p>晚上回到出租屋，突然有一种压力油然而生，我是不是太蠢了，Mentor 会不会看不起我 ……</p>\n<p>看了一天视频，文章，我觉得我已经了解了 React ，至少不会看不懂了。</p>\n<p>这篇文章就来总结一下我是如何快速上手的，分享一下我心得体会。如果你也跟我一样，下面我分享一些我的经验，希望能够对您有所帮助。</p>\n<h2 id=\"项目创建\"><a href=\"#项目创建\" class=\"headerlink\" title=\"项目创建\"></a>项目创建</h2><p>在 Vue 中，我们常用的脚手架是 Vue-CLI 以及尤大大推荐的 Vite ；在 React 中，我们通常使用 creat-react-app（CRA）创建项目，当然 Vite 同样也支持我们创建 React 项目。</p>\n<h3 id=\"使用-CRA\"><a href=\"#使用-CRA\" class=\"headerlink\" title=\"使用 CRA\"></a>使用 CRA</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npx create-react-app my-react-app<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用-Vite\"><a href=\"#使用-Vite\" class=\"headerlink\" title=\"使用 Vite\"></a>使用 Vite</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn create vite my-react-app --template react<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"其他创建方式\"><a href=\"#其他创建方式\" class=\"headerlink\" title=\"其他创建方式\"></a>其他创建方式</h3><p>参考 <a href=\"https://zh-hans.react.dev/learn/start-a-new-react-project\">React | 启动一个新项目</a></p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>值得注意的是使用 cra 创建的项目中，JS 文件就是正常的<code>.js</code>后缀，而 Vite 创建项目的文件后缀是<code>.jsx</code>。</p>\n<ul>\n<li>Vite 基于 ESModule，它提供了对 JSX 的原生支持，使用<code>.jsx</code>作为源文件的后缀，以便我们直接编写 JSX 语法的 React 组件。</li>\n<li>CRA 默认没有启用 JSX 预处理器，而是通过 Babel 和 Webpack 等工具来处理 JSX 语法。</li>\n</ul>\n<p>在写法上没有区别，不用考虑太多。</p>\n<h2 id=\"项目目录\"><a href=\"#项目目录\" class=\"headerlink\" title=\"项目目录\"></a>项目目录</h2><p>以下是 Vite 创建的项目目录结构：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af365556f65d4b75ba8b3656d79b105f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=195&h=338&s=14100&e=png&b=252526\" alt=\"image.png\"></p>\n<p>其中入口文件是<code>main.jsx</code>，如果是 CRA 创建的项目则是<code>index.js</code>。</p>\n<p>让我来看看它的代码：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ReactDOM</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-dom/client&quot;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">App</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./App.jsx&quot;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;./index.css&quot;</span>;<br><br><span class=\"hljs-title class_\">ReactDOM</span>.<span class=\"hljs-title function_\">createRoot</span>(<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;root&quot;</span>)).<span class=\"hljs-title function_\">render</span>(<br>  <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">React.StrictMode</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> /&gt;</span></span><br><span class=\"language-xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">React.StrictMode</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure>\n\n<p>这跟 Vue 的<code>main.js</code>的作用一样，将<code>App</code>根组件挂载到<code>id</code>为<code>root</code>的 DOM 元素上。</p>\n<p><strong>我猜你可能会想，这里引入一个 React 又引入一个 ReactDom 干嘛，它们两个有什么区别？</strong></p>\n<p>我们在<code>package.json</code>中也可以看到这两个依赖。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0df638d47a88442e8f77dabd6a41a1c0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=292&h=115&s=5549&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>这是因为 React 作者将 React 源码拆成了两部分：</p>\n<ul>\n<li><p><code>React</code> 库提供构建用户界面的各种 API 和组件，比如创建 React 组件、处理组件生命周期、状态管理、事件处理等核心功能。</p>\n</li>\n<li><p><code>ReactDom</code> 库是 React 的 DOM 渲染器，只负责将 React 组件渲染到浏览器的 DOM 中，提供一些管理组件的更新、挂载和卸载等操作的 API。</p>\n</li>\n</ul>\n<h2 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h2><p>我们<code>return</code>出来的 JSX 模板，如果要换行的话，需要用<code>()</code>包裹一下，然后这个 JSX 表达式必须具有一个父元素，什么意思呢？就是下面这种写法会报错，JSX 表达式规定了最外层只能有一个父元素，这种情况下我们一般会在最外面套一个<code>div</code>或者空标签<code>&lt;&gt;&lt;/&gt;</code>。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">return</span> (<br>  &#123;<span class=\"hljs-comment\">/*报错*/</span>&#125;<br>  &lt;div&gt;<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br>  &lt;/div&gt;<br>  <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>你好<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>)<br><br><span class=\"hljs-keyword\">return</span> (<br>  <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>你好<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">  <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>)<br></code></pre></td></tr></table></figure>\n\n<p>在 JSX 表达式允许我们只能在<code>&#123;&#125;</code>中写 JS 代码</p>\n<h2 id=\"创建组件\"><a href=\"#创建组件\" class=\"headerlink\" title=\"创建组件\"></a>创建组件</h2><p>在 React 中有两种创建组件的方式，函数组件和类组件，类组件是。现在界内大部分都使用函数组件，函数组件相比于类组件，性能更好，React 18 虽然还支持类组件，但是更推荐使用函数组件。</p>\n<h3 id=\"函数组件\"><a href=\"#函数组件\" class=\"headerlink\" title=\"函数组件\"></a>函数组件</h3><h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><p>函数组件是通过函数来定义的，函数的返回值是 JSX 模板，可以使用 <code>function</code> 关键字或箭头函数定义。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello Function Component<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d21eaa75fc34fcaac6638fb39e28de6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=454&h=157&s=8769&e=png&b=ffffff\" alt=\"image.png\"></p>\n<h4 id=\"状态管理\"><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h4><p>函数组件通过 React 提供的 Hooks 函数（官方提供的一般以<code>use</code>开头的 API），比如我们通常使用<code>useState</code> 钩子来管理状态。</p>\n<p><code>useState</code> 返回一个由两个值组成的数组：</p>\n<ol>\n<li>当前的<code>state</code>，初始值为传递给<code>useState</code>的参数。</li>\n<li><code>set</code>  函数，它可以让你将<code>state</code>更新为不同的值并触发重新渲染。</li>\n</ol>\n<p>🙋‍ 举个例子 🌰，这里我们实现一个计数器，点击<code>count</code>自增<code>1</code>：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; useState &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">let</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);<br>  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handleClick</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>    <span class=\"hljs-title function_\">setCount</span>(count + <span class=\"hljs-number\">1</span>);<br>  &#125;;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;handleClick&#125;</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这里我们解构得到<code>count</code>跟它的<code>set</code>方法，我们每次点击触发<code>handleClick</code>函数，函数内部通过<code>set</code>方法修改状态并重新渲染。</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91d93bd5149b47a095840c25ac501823~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=538&h=272&s=25427&e=gif&f=27&b=fefefe\" alt=\"GIF 2024-6-6 17-23-01.gif\" width=\"50%\" />\n\n<h4 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h4><p>React 16.8 之前，函数组件没有生命周期方法，但是从 React 16.8 开始，可以使用<code>useEffect</code> 这个 Hook 函数来执行类似生命周期的逻辑，用于替代 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code>这些方法。</p>\n<h5 id=\"useEffect\"><a href=\"#useEffect\" class=\"headerlink\" title=\"useEffect\"></a>useEffect</h5><p><code>useEffect</code>是 React 中用于执行副作用操作的 Hook，并且具有类似于生命周期方法的功能。</p>\n<p><code>useEffect</code> 接受两个参数：副作用函数和依赖数组。</p>\n<ol>\n<li><strong>副作用函数</strong>：第一个参数是一个函数，用于执行副作用操作。</li>\n<li><strong>依赖数组</strong>：第二个参数是一个数组，包含了副作用函数中所依赖的变量。如果省略这个参数，那么副作用函数会在每次组件重新渲染时都执行，可以充当<code>componentDidUpdate</code>这个生命周期；如果传入空数组 <code>[]</code>，则副作用函数只会在组件挂载时执行，相当于 <code>componentDidMount</code>；如果依赖数组中包含了某些变量，则只有这些变量发生变化时，副作用函数才会重新执行。如果我们在其中<code>return</code>一个函数，这个函数将会在组件卸载时除非，相当于<code>componentWillUnmount</code>。</li>\n</ol>\n<p>我总结了一下副作用函数执行时机与依赖项的关系如下：</p>\n<table>\n<thead>\n<tr>\n<th>依赖项</th>\n<th>副作用函数执行时机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>没有依赖项</td>\n<td>组件初始渲染 + 组件更新时执行</td>\n</tr>\n<tr>\n<td>空数组依赖项</td>\n<td>只在初次渲染时执行一次</td>\n</tr>\n<tr>\n<td>添加特定依赖项</td>\n<td>组件初始渲染 + 特定依赖项变化时执行</td>\n</tr>\n</tbody></table>\n<p>举例说明 🌰：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">//没有依赖项数组</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, &#123; useState, useEffect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);<br>  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;组件更新&quot;</span>);<br>  &#125;);<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>点击了 &#123;count&#125; 次<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;点击<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这里我们没有依赖项数组，刷新页面，组件初次渲染打印（打印两次是因为 React 源码自己执行了一次，应该是跟严格模式有关，这里我们不用深究），每次点击都会打印，可以充当<code>componentDidUpdate</code>生命周期。</p>\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ed443e30b2e45629bbe20cf6064e775~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=696&h=468&s=52307&e=gif&f=21&b=fefefe\" alt=\"GIF 2024-6-6 19-32-33.gif\" width=\"50%\" />\n\n<hr>\n<p>依赖项为空数组呢？</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">//依赖项为空数组呢？</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, &#123; useState, useEffect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);<br>  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;组件挂载&quot;</span>);<br>  &#125;, []);<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>点击了 &#123;count&#125; 次<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;点击<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这里我们的依赖项数组为空，刷新页面，只在初次渲染时打印，点击不打印，可以充当<code>componentDidMount</code>生命周期。</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/746f9e4ce2254e8cbe223791767e28c3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=696&h=468&s=68204&e=gif&f=28&b=fefefe\" alt=\"GIF 2024-6-6 19-33-14.gif\" width=\"50%\" />\n\n<hr>\n<p>依赖项数组不为空呢？</p>\n<p>很容易联想到，如果数组里面有会发生改变的项，则会触发副作用函数，否则不会触发，这里就不演示了。</p>\n<hr>\n<p>来看最后一个，在副作用函数中<code>return</code>一个函数：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, &#123; useState, useEffect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);<br><br>  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;组件更新&quot;</span>);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;组件卸载&quot;</span>);<br>    &#125;;<br>  &#125;, [count]);<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>点击了 &#123;count&#125; 次<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;点击<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这里我们<code>return</code>一个函数打印卸载，表示组件卸载时会执行的操作。我们通常在这里进行组件卸载时的执行的操作，可以充当<code>componentWillUnmount</code>生命周期。</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84e36073cdfe4f27b271fd53ded4a814~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=800&h=567&s=51838&e=gif&f=22&b=fefefe\" alt=\"GIF 2024-6-6 19-51-19.gif\" width=\"50%\" />\n\n<p>一个很常见的例子 🌰：</p>\n<p>我们通常在组件卸载时清除一些副作用函数，如定时器</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, &#123; useState, useEffect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);<br><br>  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> timer = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-title function_\">setCount</span>(count + <span class=\"hljs-number\">1</span>);<br>    &#125;, <span class=\"hljs-number\">1000</span>);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-built_in\">clearInterval</span>(timer);<br>    &#125;;<br>  &#125;, [count]);<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>点击了 &#123;count&#125; 次<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;点击<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;<br></code></pre></td></tr></table></figure>\n\n<p>如果我们不及时清除定时器，会导致资源浪费。</p>\n<p>而且由于 <code>setCount</code> 是一个异步操作，它不会立即更新 <code>count</code> 的值，而是在下一次渲染时才会生效。因此，即使你设置了定时器每隔一秒钟执行一次，但 <code>count</code> 的值并不会每秒增加一次。相反，当定时器触发时，<code>count</code> 的值仍然是上一次渲染时的值。等一段时间后就会看到下面这个情况：</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29923fc094d648879b1013c2c93e0f02~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=572&h=324&s=27666&e=gif&f=18&b=fefefe\" alt=\"GIF 2024-6-6 20-06-38.gif\" width=\"50%\" />\n\n<h3 id=\"类组件\"><a href=\"#类组件\" class=\"headerlink\" title=\"类组件\"></a>类组件</h3><p>😁<strong>可以不用但不能不学！</strong></p>\n<h4 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h4><p>类组件通过继承 <code>React.Component</code> 或其子类来创建，类组件中有一个 <code>render()</code> 方法，用来返回 JSX 语法。</p>\n<p>拿代码说事：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Component</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">App</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Component</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">super</span>();<br>  &#125;<br>  <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> (<br>      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello Class Component<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;<br></code></pre></td></tr></table></figure>\n\n<p>类组件的语法就是声明一个类，这个类继承<code>React.Component</code> 或者子类，<code>render()</code>方法返回 JSX 模板。然后将我们的 App 组件挂载到页面上就可以了。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04452e5cd75c48dc9e2c1f9cd6f7d1a2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=458&h=167&s=9583&e=png&b=ffffff\" alt=\"image.png\"></p>\n<h4 id=\"状态管理-1\"><a href=\"#状态管理-1\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h4><p>类组件拥有内部状态<code>state</code>，通过 <code>this.state</code> 来访问组件的状态，使用 <code>setState()</code>方法来更新状态，触发组件的重新渲染。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Component</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">App</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Component</span>&#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-variable language_\">super</span>();<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span>=&#123;<br>      <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;张三&quot;</span><br>    &#125;<br>  &#125;<br>  <span class=\"hljs-title function_\">handleClick</span>(<span class=\"hljs-params\"></span>)&#123;<br><br>  &#125;<br>  <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-keyword\">return</span>(<br>      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span>=&gt;</span>this.setState(&#123;name:&quot;李四&quot;&#125;)&gt;&#123;this.state.name&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;<br></code></pre></td></tr></table></figure>\n\n<p>我们绑定<code>onClick</code>事件，当点击时修改<code>name</code>的状态。</p>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f05edfaefa984490ba816a83af73136d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=467&h=332&s=17537&e=gif&f=5&b=fefefe\" alt=\"GIF 2024-6-6 17-04-25.gif\" width=\"30%\" />\n\n<h4 id=\"生命周期-1\"><a href=\"#生命周期-1\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h4><p>类组件中可以使用生命周期方法，常见的有<code>componentDidMount</code>、<code>componentDidUpdate</code>、&#x3D;跟<code>componentWillUnmount</code>，它们分别对应 Vue3 中的 <code>onMounted</code>、<code>onUpdated</code> 跟 <code>onBeforeUnmount</code>。</p>\n<p>这个网站可以很清楚看到 React 的生命周期，<a href=\"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\">React 生命周期</a>，这里就不过多赘述。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c876571316c4779bf0528aca4cef60a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1180&h=424&s=40943&e=png&b=fbf8f7\" alt=\"image.png\"></p>\n<h3 id=\"组件通讯\"><a href=\"#组件通讯\" class=\"headerlink\" title=\"组件通讯\"></a>组件通讯</h3><p>在 Vue 中组件传值一般通过<code>props &amp; emit</code>、<code>provide &amp; inject</code>以及 Vue2 中的<code>EventBus</code>，或者我们可以直接使用状态管理工具<code>Vuex</code>或<code>Pinia</code>，React 其实大差不差，同样也有自己的状态管理工具。</p>\n<h4 id=\"父传子\"><a href=\"#父传子\" class=\"headerlink\" title=\"父传子\"></a>父传子</h4><p>父组件通过<code>props</code>传递任意的数字、字符串、布尔值、数组、对象、函数甚至是 JSX，子组件通过<code>props</code>参数接收。</p>\n<p>🙋‍♀️🌰：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Son</span> = (<span class=\"hljs-params\">props</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;props.name&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;props.age&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;props.cb()&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;props.child&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Father</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Son</span></span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&#123;</span>&quot;<span class=\"hljs-attr\">阳阳羊</span>&quot;&#125;</span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">      <span class=\"hljs-attr\">age</span>=<span class=\"hljs-string\">&#123;20&#125;</span></span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">      <span class=\"hljs-attr\">cb</span>=<span class=\"hljs-string\">&#123;function</span> <span class=\"hljs-attr\">cb</span>() &#123;</span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">        <span class=\"hljs-attr\">console.log</span>(<span class=\"hljs-attr\">123</span>);</span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">      &#125;&#125;</span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">      <span class=\"hljs-attr\">child</span>=<span class=\"hljs-string\">&#123;</span>&lt;<span class=\"hljs-attr\">span</span>&gt;</span>i am jsx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>&#125;</span><br><span class=\"language-xml\">    &gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Son</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f7493c702384844b509095a3f5f3972~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=789&h=415&s=27428&e=png&b=fefefe\" alt=\"image.png\" width=\"50%\" />\n\n<p>⚠️ 需要注意的是：子组件只能读取<code>props</code>中的数据，不能直接进行修改，父组件的数据只能由父组件修改，或者通过父组件传过来的函数进行修改。如果在子标签中嵌套元素，可以在子组件的<code>props.children</code>中获取。</p>\n<h4 id=\"子传父\"><a href=\"#子传父\" class=\"headerlink\" title=\"子传父\"></a>子传父</h4><p>子传父通过最原始的回调函数方式，父组件给子组件传一个函数，子组件调用这个函数然后传入实参，在函数内部用<code>set</code>方法修改父组件的状态。</p>\n<p>🙋‍♀️🌰：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Son</span> = (<span class=\"hljs-params\">props</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> props.cb(&quot;小羊&quot;)&#125;&gt;点击传递<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Father</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">let</span> [name, setName] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-string\">&quot;阳阳羊&quot;</span>);<br>  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-title function_\">cb</span> = (<span class=\"hljs-params\">name</span>) =&gt; &#123;<br>    <span class=\"hljs-title function_\">setName</span>(name);<br>  &#125;;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Son</span> <span class=\"hljs-attr\">cb</span>=<span class=\"hljs-string\">&#123;cb&#125;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Son</span>&gt;</span></span><br><span class=\"language-xml\">      &#123;name&#125;</span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44f24ffe31fa4c8b84aada591cf2e534~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=549&h=284&s=14214&e=gif&f=3&b=fdfdfd\" alt=\"GIF 2024-6-7 11-20-34.gif\" width=\"50%\" />\n\n<p>⚠️ 这里需要注意：<code>onClick</code>事件处理程序是一个函数，写成<code>onClick=&#123;() =&gt; props.cb(&#39;小羊&#39;)&#125;</code>时，实际上创建了一个匿名函数，当点击按钮时会调用这个函数，然后调用<code>props.cb(&#39;小羊&#39;)</code>，如果直接写成<code>onClick=&#123;props.cb(&#39;小羊&#39;)&#125;</code>，在渲染时就会立即调用<code>props.cb(&#39;小羊&#39;)</code>，而不是在点击时调用。</p>\n<h4 id=\"兄弟组件通信\"><a href=\"#兄弟组件通信\" class=\"headerlink\" title=\"兄弟组件通信\"></a>兄弟组件通信</h4><p>兄弟组件通信贯用手段就是<strong>状态提升</strong>，说白话就是将数据都交给父组件，然后父组件作为中间商派发给大家。</p>\n<p>🙋‍♀️🌰：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Son1</span> = (<span class=\"hljs-params\">props</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">      子组件1-</span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> props.cb(&quot;小羊&quot;)&#125;&gt;传给子组件2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Son2</span> = (<span class=\"hljs-params\">props</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>子组件2-&#123;props.name&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Father</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">let</span> [name, setName] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-string\">&quot;Son2&quot;</span>);<br>  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">cb</span> = (<span class=\"hljs-params\">newName</span>) =&gt; &#123;<br>    <span class=\"hljs-title function_\">setName</span>(newName);<br>  &#125;;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Son1</span> <span class=\"hljs-attr\">cb</span>=<span class=\"hljs-string\">&#123;cb&#125;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Son1</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Son2</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&#123;name&#125;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Son2</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>这里子<code>组件1</code>通过触发父组件传递过来的函数，并传递参数，然后父组件接收到参数修改数据源，传递给<code>组件2</code>。这样就完成了兄弟组件通信。</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eb12209347142b59eea4b418c9507dc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=547&h=273&s=24884&e=gif&f=6&b=fdfcfc\" alt=\"GIF 2024-6-7 11-16-47.gif\" width=\"50%\" />\n\n<h4 id=\"夸层组件通讯\"><a href=\"#夸层组件通讯\" class=\"headerlink\" title=\"夸层组件通讯\"></a>夸层组件通讯</h4><p>思路是将两个组件放在同一个上下文中就能实现数据共享。步骤如下：</p>\n<ol>\n<li>使用<code>createContext</code>方法创建一个上下文对象，将组件<code>Provider</code>，<code>Consumer</code>抛出</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-title class_\">Provider</span>, <span class=\"hljs-title class_\">Consumer</span> &#125; = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">createContext</span>();<br><br><span class=\"hljs-keyword\">export</span> &#123; <span class=\"hljs-title class_\">Provider</span>, <span class=\"hljs-title class_\">Consumer</span> &#125;;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>在顶层组件(App)中通过<code>Provider</code>组件提供数据</p>\n</li>\n<li><p>在底层组件(B)中通过<code>Consumer</code>组件获取对应数据</p>\n</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Provider</span>, <span class=\"hljs-title class_\">Consumer</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./provider&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">ComponentB</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Consumer</span>&gt;</span></span><br><span class=\"language-xml\">      &#123;(value) =&gt; (</span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>底层组件——&#123;value&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      )&#125;</span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Consumer</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-string\">&quot;顶层组件的数据&quot;</span>;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;value&#125;</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>顶层组件<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentB</span> /&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Provider</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>效果如下：</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c488273f449470fbfbdccb8e36b31d3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=813&h=369&s=31043&e=png&b=fefefe\" alt=\"image.png\" width=\"50%\" />\n\n<h4 id=\"状态管理工具\"><a href=\"#状态管理工具\" class=\"headerlink\" title=\"状态管理工具\"></a>状态管理工具</h4><p>常见的 React 状态管理工具有 Redux、Mobx、Rcoil 等等，如果有感兴趣的同学，我可以单独出一篇文章详细聊聊。本篇就不展开聊了。</p>\n<h2 id=\"自定义-Hooks\"><a href=\"#自定义-Hooks\" class=\"headerlink\" title=\"自定义 Hooks\"></a>自定义 Hooks</h2><p>除了 React 官方提供的一些 Hooks 之外，还允许我们自定义自己的 Hooks，我们需要遵循以下规则：</p>\n<ol>\n<li>声明以<code>use</code>开头的函数</li>\n<li>在函数体内封装可复用的逻辑</li>\n<li>把组件中使用到的状态<code>return</code>出去</li>\n<li>在哪里用到就在里面执行解构</li>\n</ol>\n<p>🙋‍♀️🌰：</p>\n<p>我们设计来设计一个开关 Hooks，作用是对值取反，从而控制元素的显示隐藏：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; useState &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">useToggle</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> [value, setValue] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">true</span>);<br>  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">toggle</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>    <span class=\"hljs-title function_\">setValue</span>(!value);<br>  &#125;;<br>  <span class=\"hljs-keyword\">return</span> [value, toggle];<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> [value, toggle] = <span class=\"hljs-title function_\">useToggle</span>();<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;value ? &quot;开&quot; : &quot;关&quot;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;toggle&#125;</span>&gt;</span>按钮<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这里我们借助<code>useState</code>进行封装，将需要用到的变量进行抛出，在需要使用的地方解构拿到，通过三目运算符进行显示隐藏。</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c183f8bc55224444b6bb384239bd4c08~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=613&h=369&s=29609&e=gif&f=12&b=fefefe\" alt=\"GIF 2024-6-7 12-07-46.gif\" width=\"50%\" />\n\n<h3 id=\"Hooks-使用规则\"><a href=\"#Hooks-使用规则\" class=\"headerlink\" title=\"Hooks 使用规则\"></a>Hooks 使用规则</h3><p>Hooks 并不是然后场景下都能用，像比如在类组件中是不能直接使用 Hooks 的，除非使用高阶函数进行包装，以及其他许多规则：</p>\n<ul>\n<li>不能在组件外部使用</li>\n<li>不能在判断语句中使用</li>\n</ul>\n<p>详见 <a href=\"https://zh-hans.react.dev/reference/rules/rules-of-hooks\">React 中文官网</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>还是那句话，不管是 Vue 跟 React 都有自己的优缺点，我们不能断言说哪个好哪个差，在我看来 Vue 更适合第一次接触前端框架的小白，它封装了许多 API，对新手很友好，上手即用；而 React 相对复杂，更考验开发者的思维，对于一些复杂需求能够自定义进行封装，更接近原生 JS 开发。大家按需求选择就好。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://zh-hans.react.dev/learn\">React-中文官网</a></p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>已将学习代码上传至 <a href=\"https://github.com/YangyangU/CodeSpace\">github</a>，欢迎大家学习指正！</p>\n"},{"title":"面试官：从输入URL到页面渲染，有哪些地方可以优化","date":"2024-04-27T08:00:00.000Z","index_img":"/img/面试.jpg","banner_img":"/img/default.png","_content":"\n## 前言\n\n春招在继续，面试不停息！最近也是被问到了标题上这个问题，好家伙，一个问题问到了 URL 到页面渲染的过程和性能优化，如果不熟悉这个过程的话，回答起来确实挺费劲，这篇文章就将带大家来捋一捋，争取回答的时候不卡壳 ~\n\n## 输入 URL 到页面渲染过程\n\n### 1.URL 解析\n\n首先浏览器会判断你输入的是一个合法的`URL`  还是一个待搜索的关键词，如果是关键词，则会将关键词发送给默认的搜索引擎，然后返回页面；如果是`URL`，则会对`URL`的结构进行解析。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56d345299ffd4a9da71e3bf11a6e3944~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=942&h=265&s=55934&e=png&b=fefefe)\n\n### 2.DNS 解析\n\n当浏览器解析出域名，它会向 DNS 服务器发送请求，获取相应域名对应的 IP 地址。\n\n- 首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表\n- 若没有命中，则继续搜索操作系统的 DNS 缓存\n- 若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果\n- 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询\n  - 首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器\n  - 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址\n  - 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址\n- 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来\n- 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来\n- 至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fafd1dd33e6d4fe389872eb4ec215da0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1013&h=730&s=78701&e=png&b=ffffff)\n\n### 3.TCP 三次握手建立连接\n\n浏览器向服务器发起 TCP 连接请求，与服务器建立连接。\n\n1.  **客户端向服务器发送连接请求**：客户端首先向服务器发送一个 SYN 报文段，指定客户端的初始序列号，并设置 SYN 标志位为 1，表示请求建立连接。\n1.  **服务器响应确认连接请求**：服务器接收到客户端的 SYN 报文段后，会向客户端发送一个 ACK 报文段作为确认，同时也发送一个 SYN 报文段。服务器在 SYN 报文段中指定服务器的初始序列号，并设置 SYN 和 ACK 标志位为 1，表示确认客户端的连接请求，并请求建立连接。\n1.  **客户端确认连接**：客户端收到服务器的 SYN 报文段后，会向服务器发送一个 ACK 报文段作为确认。客户端设置 ACK 标志位为 1，表示确认服务器的连接请求，建立连接。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8355f9f227574d9ca85e5c76e9cfb872~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=864&h=439&s=265977&e=png&b=fdfdfd)\n\n### 4.发起 HTTP 请求\n\n当建立 TCP 连接之后，浏览器就可以发送  HTTP 请求到目标服务器，请求的内容包括：\n\n- **请求行：** 请求方法、请求的 URL、HTTP 协议的版本\n- **请求头部：** 包含了关于客户端、请求、所需资源等的信息（Host、User-Agent 等等）\n- **请求体**（仅在向服务器发送数据时才有）：包含了要发送给服务器的数据，如表单数据、JSON 数据等。\n\n### 5.服务器响应\n\n服务器接收到请求后，返回相应的资源数据，响应的内容包括：\n\n- **状态行：** 包含了 HTTP 协议的版本、状态码和状态消息。\n- **响应头：** 包含了关于响应、服务器、所返回资源等的信息（Content-Type、Content-Length 等等）。\n- **响应体：** 包含服务器返回给客户端的实际数据，如 HTML 页面、图片等。\n\n### 6.浏览器解析渲染页面\n\n#### 1.构建 DOM 树\n\n1.  **词法分析** ：\n    - 浏览器接收到 HTML 字符串后，会将其分解成一系列的标记（tokens）。\n    - 标记包括开始标签、结束标签、属性、文本内容等。\n1.  **解析标记** ：\n    - 浏览器根据词法分析得到的标记，开始解析这些标记并构建 DOM 节点。\n    - 当解析到开始标签时，浏览器创建对应的元素节点，并将其加入 DOM 树中。\n    - 当解析到属性时，浏览器将属性添加到对应的元素节点上。\n    - 当解析到文本内容时，浏览器创建文本节点，并将其加入到 DOM 树中。\n1.  **构建 DOM 树**：\n    - 在解析过程中，浏览器会根据标记的嵌套关系构建出完整的 DOM 树结构。\n    - 根据 HTML 文档的层次结构，浏览器将创建的元素节点和文本节点按照其在文档中的位置进行组织，形成一棵树状结构。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/608838c921b24d74a2bff2c3c2d8adaa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=800&h=443&s=214016&e=png&b=fefdfd)\n\n#### 2.构建 CSSOM 树\n\n1.  **词法分析** ：\n    - 浏览器接收到 CSS 字符串后，会将其分解成一系列的标记（tokens）。\n    - 标记包括选择器、属性、属性值等。\n1.  **解析样式表** ：\n    - 浏览器根据词法分析得到的标记，开始解析这些标记并构建 CSSOM 节点。\n    - 当解析到选择器时，浏览器创建对应的规则节点，并将其加入 CSSOM 树中。\n    - 当解析到属性和属性值时，浏览器将其添加到对应的规则节点上。\n1.  **计算优先级** ：\n    - 在解析过程中，浏览器会确定样式的优先级。\n1.  **处理样式继承** ：\n    - 浏览器会处理样式的继承关系，将父元素的样式属性应用到子元素上。\n1.  **解析样式表引用** ：\n    - 如果样式表中包含了 `@import` 规则，浏览器会解析引入的外部样式表，并将其内容合并到当前的 CSSOM 树中。\n1.  **合并样式表（Merging Stylesheets）** ：\n    - 如果页面中包含多个样式表，浏览器会将这些样式表合并成一个统一的 CSSOM 树。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/395b713f42e54922bb733d37f6a0f574~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=582&h=299&s=123760&e=png&b=fbfafa)\n\n#### 3.构建渲染树\n\n浏览器将 DOM 树和 CSSOM 树合并成渲染树（Render Tree）。\n\n1.  **从 DOM 树和 CSSOM 树中选择可见元素**：\n    - 首先，浏览器需要从 DOM 树和 CSSOM 树中选择出在页面中可见的元素。\n    - 不可见的元素，如 `<head>`、`script` 标签内的内容等，不会包含在渲染树中。\n1.  **匹配样式规则**：\n    - 对于渲染树中的每个可见元素，浏览器会根据其标签和属性等信息，匹配适用的 CSS 样式规则。\n1.  **计算最终样式**：\n    - 当一个元素匹配到多个 CSS 样式规则时，浏览器会根据优先级和层叠规则计算出最终的样式值。\n1.  **生成渲染树**：\n    - 当所有可见元素都被匹配样式并加入渲染树后，渲染树的构建过程就完成了。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8798bcc009a4c0e8d1b41b25b5a6886~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1726&h=840&s=332657&e=png&b=fdfdfd)\n\n#### 4.回流\n\n有了渲染树，再接着就要进入回流（Reflow），也称为重新布局（Layout），浏览器根据渲染树中每个节点的布局信息，计算各个节点在页面中的位置和大小。当页面中的元素尺寸、位置或可见性发生变化时，浏览器需要重新计算并更新页面的布局信息。\n\n#### 5.重绘\n\n回流一定伴随着重绘（Repaint），重绘是指浏览器根据元素的样式信息重新绘制页面的过程，而不涉及布局的改变。浏览器根据布局信息，将页面内容绘制到屏幕上。当元素的样式属性（如颜色、背景色、文本等）发生变化时，会触发重绘操作。\n\n## 性能优化\n\n### 1.DNS 解析优化\n\n- 使用快速的 DNS 服务器，可以借助 CDN ，减少域名解析时间。\n- 减少不必要的域名解析，合并资源到尽可能少的域名。\n\n### 2.建立 TCP 连接优化\n\n- 使用 HTTP/2 以上版本协议，充分利用多路复用功能，减少连接建立时间。\n- 减少不必要的 TCP 连接，通过合并或内联资源来减少连接建立次数。\n\n### 3.发起 HTTP 请求优化\n\n- 减少 HTTP 请求次数，通过合并或内联资源来减少请求次数（比如图片资源可以考虑懒加载图片或使用精灵图）。\n- 使用资源预加载和预解析来预先加载页面所需资源。`<link rel=\"preload\">` 或 `<link rel=\"prefetch\">`\n\n### 4.服务器响应优化\n\n- 使用 CDN 加速资源传输，提高服务器响应速度。\n- 启用服务器端缓存，缓存动态生成的内容或数据库查询结果，减少服务器压力和响应时间。\n\n### 5.资源下载优化\n\n- 减小资源文件大小，如优化图片（使用 WebP 格式）、压缩 JavaScript 和 CSS。\n- 使用浏览器缓存（Cache-Control、Expires），减少对服务器的请求，尤其是静态资源。\n- 使用异步加载 `<script async>` 和 `<script defer>`\n\n### 6.HTML 解析优化\n\n- 编写语义化的 HTML，避免过多嵌套和冗余标签。\n- 减小 HTML 文件大小，去除不必要的空格和注释。\n\n### 7.CSS 解析优化\n\n- 减少 CSS 文件大小，删除不必要的样式和选择器。\n- 避免使用昂贵的 CSS 选择器（尽量给每一个标签给定类名，不要嵌套），优化样式表性能。\n\n### 8.构建渲染树优化\n\n- 减少不必要的 DOM 操作，优化 JS 执行性能。\n- 避免使用 JS 动态修改样式，尽量使用 CSS 实现动画效果。\n\n### 9.回流优化\n\n- 使用新布局（Flexbox 或 Grid 布局），减少复杂的布局计算。\n- 避免频繁修改样式属性，尽量使用批量修改或者使用类名切换的方式。\n\n### 10.重绘优化\n\n- 使用 transform 和 opacity 属性来触发硬件加速，减少页面重绘次数。\n- 避免在页面加载过程中阻塞渲染，尽快将页面内容呈现给用户。\n- 如果需要操作 DOM，先让 DOM 脱离文档流，再修改，再带回文档流（或者使用 DocumentFragment），减少回流重绘。\n\n## 参考\n\n- [「一道面试题」输入 URL 到渲染全面梳理中-页面渲染篇 - 掘金 (juejin.cn)](https://juejin.cn/post/6844904134307495943?searchId=20240426205357E60AB4CA7A393DAA106E#heading-26)\n- [从 URL 输入到页面展现到底发生什么？ - 掘金 (juejin.cn)](https://juejin.cn/post/6844903784229896199?searchId=20240426205107A43476DE1FB412A9CC53#heading-15)\n- [面试官：说说地址栏输入 URL 敲下回车后发生了什么? | web 前端面试 - 面试官系列 (vue3js.cn)](https://vue3js.cn/interview/http/after_url.html#%E4%BA%8C%E3%80%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90)\n\n## 最后\n\n已将学习代码上传至 [github](https://github.com/YangyangU/CodeSpace)，欢迎大家学习指正！\n","source":"_posts/面试官：从输入URL到页面渲染，有哪些地方可以优化.md","raw":"---\ntitle: 面试官：从输入URL到页面渲染，有哪些地方可以优化\ndate: 2024-04-27 16:00:00\ntags: [性能优化]\ncategories: 性能优化\nindex_img: /img/面试.jpg\nbanner_img: /img/default.png\n---\n\n## 前言\n\n春招在继续，面试不停息！最近也是被问到了标题上这个问题，好家伙，一个问题问到了 URL 到页面渲染的过程和性能优化，如果不熟悉这个过程的话，回答起来确实挺费劲，这篇文章就将带大家来捋一捋，争取回答的时候不卡壳 ~\n\n## 输入 URL 到页面渲染过程\n\n### 1.URL 解析\n\n首先浏览器会判断你输入的是一个合法的`URL`  还是一个待搜索的关键词，如果是关键词，则会将关键词发送给默认的搜索引擎，然后返回页面；如果是`URL`，则会对`URL`的结构进行解析。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56d345299ffd4a9da71e3bf11a6e3944~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=942&h=265&s=55934&e=png&b=fefefe)\n\n### 2.DNS 解析\n\n当浏览器解析出域名，它会向 DNS 服务器发送请求，获取相应域名对应的 IP 地址。\n\n- 首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表\n- 若没有命中，则继续搜索操作系统的 DNS 缓存\n- 若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果\n- 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询\n  - 首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器\n  - 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址\n  - 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址\n- 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来\n- 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来\n- 至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fafd1dd33e6d4fe389872eb4ec215da0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1013&h=730&s=78701&e=png&b=ffffff)\n\n### 3.TCP 三次握手建立连接\n\n浏览器向服务器发起 TCP 连接请求，与服务器建立连接。\n\n1.  **客户端向服务器发送连接请求**：客户端首先向服务器发送一个 SYN 报文段，指定客户端的初始序列号，并设置 SYN 标志位为 1，表示请求建立连接。\n1.  **服务器响应确认连接请求**：服务器接收到客户端的 SYN 报文段后，会向客户端发送一个 ACK 报文段作为确认，同时也发送一个 SYN 报文段。服务器在 SYN 报文段中指定服务器的初始序列号，并设置 SYN 和 ACK 标志位为 1，表示确认客户端的连接请求，并请求建立连接。\n1.  **客户端确认连接**：客户端收到服务器的 SYN 报文段后，会向服务器发送一个 ACK 报文段作为确认。客户端设置 ACK 标志位为 1，表示确认服务器的连接请求，建立连接。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8355f9f227574d9ca85e5c76e9cfb872~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=864&h=439&s=265977&e=png&b=fdfdfd)\n\n### 4.发起 HTTP 请求\n\n当建立 TCP 连接之后，浏览器就可以发送  HTTP 请求到目标服务器，请求的内容包括：\n\n- **请求行：** 请求方法、请求的 URL、HTTP 协议的版本\n- **请求头部：** 包含了关于客户端、请求、所需资源等的信息（Host、User-Agent 等等）\n- **请求体**（仅在向服务器发送数据时才有）：包含了要发送给服务器的数据，如表单数据、JSON 数据等。\n\n### 5.服务器响应\n\n服务器接收到请求后，返回相应的资源数据，响应的内容包括：\n\n- **状态行：** 包含了 HTTP 协议的版本、状态码和状态消息。\n- **响应头：** 包含了关于响应、服务器、所返回资源等的信息（Content-Type、Content-Length 等等）。\n- **响应体：** 包含服务器返回给客户端的实际数据，如 HTML 页面、图片等。\n\n### 6.浏览器解析渲染页面\n\n#### 1.构建 DOM 树\n\n1.  **词法分析** ：\n    - 浏览器接收到 HTML 字符串后，会将其分解成一系列的标记（tokens）。\n    - 标记包括开始标签、结束标签、属性、文本内容等。\n1.  **解析标记** ：\n    - 浏览器根据词法分析得到的标记，开始解析这些标记并构建 DOM 节点。\n    - 当解析到开始标签时，浏览器创建对应的元素节点，并将其加入 DOM 树中。\n    - 当解析到属性时，浏览器将属性添加到对应的元素节点上。\n    - 当解析到文本内容时，浏览器创建文本节点，并将其加入到 DOM 树中。\n1.  **构建 DOM 树**：\n    - 在解析过程中，浏览器会根据标记的嵌套关系构建出完整的 DOM 树结构。\n    - 根据 HTML 文档的层次结构，浏览器将创建的元素节点和文本节点按照其在文档中的位置进行组织，形成一棵树状结构。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/608838c921b24d74a2bff2c3c2d8adaa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=800&h=443&s=214016&e=png&b=fefdfd)\n\n#### 2.构建 CSSOM 树\n\n1.  **词法分析** ：\n    - 浏览器接收到 CSS 字符串后，会将其分解成一系列的标记（tokens）。\n    - 标记包括选择器、属性、属性值等。\n1.  **解析样式表** ：\n    - 浏览器根据词法分析得到的标记，开始解析这些标记并构建 CSSOM 节点。\n    - 当解析到选择器时，浏览器创建对应的规则节点，并将其加入 CSSOM 树中。\n    - 当解析到属性和属性值时，浏览器将其添加到对应的规则节点上。\n1.  **计算优先级** ：\n    - 在解析过程中，浏览器会确定样式的优先级。\n1.  **处理样式继承** ：\n    - 浏览器会处理样式的继承关系，将父元素的样式属性应用到子元素上。\n1.  **解析样式表引用** ：\n    - 如果样式表中包含了 `@import` 规则，浏览器会解析引入的外部样式表，并将其内容合并到当前的 CSSOM 树中。\n1.  **合并样式表（Merging Stylesheets）** ：\n    - 如果页面中包含多个样式表，浏览器会将这些样式表合并成一个统一的 CSSOM 树。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/395b713f42e54922bb733d37f6a0f574~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=582&h=299&s=123760&e=png&b=fbfafa)\n\n#### 3.构建渲染树\n\n浏览器将 DOM 树和 CSSOM 树合并成渲染树（Render Tree）。\n\n1.  **从 DOM 树和 CSSOM 树中选择可见元素**：\n    - 首先，浏览器需要从 DOM 树和 CSSOM 树中选择出在页面中可见的元素。\n    - 不可见的元素，如 `<head>`、`script` 标签内的内容等，不会包含在渲染树中。\n1.  **匹配样式规则**：\n    - 对于渲染树中的每个可见元素，浏览器会根据其标签和属性等信息，匹配适用的 CSS 样式规则。\n1.  **计算最终样式**：\n    - 当一个元素匹配到多个 CSS 样式规则时，浏览器会根据优先级和层叠规则计算出最终的样式值。\n1.  **生成渲染树**：\n    - 当所有可见元素都被匹配样式并加入渲染树后，渲染树的构建过程就完成了。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8798bcc009a4c0e8d1b41b25b5a6886~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1726&h=840&s=332657&e=png&b=fdfdfd)\n\n#### 4.回流\n\n有了渲染树，再接着就要进入回流（Reflow），也称为重新布局（Layout），浏览器根据渲染树中每个节点的布局信息，计算各个节点在页面中的位置和大小。当页面中的元素尺寸、位置或可见性发生变化时，浏览器需要重新计算并更新页面的布局信息。\n\n#### 5.重绘\n\n回流一定伴随着重绘（Repaint），重绘是指浏览器根据元素的样式信息重新绘制页面的过程，而不涉及布局的改变。浏览器根据布局信息，将页面内容绘制到屏幕上。当元素的样式属性（如颜色、背景色、文本等）发生变化时，会触发重绘操作。\n\n## 性能优化\n\n### 1.DNS 解析优化\n\n- 使用快速的 DNS 服务器，可以借助 CDN ，减少域名解析时间。\n- 减少不必要的域名解析，合并资源到尽可能少的域名。\n\n### 2.建立 TCP 连接优化\n\n- 使用 HTTP/2 以上版本协议，充分利用多路复用功能，减少连接建立时间。\n- 减少不必要的 TCP 连接，通过合并或内联资源来减少连接建立次数。\n\n### 3.发起 HTTP 请求优化\n\n- 减少 HTTP 请求次数，通过合并或内联资源来减少请求次数（比如图片资源可以考虑懒加载图片或使用精灵图）。\n- 使用资源预加载和预解析来预先加载页面所需资源。`<link rel=\"preload\">` 或 `<link rel=\"prefetch\">`\n\n### 4.服务器响应优化\n\n- 使用 CDN 加速资源传输，提高服务器响应速度。\n- 启用服务器端缓存，缓存动态生成的内容或数据库查询结果，减少服务器压力和响应时间。\n\n### 5.资源下载优化\n\n- 减小资源文件大小，如优化图片（使用 WebP 格式）、压缩 JavaScript 和 CSS。\n- 使用浏览器缓存（Cache-Control、Expires），减少对服务器的请求，尤其是静态资源。\n- 使用异步加载 `<script async>` 和 `<script defer>`\n\n### 6.HTML 解析优化\n\n- 编写语义化的 HTML，避免过多嵌套和冗余标签。\n- 减小 HTML 文件大小，去除不必要的空格和注释。\n\n### 7.CSS 解析优化\n\n- 减少 CSS 文件大小，删除不必要的样式和选择器。\n- 避免使用昂贵的 CSS 选择器（尽量给每一个标签给定类名，不要嵌套），优化样式表性能。\n\n### 8.构建渲染树优化\n\n- 减少不必要的 DOM 操作，优化 JS 执行性能。\n- 避免使用 JS 动态修改样式，尽量使用 CSS 实现动画效果。\n\n### 9.回流优化\n\n- 使用新布局（Flexbox 或 Grid 布局），减少复杂的布局计算。\n- 避免频繁修改样式属性，尽量使用批量修改或者使用类名切换的方式。\n\n### 10.重绘优化\n\n- 使用 transform 和 opacity 属性来触发硬件加速，减少页面重绘次数。\n- 避免在页面加载过程中阻塞渲染，尽快将页面内容呈现给用户。\n- 如果需要操作 DOM，先让 DOM 脱离文档流，再修改，再带回文档流（或者使用 DocumentFragment），减少回流重绘。\n\n## 参考\n\n- [「一道面试题」输入 URL 到渲染全面梳理中-页面渲染篇 - 掘金 (juejin.cn)](https://juejin.cn/post/6844904134307495943?searchId=20240426205357E60AB4CA7A393DAA106E#heading-26)\n- [从 URL 输入到页面展现到底发生什么？ - 掘金 (juejin.cn)](https://juejin.cn/post/6844903784229896199?searchId=20240426205107A43476DE1FB412A9CC53#heading-15)\n- [面试官：说说地址栏输入 URL 敲下回车后发生了什么? | web 前端面试 - 面试官系列 (vue3js.cn)](https://vue3js.cn/interview/http/after_url.html#%E4%BA%8C%E3%80%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90)\n\n## 最后\n\n已将学习代码上传至 [github](https://github.com/YangyangU/CodeSpace)，欢迎大家学习指正！\n","slug":"面试官：从输入URL到页面渲染，有哪些地方可以优化","published":1,"updated":"2024-09-09T15:30:35.432Z","_id":"clyww1il3000040v653arhv7b","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>春招在继续，面试不停息！最近也是被问到了标题上这个问题，好家伙，一个问题问到了 URL 到页面渲染的过程和性能优化，如果不熟悉这个过程的话，回答起来确实挺费劲，这篇文章就将带大家来捋一捋，争取回答的时候不卡壳 ~</p>\n<h2 id=\"输入-URL-到页面渲染过程\"><a href=\"#输入-URL-到页面渲染过程\" class=\"headerlink\" title=\"输入 URL 到页面渲染过程\"></a>输入 URL 到页面渲染过程</h2><h3 id=\"1-URL-解析\"><a href=\"#1-URL-解析\" class=\"headerlink\" title=\"1.URL 解析\"></a>1.URL 解析</h3><p>首先浏览器会判断你输入的是一个合法的<code>URL</code>  还是一个待搜索的关键词，如果是关键词，则会将关键词发送给默认的搜索引擎，然后返回页面；如果是<code>URL</code>，则会对<code>URL</code>的结构进行解析。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56d345299ffd4a9da71e3bf11a6e3944~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=942&h=265&s=55934&e=png&b=fefefe\" alt=\"image.png\"></p>\n<h3 id=\"2-DNS-解析\"><a href=\"#2-DNS-解析\" class=\"headerlink\" title=\"2.DNS 解析\"></a>2.DNS 解析</h3><p>当浏览器解析出域名，它会向 DNS 服务器发送请求，获取相应域名对应的 IP 地址。</p>\n<ul>\n<li>首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表</li>\n<li>若没有命中，则继续搜索操作系统的 DNS 缓存</li>\n<li>若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果</li>\n<li>若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询<ul>\n<li>首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器</li>\n<li>本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址</li>\n<li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li>\n</ul>\n</li>\n<li>本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</li>\n<li>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来</li>\n<li>至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fafd1dd33e6d4fe389872eb4ec215da0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1013&h=730&s=78701&e=png&b=ffffff\" alt=\"image.png\"></p>\n<h3 id=\"3-TCP-三次握手建立连接\"><a href=\"#3-TCP-三次握手建立连接\" class=\"headerlink\" title=\"3.TCP 三次握手建立连接\"></a>3.TCP 三次握手建立连接</h3><p>浏览器向服务器发起 TCP 连接请求，与服务器建立连接。</p>\n<ol>\n<li><strong>客户端向服务器发送连接请求</strong>：客户端首先向服务器发送一个 SYN 报文段，指定客户端的初始序列号，并设置 SYN 标志位为 1，表示请求建立连接。</li>\n<li><strong>服务器响应确认连接请求</strong>：服务器接收到客户端的 SYN 报文段后，会向客户端发送一个 ACK 报文段作为确认，同时也发送一个 SYN 报文段。服务器在 SYN 报文段中指定服务器的初始序列号，并设置 SYN 和 ACK 标志位为 1，表示确认客户端的连接请求，并请求建立连接。</li>\n<li><strong>客户端确认连接</strong>：客户端收到服务器的 SYN 报文段后，会向服务器发送一个 ACK 报文段作为确认。客户端设置 ACK 标志位为 1，表示确认服务器的连接请求，建立连接。</li>\n</ol>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8355f9f227574d9ca85e5c76e9cfb872~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=864&h=439&s=265977&e=png&b=fdfdfd\" alt=\"image.png\"></p>\n<h3 id=\"4-发起-HTTP-请求\"><a href=\"#4-发起-HTTP-请求\" class=\"headerlink\" title=\"4.发起 HTTP 请求\"></a>4.发起 HTTP 请求</h3><p>当建立 TCP 连接之后，浏览器就可以发送  HTTP 请求到目标服务器，请求的内容包括：</p>\n<ul>\n<li><strong>请求行：</strong> 请求方法、请求的 URL、HTTP 协议的版本</li>\n<li><strong>请求头部：</strong> 包含了关于客户端、请求、所需资源等的信息（Host、User-Agent 等等）</li>\n<li><strong>请求体</strong>（仅在向服务器发送数据时才有）：包含了要发送给服务器的数据，如表单数据、JSON 数据等。</li>\n</ul>\n<h3 id=\"5-服务器响应\"><a href=\"#5-服务器响应\" class=\"headerlink\" title=\"5.服务器响应\"></a>5.服务器响应</h3><p>服务器接收到请求后，返回相应的资源数据，响应的内容包括：</p>\n<ul>\n<li><strong>状态行：</strong> 包含了 HTTP 协议的版本、状态码和状态消息。</li>\n<li><strong>响应头：</strong> 包含了关于响应、服务器、所返回资源等的信息（Content-Type、Content-Length 等等）。</li>\n<li><strong>响应体：</strong> 包含服务器返回给客户端的实际数据，如 HTML 页面、图片等。</li>\n</ul>\n<h3 id=\"6-浏览器解析渲染页面\"><a href=\"#6-浏览器解析渲染页面\" class=\"headerlink\" title=\"6.浏览器解析渲染页面\"></a>6.浏览器解析渲染页面</h3><h4 id=\"1-构建-DOM-树\"><a href=\"#1-构建-DOM-树\" class=\"headerlink\" title=\"1.构建 DOM 树\"></a>1.构建 DOM 树</h4><ol>\n<li><strong>词法分析</strong> ：<ul>\n<li>浏览器接收到 HTML 字符串后，会将其分解成一系列的标记（tokens）。</li>\n<li>标记包括开始标签、结束标签、属性、文本内容等。</li>\n</ul>\n</li>\n<li><strong>解析标记</strong> ：<ul>\n<li>浏览器根据词法分析得到的标记，开始解析这些标记并构建 DOM 节点。</li>\n<li>当解析到开始标签时，浏览器创建对应的元素节点，并将其加入 DOM 树中。</li>\n<li>当解析到属性时，浏览器将属性添加到对应的元素节点上。</li>\n<li>当解析到文本内容时，浏览器创建文本节点，并将其加入到 DOM 树中。</li>\n</ul>\n</li>\n<li><strong>构建 DOM 树</strong>：<ul>\n<li>在解析过程中，浏览器会根据标记的嵌套关系构建出完整的 DOM 树结构。</li>\n<li>根据 HTML 文档的层次结构，浏览器将创建的元素节点和文本节点按照其在文档中的位置进行组织，形成一棵树状结构。</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/608838c921b24d74a2bff2c3c2d8adaa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=800&h=443&s=214016&e=png&b=fefdfd\" alt=\"image.png\"></p>\n<h4 id=\"2-构建-CSSOM-树\"><a href=\"#2-构建-CSSOM-树\" class=\"headerlink\" title=\"2.构建 CSSOM 树\"></a>2.构建 CSSOM 树</h4><ol>\n<li><strong>词法分析</strong> ：<ul>\n<li>浏览器接收到 CSS 字符串后，会将其分解成一系列的标记（tokens）。</li>\n<li>标记包括选择器、属性、属性值等。</li>\n</ul>\n</li>\n<li><strong>解析样式表</strong> ：<ul>\n<li>浏览器根据词法分析得到的标记，开始解析这些标记并构建 CSSOM 节点。</li>\n<li>当解析到选择器时，浏览器创建对应的规则节点，并将其加入 CSSOM 树中。</li>\n<li>当解析到属性和属性值时，浏览器将其添加到对应的规则节点上。</li>\n</ul>\n</li>\n<li><strong>计算优先级</strong> ：<ul>\n<li>在解析过程中，浏览器会确定样式的优先级。</li>\n</ul>\n</li>\n<li><strong>处理样式继承</strong> ：<ul>\n<li>浏览器会处理样式的继承关系，将父元素的样式属性应用到子元素上。</li>\n</ul>\n</li>\n<li><strong>解析样式表引用</strong> ：<ul>\n<li>如果样式表中包含了 <code>@import</code> 规则，浏览器会解析引入的外部样式表，并将其内容合并到当前的 CSSOM 树中。</li>\n</ul>\n</li>\n<li><strong>合并样式表（Merging Stylesheets）</strong> ：<ul>\n<li>如果页面中包含多个样式表，浏览器会将这些样式表合并成一个统一的 CSSOM 树。</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/395b713f42e54922bb733d37f6a0f574~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=582&h=299&s=123760&e=png&b=fbfafa\" alt=\"image.png\"></p>\n<h4 id=\"3-构建渲染树\"><a href=\"#3-构建渲染树\" class=\"headerlink\" title=\"3.构建渲染树\"></a>3.构建渲染树</h4><p>浏览器将 DOM 树和 CSSOM 树合并成渲染树（Render Tree）。</p>\n<ol>\n<li><strong>从 DOM 树和 CSSOM 树中选择可见元素</strong>：<ul>\n<li>首先，浏览器需要从 DOM 树和 CSSOM 树中选择出在页面中可见的元素。</li>\n<li>不可见的元素，如 <code>&lt;head&gt;</code>、<code>script</code> 标签内的内容等，不会包含在渲染树中。</li>\n</ul>\n</li>\n<li><strong>匹配样式规则</strong>：<ul>\n<li>对于渲染树中的每个可见元素，浏览器会根据其标签和属性等信息，匹配适用的 CSS 样式规则。</li>\n</ul>\n</li>\n<li><strong>计算最终样式</strong>：<ul>\n<li>当一个元素匹配到多个 CSS 样式规则时，浏览器会根据优先级和层叠规则计算出最终的样式值。</li>\n</ul>\n</li>\n<li><strong>生成渲染树</strong>：<ul>\n<li>当所有可见元素都被匹配样式并加入渲染树后，渲染树的构建过程就完成了。</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8798bcc009a4c0e8d1b41b25b5a6886~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1726&h=840&s=332657&e=png&b=fdfdfd\" alt=\"image.png\"></p>\n<h4 id=\"4-回流\"><a href=\"#4-回流\" class=\"headerlink\" title=\"4.回流\"></a>4.回流</h4><p>有了渲染树，再接着就要进入回流（Reflow），也称为重新布局（Layout），浏览器根据渲染树中每个节点的布局信息，计算各个节点在页面中的位置和大小。当页面中的元素尺寸、位置或可见性发生变化时，浏览器需要重新计算并更新页面的布局信息。</p>\n<h4 id=\"5-重绘\"><a href=\"#5-重绘\" class=\"headerlink\" title=\"5.重绘\"></a>5.重绘</h4><p>回流一定伴随着重绘（Repaint），重绘是指浏览器根据元素的样式信息重新绘制页面的过程，而不涉及布局的改变。浏览器根据布局信息，将页面内容绘制到屏幕上。当元素的样式属性（如颜色、背景色、文本等）发生变化时，会触发重绘操作。</p>\n<h2 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h2><h3 id=\"1-DNS-解析优化\"><a href=\"#1-DNS-解析优化\" class=\"headerlink\" title=\"1.DNS 解析优化\"></a>1.DNS 解析优化</h3><ul>\n<li>使用快速的 DNS 服务器，可以借助 CDN ，减少域名解析时间。</li>\n<li>减少不必要的域名解析，合并资源到尽可能少的域名。</li>\n</ul>\n<h3 id=\"2-建立-TCP-连接优化\"><a href=\"#2-建立-TCP-连接优化\" class=\"headerlink\" title=\"2.建立 TCP 连接优化\"></a>2.建立 TCP 连接优化</h3><ul>\n<li>使用 HTTP&#x2F;2 以上版本协议，充分利用多路复用功能，减少连接建立时间。</li>\n<li>减少不必要的 TCP 连接，通过合并或内联资源来减少连接建立次数。</li>\n</ul>\n<h3 id=\"3-发起-HTTP-请求优化\"><a href=\"#3-发起-HTTP-请求优化\" class=\"headerlink\" title=\"3.发起 HTTP 请求优化\"></a>3.发起 HTTP 请求优化</h3><ul>\n<li>减少 HTTP 请求次数，通过合并或内联资源来减少请求次数（比如图片资源可以考虑懒加载图片或使用精灵图）。</li>\n<li>使用资源预加载和预解析来预先加载页面所需资源。<code>&lt;link rel=&quot;preload&quot;&gt;</code> 或 <code>&lt;link rel=&quot;prefetch&quot;&gt;</code></li>\n</ul>\n<h3 id=\"4-服务器响应优化\"><a href=\"#4-服务器响应优化\" class=\"headerlink\" title=\"4.服务器响应优化\"></a>4.服务器响应优化</h3><ul>\n<li>使用 CDN 加速资源传输，提高服务器响应速度。</li>\n<li>启用服务器端缓存，缓存动态生成的内容或数据库查询结果，减少服务器压力和响应时间。</li>\n</ul>\n<h3 id=\"5-资源下载优化\"><a href=\"#5-资源下载优化\" class=\"headerlink\" title=\"5.资源下载优化\"></a>5.资源下载优化</h3><ul>\n<li>减小资源文件大小，如优化图片（使用 WebP 格式）、压缩 JavaScript 和 CSS。</li>\n<li>使用浏览器缓存（Cache-Control、Expires），减少对服务器的请求，尤其是静态资源。</li>\n<li>使用异步加载 <code>&lt;script async&gt;</code> 和 <code>&lt;script defer&gt;</code></li>\n</ul>\n<h3 id=\"6-HTML-解析优化\"><a href=\"#6-HTML-解析优化\" class=\"headerlink\" title=\"6.HTML 解析优化\"></a>6.HTML 解析优化</h3><ul>\n<li>编写语义化的 HTML，避免过多嵌套和冗余标签。</li>\n<li>减小 HTML 文件大小，去除不必要的空格和注释。</li>\n</ul>\n<h3 id=\"7-CSS-解析优化\"><a href=\"#7-CSS-解析优化\" class=\"headerlink\" title=\"7.CSS 解析优化\"></a>7.CSS 解析优化</h3><ul>\n<li>减少 CSS 文件大小，删除不必要的样式和选择器。</li>\n<li>避免使用昂贵的 CSS 选择器（尽量给每一个标签给定类名，不要嵌套），优化样式表性能。</li>\n</ul>\n<h3 id=\"8-构建渲染树优化\"><a href=\"#8-构建渲染树优化\" class=\"headerlink\" title=\"8.构建渲染树优化\"></a>8.构建渲染树优化</h3><ul>\n<li>减少不必要的 DOM 操作，优化 JS 执行性能。</li>\n<li>避免使用 JS 动态修改样式，尽量使用 CSS 实现动画效果。</li>\n</ul>\n<h3 id=\"9-回流优化\"><a href=\"#9-回流优化\" class=\"headerlink\" title=\"9.回流优化\"></a>9.回流优化</h3><ul>\n<li>使用新布局（Flexbox 或 Grid 布局），减少复杂的布局计算。</li>\n<li>避免频繁修改样式属性，尽量使用批量修改或者使用类名切换的方式。</li>\n</ul>\n<h3 id=\"10-重绘优化\"><a href=\"#10-重绘优化\" class=\"headerlink\" title=\"10.重绘优化\"></a>10.重绘优化</h3><ul>\n<li>使用 transform 和 opacity 属性来触发硬件加速，减少页面重绘次数。</li>\n<li>避免在页面加载过程中阻塞渲染，尽快将页面内容呈现给用户。</li>\n<li>如果需要操作 DOM，先让 DOM 脱离文档流，再修改，再带回文档流（或者使用 DocumentFragment），减少回流重绘。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://juejin.cn/post/6844904134307495943?searchId=20240426205357E60AB4CA7A393DAA106E#heading-26\">「一道面试题」输入 URL 到渲染全面梳理中-页面渲染篇 - 掘金 (juejin.cn)</a></li>\n<li><a href=\"https://juejin.cn/post/6844903784229896199?searchId=20240426205107A43476DE1FB412A9CC53#heading-15\">从 URL 输入到页面展现到底发生什么？ - 掘金 (juejin.cn)</a></li>\n<li><a href=\"https://vue3js.cn/interview/http/after_url.html#%E4%BA%8C%E3%80%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90\">面试官：说说地址栏输入 URL 敲下回车后发生了什么? | web 前端面试 - 面试官系列 (vue3js.cn)</a></li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>已将学习代码上传至 <a href=\"https://github.com/YangyangU/CodeSpace\">github</a>，欢迎大家学习指正！</p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>春招在继续，面试不停息！最近也是被问到了标题上这个问题，好家伙，一个问题问到了 URL 到页面渲染的过程和性能优化，如果不熟悉这个过程的话，回答起来确实挺费劲，这篇文章就将带大家来捋一捋，争取回答的时候不卡壳 ~</p>\n<h2 id=\"输入-URL-到页面渲染过程\"><a href=\"#输入-URL-到页面渲染过程\" class=\"headerlink\" title=\"输入 URL 到页面渲染过程\"></a>输入 URL 到页面渲染过程</h2><h3 id=\"1-URL-解析\"><a href=\"#1-URL-解析\" class=\"headerlink\" title=\"1.URL 解析\"></a>1.URL 解析</h3><p>首先浏览器会判断你输入的是一个合法的<code>URL</code>  还是一个待搜索的关键词，如果是关键词，则会将关键词发送给默认的搜索引擎，然后返回页面；如果是<code>URL</code>，则会对<code>URL</code>的结构进行解析。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56d345299ffd4a9da71e3bf11a6e3944~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=942&h=265&s=55934&e=png&b=fefefe\" alt=\"image.png\"></p>\n<h3 id=\"2-DNS-解析\"><a href=\"#2-DNS-解析\" class=\"headerlink\" title=\"2.DNS 解析\"></a>2.DNS 解析</h3><p>当浏览器解析出域名，它会向 DNS 服务器发送请求，获取相应域名对应的 IP 地址。</p>\n<ul>\n<li>首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表</li>\n<li>若没有命中，则继续搜索操作系统的 DNS 缓存</li>\n<li>若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果</li>\n<li>若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询<ul>\n<li>首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器</li>\n<li>本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址</li>\n<li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li>\n</ul>\n</li>\n<li>本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</li>\n<li>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来</li>\n<li>至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fafd1dd33e6d4fe389872eb4ec215da0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1013&h=730&s=78701&e=png&b=ffffff\" alt=\"image.png\"></p>\n<h3 id=\"3-TCP-三次握手建立连接\"><a href=\"#3-TCP-三次握手建立连接\" class=\"headerlink\" title=\"3.TCP 三次握手建立连接\"></a>3.TCP 三次握手建立连接</h3><p>浏览器向服务器发起 TCP 连接请求，与服务器建立连接。</p>\n<ol>\n<li><strong>客户端向服务器发送连接请求</strong>：客户端首先向服务器发送一个 SYN 报文段，指定客户端的初始序列号，并设置 SYN 标志位为 1，表示请求建立连接。</li>\n<li><strong>服务器响应确认连接请求</strong>：服务器接收到客户端的 SYN 报文段后，会向客户端发送一个 ACK 报文段作为确认，同时也发送一个 SYN 报文段。服务器在 SYN 报文段中指定服务器的初始序列号，并设置 SYN 和 ACK 标志位为 1，表示确认客户端的连接请求，并请求建立连接。</li>\n<li><strong>客户端确认连接</strong>：客户端收到服务器的 SYN 报文段后，会向服务器发送一个 ACK 报文段作为确认。客户端设置 ACK 标志位为 1，表示确认服务器的连接请求，建立连接。</li>\n</ol>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8355f9f227574d9ca85e5c76e9cfb872~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=864&h=439&s=265977&e=png&b=fdfdfd\" alt=\"image.png\"></p>\n<h3 id=\"4-发起-HTTP-请求\"><a href=\"#4-发起-HTTP-请求\" class=\"headerlink\" title=\"4.发起 HTTP 请求\"></a>4.发起 HTTP 请求</h3><p>当建立 TCP 连接之后，浏览器就可以发送  HTTP 请求到目标服务器，请求的内容包括：</p>\n<ul>\n<li><strong>请求行：</strong> 请求方法、请求的 URL、HTTP 协议的版本</li>\n<li><strong>请求头部：</strong> 包含了关于客户端、请求、所需资源等的信息（Host、User-Agent 等等）</li>\n<li><strong>请求体</strong>（仅在向服务器发送数据时才有）：包含了要发送给服务器的数据，如表单数据、JSON 数据等。</li>\n</ul>\n<h3 id=\"5-服务器响应\"><a href=\"#5-服务器响应\" class=\"headerlink\" title=\"5.服务器响应\"></a>5.服务器响应</h3><p>服务器接收到请求后，返回相应的资源数据，响应的内容包括：</p>\n<ul>\n<li><strong>状态行：</strong> 包含了 HTTP 协议的版本、状态码和状态消息。</li>\n<li><strong>响应头：</strong> 包含了关于响应、服务器、所返回资源等的信息（Content-Type、Content-Length 等等）。</li>\n<li><strong>响应体：</strong> 包含服务器返回给客户端的实际数据，如 HTML 页面、图片等。</li>\n</ul>\n<h3 id=\"6-浏览器解析渲染页面\"><a href=\"#6-浏览器解析渲染页面\" class=\"headerlink\" title=\"6.浏览器解析渲染页面\"></a>6.浏览器解析渲染页面</h3><h4 id=\"1-构建-DOM-树\"><a href=\"#1-构建-DOM-树\" class=\"headerlink\" title=\"1.构建 DOM 树\"></a>1.构建 DOM 树</h4><ol>\n<li><strong>词法分析</strong> ：<ul>\n<li>浏览器接收到 HTML 字符串后，会将其分解成一系列的标记（tokens）。</li>\n<li>标记包括开始标签、结束标签、属性、文本内容等。</li>\n</ul>\n</li>\n<li><strong>解析标记</strong> ：<ul>\n<li>浏览器根据词法分析得到的标记，开始解析这些标记并构建 DOM 节点。</li>\n<li>当解析到开始标签时，浏览器创建对应的元素节点，并将其加入 DOM 树中。</li>\n<li>当解析到属性时，浏览器将属性添加到对应的元素节点上。</li>\n<li>当解析到文本内容时，浏览器创建文本节点，并将其加入到 DOM 树中。</li>\n</ul>\n</li>\n<li><strong>构建 DOM 树</strong>：<ul>\n<li>在解析过程中，浏览器会根据标记的嵌套关系构建出完整的 DOM 树结构。</li>\n<li>根据 HTML 文档的层次结构，浏览器将创建的元素节点和文本节点按照其在文档中的位置进行组织，形成一棵树状结构。</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/608838c921b24d74a2bff2c3c2d8adaa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=800&h=443&s=214016&e=png&b=fefdfd\" alt=\"image.png\"></p>\n<h4 id=\"2-构建-CSSOM-树\"><a href=\"#2-构建-CSSOM-树\" class=\"headerlink\" title=\"2.构建 CSSOM 树\"></a>2.构建 CSSOM 树</h4><ol>\n<li><strong>词法分析</strong> ：<ul>\n<li>浏览器接收到 CSS 字符串后，会将其分解成一系列的标记（tokens）。</li>\n<li>标记包括选择器、属性、属性值等。</li>\n</ul>\n</li>\n<li><strong>解析样式表</strong> ：<ul>\n<li>浏览器根据词法分析得到的标记，开始解析这些标记并构建 CSSOM 节点。</li>\n<li>当解析到选择器时，浏览器创建对应的规则节点，并将其加入 CSSOM 树中。</li>\n<li>当解析到属性和属性值时，浏览器将其添加到对应的规则节点上。</li>\n</ul>\n</li>\n<li><strong>计算优先级</strong> ：<ul>\n<li>在解析过程中，浏览器会确定样式的优先级。</li>\n</ul>\n</li>\n<li><strong>处理样式继承</strong> ：<ul>\n<li>浏览器会处理样式的继承关系，将父元素的样式属性应用到子元素上。</li>\n</ul>\n</li>\n<li><strong>解析样式表引用</strong> ：<ul>\n<li>如果样式表中包含了 <code>@import</code> 规则，浏览器会解析引入的外部样式表，并将其内容合并到当前的 CSSOM 树中。</li>\n</ul>\n</li>\n<li><strong>合并样式表（Merging Stylesheets）</strong> ：<ul>\n<li>如果页面中包含多个样式表，浏览器会将这些样式表合并成一个统一的 CSSOM 树。</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/395b713f42e54922bb733d37f6a0f574~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=582&h=299&s=123760&e=png&b=fbfafa\" alt=\"image.png\"></p>\n<h4 id=\"3-构建渲染树\"><a href=\"#3-构建渲染树\" class=\"headerlink\" title=\"3.构建渲染树\"></a>3.构建渲染树</h4><p>浏览器将 DOM 树和 CSSOM 树合并成渲染树（Render Tree）。</p>\n<ol>\n<li><strong>从 DOM 树和 CSSOM 树中选择可见元素</strong>：<ul>\n<li>首先，浏览器需要从 DOM 树和 CSSOM 树中选择出在页面中可见的元素。</li>\n<li>不可见的元素，如 <code>&lt;head&gt;</code>、<code>script</code> 标签内的内容等，不会包含在渲染树中。</li>\n</ul>\n</li>\n<li><strong>匹配样式规则</strong>：<ul>\n<li>对于渲染树中的每个可见元素，浏览器会根据其标签和属性等信息，匹配适用的 CSS 样式规则。</li>\n</ul>\n</li>\n<li><strong>计算最终样式</strong>：<ul>\n<li>当一个元素匹配到多个 CSS 样式规则时，浏览器会根据优先级和层叠规则计算出最终的样式值。</li>\n</ul>\n</li>\n<li><strong>生成渲染树</strong>：<ul>\n<li>当所有可见元素都被匹配样式并加入渲染树后，渲染树的构建过程就完成了。</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8798bcc009a4c0e8d1b41b25b5a6886~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1726&h=840&s=332657&e=png&b=fdfdfd\" alt=\"image.png\"></p>\n<h4 id=\"4-回流\"><a href=\"#4-回流\" class=\"headerlink\" title=\"4.回流\"></a>4.回流</h4><p>有了渲染树，再接着就要进入回流（Reflow），也称为重新布局（Layout），浏览器根据渲染树中每个节点的布局信息，计算各个节点在页面中的位置和大小。当页面中的元素尺寸、位置或可见性发生变化时，浏览器需要重新计算并更新页面的布局信息。</p>\n<h4 id=\"5-重绘\"><a href=\"#5-重绘\" class=\"headerlink\" title=\"5.重绘\"></a>5.重绘</h4><p>回流一定伴随着重绘（Repaint），重绘是指浏览器根据元素的样式信息重新绘制页面的过程，而不涉及布局的改变。浏览器根据布局信息，将页面内容绘制到屏幕上。当元素的样式属性（如颜色、背景色、文本等）发生变化时，会触发重绘操作。</p>\n<h2 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h2><h3 id=\"1-DNS-解析优化\"><a href=\"#1-DNS-解析优化\" class=\"headerlink\" title=\"1.DNS 解析优化\"></a>1.DNS 解析优化</h3><ul>\n<li>使用快速的 DNS 服务器，可以借助 CDN ，减少域名解析时间。</li>\n<li>减少不必要的域名解析，合并资源到尽可能少的域名。</li>\n</ul>\n<h3 id=\"2-建立-TCP-连接优化\"><a href=\"#2-建立-TCP-连接优化\" class=\"headerlink\" title=\"2.建立 TCP 连接优化\"></a>2.建立 TCP 连接优化</h3><ul>\n<li>使用 HTTP&#x2F;2 以上版本协议，充分利用多路复用功能，减少连接建立时间。</li>\n<li>减少不必要的 TCP 连接，通过合并或内联资源来减少连接建立次数。</li>\n</ul>\n<h3 id=\"3-发起-HTTP-请求优化\"><a href=\"#3-发起-HTTP-请求优化\" class=\"headerlink\" title=\"3.发起 HTTP 请求优化\"></a>3.发起 HTTP 请求优化</h3><ul>\n<li>减少 HTTP 请求次数，通过合并或内联资源来减少请求次数（比如图片资源可以考虑懒加载图片或使用精灵图）。</li>\n<li>使用资源预加载和预解析来预先加载页面所需资源。<code>&lt;link rel=&quot;preload&quot;&gt;</code> 或 <code>&lt;link rel=&quot;prefetch&quot;&gt;</code></li>\n</ul>\n<h3 id=\"4-服务器响应优化\"><a href=\"#4-服务器响应优化\" class=\"headerlink\" title=\"4.服务器响应优化\"></a>4.服务器响应优化</h3><ul>\n<li>使用 CDN 加速资源传输，提高服务器响应速度。</li>\n<li>启用服务器端缓存，缓存动态生成的内容或数据库查询结果，减少服务器压力和响应时间。</li>\n</ul>\n<h3 id=\"5-资源下载优化\"><a href=\"#5-资源下载优化\" class=\"headerlink\" title=\"5.资源下载优化\"></a>5.资源下载优化</h3><ul>\n<li>减小资源文件大小，如优化图片（使用 WebP 格式）、压缩 JavaScript 和 CSS。</li>\n<li>使用浏览器缓存（Cache-Control、Expires），减少对服务器的请求，尤其是静态资源。</li>\n<li>使用异步加载 <code>&lt;script async&gt;</code> 和 <code>&lt;script defer&gt;</code></li>\n</ul>\n<h3 id=\"6-HTML-解析优化\"><a href=\"#6-HTML-解析优化\" class=\"headerlink\" title=\"6.HTML 解析优化\"></a>6.HTML 解析优化</h3><ul>\n<li>编写语义化的 HTML，避免过多嵌套和冗余标签。</li>\n<li>减小 HTML 文件大小，去除不必要的空格和注释。</li>\n</ul>\n<h3 id=\"7-CSS-解析优化\"><a href=\"#7-CSS-解析优化\" class=\"headerlink\" title=\"7.CSS 解析优化\"></a>7.CSS 解析优化</h3><ul>\n<li>减少 CSS 文件大小，删除不必要的样式和选择器。</li>\n<li>避免使用昂贵的 CSS 选择器（尽量给每一个标签给定类名，不要嵌套），优化样式表性能。</li>\n</ul>\n<h3 id=\"8-构建渲染树优化\"><a href=\"#8-构建渲染树优化\" class=\"headerlink\" title=\"8.构建渲染树优化\"></a>8.构建渲染树优化</h3><ul>\n<li>减少不必要的 DOM 操作，优化 JS 执行性能。</li>\n<li>避免使用 JS 动态修改样式，尽量使用 CSS 实现动画效果。</li>\n</ul>\n<h3 id=\"9-回流优化\"><a href=\"#9-回流优化\" class=\"headerlink\" title=\"9.回流优化\"></a>9.回流优化</h3><ul>\n<li>使用新布局（Flexbox 或 Grid 布局），减少复杂的布局计算。</li>\n<li>避免频繁修改样式属性，尽量使用批量修改或者使用类名切换的方式。</li>\n</ul>\n<h3 id=\"10-重绘优化\"><a href=\"#10-重绘优化\" class=\"headerlink\" title=\"10.重绘优化\"></a>10.重绘优化</h3><ul>\n<li>使用 transform 和 opacity 属性来触发硬件加速，减少页面重绘次数。</li>\n<li>避免在页面加载过程中阻塞渲染，尽快将页面内容呈现给用户。</li>\n<li>如果需要操作 DOM，先让 DOM 脱离文档流，再修改，再带回文档流（或者使用 DocumentFragment），减少回流重绘。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://juejin.cn/post/6844904134307495943?searchId=20240426205357E60AB4CA7A393DAA106E#heading-26\">「一道面试题」输入 URL 到渲染全面梳理中-页面渲染篇 - 掘金 (juejin.cn)</a></li>\n<li><a href=\"https://juejin.cn/post/6844903784229896199?searchId=20240426205107A43476DE1FB412A9CC53#heading-15\">从 URL 输入到页面展现到底发生什么？ - 掘金 (juejin.cn)</a></li>\n<li><a href=\"https://vue3js.cn/interview/http/after_url.html#%E4%BA%8C%E3%80%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90\">面试官：说说地址栏输入 URL 敲下回车后发生了什么? | web 前端面试 - 面试官系列 (vue3js.cn)</a></li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>已将学习代码上传至 <a href=\"https://github.com/YangyangU/CodeSpace\">github</a>，欢迎大家学习指正！</p>\n"},{"title":"一文搞懂 Webpack 和 Vite","date":"2024-04-25T08:00:00.000Z","index_img":"/img/vite.webp","banner_img":"/img/default.png","_content":"\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b07f91e750c4751ab4e412a06fb8c9f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=771&h=318&s=214903&e=png&b=fec644)\n\n## 前言\n\nWebpack 和 Vite 都是前端工程化工具。Webpack 作为老大哥，在前端社区也算站稳了脚跟，它提供了许多配置和插件，让开发者定制化构建项目。随着 Vite 的出现，Webpack 在启动时间和热更新方面的缺陷就慢慢暴露，Vite 逐渐开始替代 Webpack。\n\n## Webpack\n\n### 使用步骤\n\n**1. 初始化项目**\n\n```bash\nyarn init -y\n```\n\n**2. 安装依赖**\n\n```bash\nyarn add webpack webpack-cli -D\n```\n\n**3. 在项目中创建 src 目录，编写代码**\n\n**4. 打包**\n\n```bash\nyarn webpack\n```\n\n### 配置文件\n\nWebpack 提供配置项和插件系统，允许我们在`webpack.config.js`文件中进行各种配置，从而帮助我们定制化构建项目。\n\n#### mode\n\n设置打包的模式，`production`为生产模式，`development`为开发模式\n\n```js\nmodule.exports = {\n  mode: \"production\",\n};\n```\n\n#### entry\n\n指定打包入口文件，默认为`./src/index.js`\n\n```js\nmodule.exports = {\n  entry: \"./src/a.js\",\n};\n```\n\n指定打包入口文件为`./src/a.js`\n\n```js\nentry: [\"./src/a.js\", \"./src/b.js\"];\n```\n\n使用数组可以设置多个入口文件，但是最后始终打包成一个文件\n\n```js\nentry:{\n    aa:'./src/a.js',\n    bb:'./src/b.js'\n},\n```\n\n对象形式也可设置多个入口文件，但是会打包成多个文件。Webpack 会将`value`文件打包成`key.js`文件，比如上述例子会将`'./src/a.js'`文件打包成`aa.js`文件、`'./src/b.js'`件打包成`bb.js`文件。\n\n#### output\n\n对打包后的文件进行配置，默认打包文件地址为`./dist/main.js`\n\n```js\nconst path = require(\"path\");\n\nmodule.exports = {\n  output: {\n    filename: \"bundle.js\", //打包后的文件名\n    clean: true, //每次打包前清除上次打包的文件\n    path: path.resolve(__dirname, \"hello\"), //打包后的文件存放路径，必须要绝对路径\n  },\n};\n```\n\n在`filename`中 Webpack 提供模版字符串的形式，可以自动生成唯一文件名：\n\n- `filename: \"[name].js\"` 打包多个文件时匹配对应的文件名,`[name]`与 entry 中的 key 对应。\n- `filename: \"[hash].js\"` 会随机生成哈希值，一般用于区分版本。\n\n等等，详情参考官方文档 [Output | template-strings](https://webpack.docschina.org/configuration/output/#template-strings)\n\n#### loader\n\nWebpack 默认情况下，只会处理 js 文件，如果我们希望它可以处理其他类型的文件，则要为其引入 loader\n\n以 css 为例，如果我们不进行任何操作\n\n```js\n//直接将css引入到js中\nimport \"./style/index.css\";\n\ndocument.body.insertAdjacentHTML(\"beforeend\", \"<h1>hello webpack</h1>\");\n```\n\n直接打包\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b79dfc906c304c919c48740c96fca4f0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=745&h=222&s=21476&e=png&b=1e1e1e)\n\n报错了，Webpack 说读不懂。\n\n我们需要安装解析 css 文件的 loader：\n\n```bash\nyarn add css-loader\n```\n\n配置 loader，`rules`是一个数组，允许我们配置多个 loader，`test`属性是一个正则表达式，用于匹配对应 loader 的文件，`use`属性则是匹配对应 loader。\n\n```js\nmodule: {\n  rules: [\n    {\n      test: /\\.css$/, //匹配文件\n      use: \"css-loader\",\n    },\n  ];\n}\n```\n\n配置完毕，成功打包，但是页面上并没有样式，但是打包文件中是有样式的啊，为什么就没有显示到页面上呢？\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f78ba8c1067840159bffdb596152f8f4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=481&h=61&s=4104&e=png&b=1f1f1f)\n\n因为 loader 遵循职责单一原则，一个 loader 只做一件事情，如果你想在打包的文件中使用上 css，光有解析 loader 还不够，还需要安装另一个 loader：\n\n```bash\nyarn add style-loader\n```\n\n然后配置`style-loader`：\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/, //匹配文件\n        use: [\"style-loader\", \"css-loader\"], //从后往前执行,有顺序要求\n      },\n    ],\n  },\n};\n```\n\n这里需要注意 ⚠️，如果我们配置多个 loader，则用数组存放，存放的顺序遵循**从右往左**，先执行的放右边，否则会报错。这里先编译 css 再使用，所以顺序为`'style-loader','css-loader'`。\n\n##### babel-loader\n\n在编写 js 代码时，经常需要使用一些 js 中的新特性，而新特性在旧的浏览器中兼容性并不好。但是我们现在希望能够使用新的特性，我们可以采用折中的方案。依然使用新特性编写代码，但是代码编写完成时我们通过一些工具将新代码转换为旧代码。\n\n[Babel](https://babel.nodejs.cn/) 就是这样一个工具，可以将新的 js 语法转换为旧的 js，以提高代码的兼容性。我们如果希望在 Webpack 支持 babel，则需要向 Webpack 中引入 babel-loader。\n\n```js\ndocument.body.onclick(() => {\n  alert(\"hello webpack\");\n});\n```\n\n这里我们使用一个箭头函数，在不做任何处理的情况下进行打包\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a10db0edca94d77872bd99660885a22~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=582&h=61&s=6024&e=png&b=1f1f1f)\n\n打包后发现还是箭头函数。\n\n于是我们安装`babel-loader`以及一些配置：\n\n```bash\nyarn add -D babel-loader @babel/core @babel/preset-env\n```\n\n配置\n\n```js\nmodule: {\n  rules: [\n    {\n      test: /\\.m?js$/, //以.mjs或js后缀的文件\n      exclude: /(node_modules|bower_components)/, //排除node_modules中的文件\n      use: {\n        loader: \"babel-loader\",\n        options: {\n          presets: [\"@babel/preset-env\"], //根据目标浏览器或运行时环境自动选择合适的转换规则\n        },\n      },\n    },\n  ];\n}\n```\n\n再试试呢：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b1a28dfbd914275971397476bf870c9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=608&h=60&s=6398&e=png&b=1f1f1f)\n\n成功将箭头函数打包成普通函数。\n\n###### 配置兼容性\n\n我们可以在`package.json`文件中配置需要兼容的浏览器，详情见 [github](https://github.com/browserslist/browserslist)\n\n```json\n\"browserslist\": [\n  \"defaults\", //默认\n  \"ie <= 11\", //ie版本低于11\n  \"last 2 versions\", //至少存在两个版本\n  \"> 1%\", //市场占有率大于1%\n  \"iOS 7\",\n]\n```\n\n#### plugin\n\nplugin 的作用是 Webpack 扩展功能。loader 可以理解为转换器，用于处理模块之间的转换，plugin 则用于执行更广泛的任务，它可以访问 Webpack 的生命周期，在合适的时机执行插件的功能。\n\n举个例子 🌰：\n\n我想在打包目录生成 html 文件，用于访问打包的 js 文件，我们可以手动创建，但是我们不建议直接操作`dist`打包目录，我们可以通过 plugin 自动生成该文件。\n\n安装自动生成 html 文件的插件\n\n```bash\nyarn add -D html-webpack-plugin\n```\n\n配置 plugin\n\n```js\nplugins: [\n  //自动创建html文件\n  new HTMLPlugin({\n    title: \"Hello Webpack\", //配置html文件的标题\n    template: \"./src/index.html\", //以哪个文件为模版创建\n  }),\n];\n```\n\n当我们再次打包，就会自动生成包含对应配置的 html 文件。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87bfecda699449a5979753c9c4d6d3bd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=200&h=90&s=3005&e=png&b=252526)\n\n### 服务器环境\n\n`webpack-cli`提供了许多命令帮助我们打包运行项目\n\n```bash\nyarn webpack\n```\n\n每次修改源码都需要重新打包，太麻烦了\n\n```bash\nyarn webpack --watch\n```\n\n加上`--watch`后每次修改源码都会被监听到，并且重新打包。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6329df87bb8e4f91a2b344f2d239a561~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=544&h=73&s=11212&e=png&b=1e1e1e)\n\n但是这个命令不能完美还原项目上线的场景，因为它访问的是文件目录，而不是服务器。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/041b8d5d3b9a4785a96f6810536c74fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=704&h=176&s=11852&e=png&b=fefefe)\n\n为此，我们可以安装一个 Webpack 服务：\n\n```bash\nyarn add -D webpack-dev-server\n```\n\n当我们运行以下命令，它能够将项目部署到一个开发服务器上：\n\n```bash\nyarn webpack serve --open\n```\n\n当我们访问本地 8080 端口，就能够看到我们的项目。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a39e13a757994cbf8ebd21a9be5870a5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=421&h=149&s=8115&e=png&b=fdfdfd)\n\n⚠️ 需要注意的是：这个服务它只会将我们的项目打包并运行在这个服务器，但是本地看不到这个`dist`的，所以当我们项目调试完毕，还需要自己手动打包一下。\n\n### 快捷命令\n\n我们一般会将常用的命令配置一下，使用起来更方便：\n\n```json\n\"scripts\": {\n  \"build\": \"webpack\",\n  \"watch\": \"webpack --watch\",\n  \"dev\": \"webpack serve --open\"\n},\n```\n\n## Vite\n\nWebpack 是先打包再运行，而 Vite 开发时并不打包，而是直接采用 ES Module 运行项目，部署的时候再打包，开箱即用。\n\n### 使用步骤\n\n**1. 初始化项目**\n\n```bash\nyarn init -y\n```\n\n**2. 安装 Vite**\n\n```bash\nyarn add -D vite\n```\n\n**3. Vite 的源码目录就是项目根目录，创建`index.html`文件，以 ES Module 的方式引入 js 文件**\n\n```html\n<script type=\"module\" src=\"./index.js\"></script>\n```\n\n**4. 在本地`5173`端口启动一个开发服务器，进行项目调试**\n\n```bash\nyarn vite\n```\n\n**5. 打包代码**\n\n```bash\nyarn vite build\n```\n\n### 快速创建项目\n\n参考 [开始 | Vite 官方中文文档 (vitejs.cn)](https://vitejs.cn/vite3-cn/guide/#scaffolding-your-first-vite-project)\n\n```bash\nyarn create vite\n```\n\n然后按照提示操作一步步配置即可！\n\n如果你选的是原生 JS，你就会得到一个这样的完整项目路径：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc878253b972445ca40eee285985308a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=235&h=280&s=11761&e=png&b=252526)\n\n### 配置文件\n\n首先在根目录下创建`vite.config.js`文件，⚠️ 注意这里的抛出语法与 Webpack 不同，Webpack 使用 CommonJS 语法，而 Vite 使用的是 ES Module 语法。\n\n```js\n//webpack\nmodule.exports = {\n    ...\n}\n```\n\n```js\n//vite\nexport default = {\n    ...\n}\n```\n\n这里 Vite 还提供了一个可选配置项`defineConfig`\n\n```js\nimport { defineConfig } from \"vite\";//需不需要提示\n\nexport default defineConfig({\n    ...\n})\n```\n\n它的作用是在我们写配置的时候会不会有提示。\n\n加了：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8b3281b4ea0411ab6db84977ed8da49~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=506&h=174&s=14896&e=png&b=1f1f1f)\n\n没加：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a649bc2692564ce4a4822396eb14e8f6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=398&h=164&s=8082&e=png&b=1e1e1e)\n\n对比不难发现区别。\n\n#### Vite 需要配置 loader 吗？\n\n试验一下：\n\n```css\nh2 {\n  background-color: pink;\n}\n```\n\n```js\nimport \"./index.css\";\ndocument.body.insertAdjacentHTML(\"beforeend\", \"<h2>hello vite</h2>\");\n```\n\n这里我们在 js 中引入 css 样式，然后`yarn vite` 运行一下\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d4e62e6bcfd4ac3b2c04c7da18e9198~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=461&h=171&s=7138&e=png&b=fefefe)\n\n结果显而易见，vite 不用配置 loader 就能编译和使用 css。\n\n#### 插件\n\nVite 可以使用插件进行扩展，这得益于 Rollup 优秀的插件接口设计和一部分 Vite 独有的额外选项。详情参见 [使用插件 | Vite 官方中文文档 (vitejs.cn)](https://vitejs.cn/vite3-cn/guide/using-plugins.html)\n\n举个例子 🌰：\n\n要想为传统浏览器提供支持，类似于 Babel，需要引入官方插件`@vitejs/plugin-legacy`和压缩工具`terser`。\n\n```bash\nyarn add -D @vitejs/plugin-legacy terser\n```\n\n然后配置插件：\n\n```js\nimport { defineConfig } from \"vite\"; //需不需要提示\nimport legacy from \"@vitejs/plugin-legacy\";\n\nexport default defineConfig({\n  plugins: [\n    legacy({\n      targets: [\"ie 11\"], //兼容IE 11\n    }),\n  ],\n});\n```\n\n我们来个箭头函数检验一下\n\n```js\ndocument.body.onclick = () => {\n  alert(\"hello vite\");\n};\n```\n\n`yarn vite build`一下\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9c237136b5f417f8d75a4a7a83d562c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=349&h=165&s=10660&e=png&b=262627)\n\n我们可以看到 Vite 给我们生产了三个 js 文件和一个 html 文件，来分析一下：\n\n`index.js`：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff6d50da1f7c431ca55d249120ebc223~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=468&h=52&s=4671&e=png&b=1e1e1e)\n\n这个文件中的箭头函数并没有转为普通函数；\n\n`index-legacy.js`：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3153971c059148c0852a3917640edde0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=522&h=48&s=5193&e=png&b=1f1f1f)\n\n这个文件中的箭头函数成功转成了普通函数；\n\n`polyfills-legacy.js`：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f289559ffa1c4faca4339661c488cbc8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=706&h=123&s=21850&e=png&b=1e1e1e)\n\n这个文件的作用是用于向下兼容旧版浏览器，确保旧版浏览器能够读懂新特性。\n\n`index.html`：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51f54a5761f14494a5c12830c47d7028~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1044&h=299&s=49070&e=png&b=1e1e1e)\n\n这个文件的意图就很明显了，如果浏览器支持 ESModule（即现代浏览器），则一般可以支持新语法，因此就可以直接引入新语法文件；但是如果浏览器不支持 ESModule，则可能是旧版本的浏览器，它们可能不支持新特性，这时候就需要引入兼容性代码来填补这些功能的缺失。在这种情况下，一般会引入 polyfills，以及旧版文件，来确保应用在旧版浏览器中的正常运行。\n\nvite 不像 webpack 只生成一个降级之后的文件，而是两个都生成，再根据浏览器的兼容性，动态地确定加载哪个版本的代码。对于现代浏览器来说，直接加载现代版本的代码可以获得更快的加载速度和更好的性能。而对于不支持 ES Module 的旧版浏览器，则加载降级版本的代码以确保兼容性。\n\n以上是对兼容性插件`legacy`的分析，更多插件可参见 [插件 | Vite 官方中文文档 (vitejs.cn)](https://vitejs.cn/vite3-cn/plugins/)\n\n### 快捷命令\n\n```json\n\"scripts\": {\n  \"dev\": \"vite\",\n  \"build\": \"vite build\",\n  \"preview\": \"vite preview\"\n},\n```\n\n## 对比总结\n\n1.  **构建方式：** Webpack 通过构建整个项目的依赖图，将所有资源打包成一个或多个 bundle 文件，每次重启都需要打包。Vite 采用了即时编译的方式，在开发模式下通过浏览器原生支持的 ES Module 特性进行加载，不需要打包。\n1.  **开发体验：** Webpack 需要较多的配置，对复杂的项目来说，需要花费时间和精力来配置各种 loader 和 plugin。Vite 开箱即用，不需要复杂的配置即可快速启动项目，支持各种插件以满足特定需求。\n1.  **热更新：** Webpack 的热更新通常需要借助 webpack-dev-server 等插件，在一些情况下配置起来比较复杂。Vite 内置了基于浏览器原生模块热更新的开发服务器，无需额外配置即可实现快速的热更新。\n\n## 最后\n\n已将学习代码上传至 [github](https://github.com/YangyangU/CodeSpace)，欢迎大家学习指正！\n","source":"_posts/一文搞懂Webpack和Vite.md","raw":"---\ntitle: 一文搞懂 Webpack 和 Vite\ndate: 2024-04-25 16:00:00\ntags: [Webpack, Vite]\ncategories: 工程化\nindex_img: /img/vite.webp\nbanner_img: /img/default.png\n---\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b07f91e750c4751ab4e412a06fb8c9f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=771&h=318&s=214903&e=png&b=fec644)\n\n## 前言\n\nWebpack 和 Vite 都是前端工程化工具。Webpack 作为老大哥，在前端社区也算站稳了脚跟，它提供了许多配置和插件，让开发者定制化构建项目。随着 Vite 的出现，Webpack 在启动时间和热更新方面的缺陷就慢慢暴露，Vite 逐渐开始替代 Webpack。\n\n## Webpack\n\n### 使用步骤\n\n**1. 初始化项目**\n\n```bash\nyarn init -y\n```\n\n**2. 安装依赖**\n\n```bash\nyarn add webpack webpack-cli -D\n```\n\n**3. 在项目中创建 src 目录，编写代码**\n\n**4. 打包**\n\n```bash\nyarn webpack\n```\n\n### 配置文件\n\nWebpack 提供配置项和插件系统，允许我们在`webpack.config.js`文件中进行各种配置，从而帮助我们定制化构建项目。\n\n#### mode\n\n设置打包的模式，`production`为生产模式，`development`为开发模式\n\n```js\nmodule.exports = {\n  mode: \"production\",\n};\n```\n\n#### entry\n\n指定打包入口文件，默认为`./src/index.js`\n\n```js\nmodule.exports = {\n  entry: \"./src/a.js\",\n};\n```\n\n指定打包入口文件为`./src/a.js`\n\n```js\nentry: [\"./src/a.js\", \"./src/b.js\"];\n```\n\n使用数组可以设置多个入口文件，但是最后始终打包成一个文件\n\n```js\nentry:{\n    aa:'./src/a.js',\n    bb:'./src/b.js'\n},\n```\n\n对象形式也可设置多个入口文件，但是会打包成多个文件。Webpack 会将`value`文件打包成`key.js`文件，比如上述例子会将`'./src/a.js'`文件打包成`aa.js`文件、`'./src/b.js'`件打包成`bb.js`文件。\n\n#### output\n\n对打包后的文件进行配置，默认打包文件地址为`./dist/main.js`\n\n```js\nconst path = require(\"path\");\n\nmodule.exports = {\n  output: {\n    filename: \"bundle.js\", //打包后的文件名\n    clean: true, //每次打包前清除上次打包的文件\n    path: path.resolve(__dirname, \"hello\"), //打包后的文件存放路径，必须要绝对路径\n  },\n};\n```\n\n在`filename`中 Webpack 提供模版字符串的形式，可以自动生成唯一文件名：\n\n- `filename: \"[name].js\"` 打包多个文件时匹配对应的文件名,`[name]`与 entry 中的 key 对应。\n- `filename: \"[hash].js\"` 会随机生成哈希值，一般用于区分版本。\n\n等等，详情参考官方文档 [Output | template-strings](https://webpack.docschina.org/configuration/output/#template-strings)\n\n#### loader\n\nWebpack 默认情况下，只会处理 js 文件，如果我们希望它可以处理其他类型的文件，则要为其引入 loader\n\n以 css 为例，如果我们不进行任何操作\n\n```js\n//直接将css引入到js中\nimport \"./style/index.css\";\n\ndocument.body.insertAdjacentHTML(\"beforeend\", \"<h1>hello webpack</h1>\");\n```\n\n直接打包\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b79dfc906c304c919c48740c96fca4f0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=745&h=222&s=21476&e=png&b=1e1e1e)\n\n报错了，Webpack 说读不懂。\n\n我们需要安装解析 css 文件的 loader：\n\n```bash\nyarn add css-loader\n```\n\n配置 loader，`rules`是一个数组，允许我们配置多个 loader，`test`属性是一个正则表达式，用于匹配对应 loader 的文件，`use`属性则是匹配对应 loader。\n\n```js\nmodule: {\n  rules: [\n    {\n      test: /\\.css$/, //匹配文件\n      use: \"css-loader\",\n    },\n  ];\n}\n```\n\n配置完毕，成功打包，但是页面上并没有样式，但是打包文件中是有样式的啊，为什么就没有显示到页面上呢？\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f78ba8c1067840159bffdb596152f8f4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=481&h=61&s=4104&e=png&b=1f1f1f)\n\n因为 loader 遵循职责单一原则，一个 loader 只做一件事情，如果你想在打包的文件中使用上 css，光有解析 loader 还不够，还需要安装另一个 loader：\n\n```bash\nyarn add style-loader\n```\n\n然后配置`style-loader`：\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/, //匹配文件\n        use: [\"style-loader\", \"css-loader\"], //从后往前执行,有顺序要求\n      },\n    ],\n  },\n};\n```\n\n这里需要注意 ⚠️，如果我们配置多个 loader，则用数组存放，存放的顺序遵循**从右往左**，先执行的放右边，否则会报错。这里先编译 css 再使用，所以顺序为`'style-loader','css-loader'`。\n\n##### babel-loader\n\n在编写 js 代码时，经常需要使用一些 js 中的新特性，而新特性在旧的浏览器中兼容性并不好。但是我们现在希望能够使用新的特性，我们可以采用折中的方案。依然使用新特性编写代码，但是代码编写完成时我们通过一些工具将新代码转换为旧代码。\n\n[Babel](https://babel.nodejs.cn/) 就是这样一个工具，可以将新的 js 语法转换为旧的 js，以提高代码的兼容性。我们如果希望在 Webpack 支持 babel，则需要向 Webpack 中引入 babel-loader。\n\n```js\ndocument.body.onclick(() => {\n  alert(\"hello webpack\");\n});\n```\n\n这里我们使用一个箭头函数，在不做任何处理的情况下进行打包\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a10db0edca94d77872bd99660885a22~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=582&h=61&s=6024&e=png&b=1f1f1f)\n\n打包后发现还是箭头函数。\n\n于是我们安装`babel-loader`以及一些配置：\n\n```bash\nyarn add -D babel-loader @babel/core @babel/preset-env\n```\n\n配置\n\n```js\nmodule: {\n  rules: [\n    {\n      test: /\\.m?js$/, //以.mjs或js后缀的文件\n      exclude: /(node_modules|bower_components)/, //排除node_modules中的文件\n      use: {\n        loader: \"babel-loader\",\n        options: {\n          presets: [\"@babel/preset-env\"], //根据目标浏览器或运行时环境自动选择合适的转换规则\n        },\n      },\n    },\n  ];\n}\n```\n\n再试试呢：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b1a28dfbd914275971397476bf870c9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=608&h=60&s=6398&e=png&b=1f1f1f)\n\n成功将箭头函数打包成普通函数。\n\n###### 配置兼容性\n\n我们可以在`package.json`文件中配置需要兼容的浏览器，详情见 [github](https://github.com/browserslist/browserslist)\n\n```json\n\"browserslist\": [\n  \"defaults\", //默认\n  \"ie <= 11\", //ie版本低于11\n  \"last 2 versions\", //至少存在两个版本\n  \"> 1%\", //市场占有率大于1%\n  \"iOS 7\",\n]\n```\n\n#### plugin\n\nplugin 的作用是 Webpack 扩展功能。loader 可以理解为转换器，用于处理模块之间的转换，plugin 则用于执行更广泛的任务，它可以访问 Webpack 的生命周期，在合适的时机执行插件的功能。\n\n举个例子 🌰：\n\n我想在打包目录生成 html 文件，用于访问打包的 js 文件，我们可以手动创建，但是我们不建议直接操作`dist`打包目录，我们可以通过 plugin 自动生成该文件。\n\n安装自动生成 html 文件的插件\n\n```bash\nyarn add -D html-webpack-plugin\n```\n\n配置 plugin\n\n```js\nplugins: [\n  //自动创建html文件\n  new HTMLPlugin({\n    title: \"Hello Webpack\", //配置html文件的标题\n    template: \"./src/index.html\", //以哪个文件为模版创建\n  }),\n];\n```\n\n当我们再次打包，就会自动生成包含对应配置的 html 文件。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87bfecda699449a5979753c9c4d6d3bd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=200&h=90&s=3005&e=png&b=252526)\n\n### 服务器环境\n\n`webpack-cli`提供了许多命令帮助我们打包运行项目\n\n```bash\nyarn webpack\n```\n\n每次修改源码都需要重新打包，太麻烦了\n\n```bash\nyarn webpack --watch\n```\n\n加上`--watch`后每次修改源码都会被监听到，并且重新打包。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6329df87bb8e4f91a2b344f2d239a561~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=544&h=73&s=11212&e=png&b=1e1e1e)\n\n但是这个命令不能完美还原项目上线的场景，因为它访问的是文件目录，而不是服务器。\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/041b8d5d3b9a4785a96f6810536c74fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=704&h=176&s=11852&e=png&b=fefefe)\n\n为此，我们可以安装一个 Webpack 服务：\n\n```bash\nyarn add -D webpack-dev-server\n```\n\n当我们运行以下命令，它能够将项目部署到一个开发服务器上：\n\n```bash\nyarn webpack serve --open\n```\n\n当我们访问本地 8080 端口，就能够看到我们的项目。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a39e13a757994cbf8ebd21a9be5870a5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=421&h=149&s=8115&e=png&b=fdfdfd)\n\n⚠️ 需要注意的是：这个服务它只会将我们的项目打包并运行在这个服务器，但是本地看不到这个`dist`的，所以当我们项目调试完毕，还需要自己手动打包一下。\n\n### 快捷命令\n\n我们一般会将常用的命令配置一下，使用起来更方便：\n\n```json\n\"scripts\": {\n  \"build\": \"webpack\",\n  \"watch\": \"webpack --watch\",\n  \"dev\": \"webpack serve --open\"\n},\n```\n\n## Vite\n\nWebpack 是先打包再运行，而 Vite 开发时并不打包，而是直接采用 ES Module 运行项目，部署的时候再打包，开箱即用。\n\n### 使用步骤\n\n**1. 初始化项目**\n\n```bash\nyarn init -y\n```\n\n**2. 安装 Vite**\n\n```bash\nyarn add -D vite\n```\n\n**3. Vite 的源码目录就是项目根目录，创建`index.html`文件，以 ES Module 的方式引入 js 文件**\n\n```html\n<script type=\"module\" src=\"./index.js\"></script>\n```\n\n**4. 在本地`5173`端口启动一个开发服务器，进行项目调试**\n\n```bash\nyarn vite\n```\n\n**5. 打包代码**\n\n```bash\nyarn vite build\n```\n\n### 快速创建项目\n\n参考 [开始 | Vite 官方中文文档 (vitejs.cn)](https://vitejs.cn/vite3-cn/guide/#scaffolding-your-first-vite-project)\n\n```bash\nyarn create vite\n```\n\n然后按照提示操作一步步配置即可！\n\n如果你选的是原生 JS，你就会得到一个这样的完整项目路径：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc878253b972445ca40eee285985308a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=235&h=280&s=11761&e=png&b=252526)\n\n### 配置文件\n\n首先在根目录下创建`vite.config.js`文件，⚠️ 注意这里的抛出语法与 Webpack 不同，Webpack 使用 CommonJS 语法，而 Vite 使用的是 ES Module 语法。\n\n```js\n//webpack\nmodule.exports = {\n    ...\n}\n```\n\n```js\n//vite\nexport default = {\n    ...\n}\n```\n\n这里 Vite 还提供了一个可选配置项`defineConfig`\n\n```js\nimport { defineConfig } from \"vite\";//需不需要提示\n\nexport default defineConfig({\n    ...\n})\n```\n\n它的作用是在我们写配置的时候会不会有提示。\n\n加了：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8b3281b4ea0411ab6db84977ed8da49~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=506&h=174&s=14896&e=png&b=1f1f1f)\n\n没加：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a649bc2692564ce4a4822396eb14e8f6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=398&h=164&s=8082&e=png&b=1e1e1e)\n\n对比不难发现区别。\n\n#### Vite 需要配置 loader 吗？\n\n试验一下：\n\n```css\nh2 {\n  background-color: pink;\n}\n```\n\n```js\nimport \"./index.css\";\ndocument.body.insertAdjacentHTML(\"beforeend\", \"<h2>hello vite</h2>\");\n```\n\n这里我们在 js 中引入 css 样式，然后`yarn vite` 运行一下\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d4e62e6bcfd4ac3b2c04c7da18e9198~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=461&h=171&s=7138&e=png&b=fefefe)\n\n结果显而易见，vite 不用配置 loader 就能编译和使用 css。\n\n#### 插件\n\nVite 可以使用插件进行扩展，这得益于 Rollup 优秀的插件接口设计和一部分 Vite 独有的额外选项。详情参见 [使用插件 | Vite 官方中文文档 (vitejs.cn)](https://vitejs.cn/vite3-cn/guide/using-plugins.html)\n\n举个例子 🌰：\n\n要想为传统浏览器提供支持，类似于 Babel，需要引入官方插件`@vitejs/plugin-legacy`和压缩工具`terser`。\n\n```bash\nyarn add -D @vitejs/plugin-legacy terser\n```\n\n然后配置插件：\n\n```js\nimport { defineConfig } from \"vite\"; //需不需要提示\nimport legacy from \"@vitejs/plugin-legacy\";\n\nexport default defineConfig({\n  plugins: [\n    legacy({\n      targets: [\"ie 11\"], //兼容IE 11\n    }),\n  ],\n});\n```\n\n我们来个箭头函数检验一下\n\n```js\ndocument.body.onclick = () => {\n  alert(\"hello vite\");\n};\n```\n\n`yarn vite build`一下\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9c237136b5f417f8d75a4a7a83d562c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=349&h=165&s=10660&e=png&b=262627)\n\n我们可以看到 Vite 给我们生产了三个 js 文件和一个 html 文件，来分析一下：\n\n`index.js`：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff6d50da1f7c431ca55d249120ebc223~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=468&h=52&s=4671&e=png&b=1e1e1e)\n\n这个文件中的箭头函数并没有转为普通函数；\n\n`index-legacy.js`：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3153971c059148c0852a3917640edde0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=522&h=48&s=5193&e=png&b=1f1f1f)\n\n这个文件中的箭头函数成功转成了普通函数；\n\n`polyfills-legacy.js`：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f289559ffa1c4faca4339661c488cbc8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=706&h=123&s=21850&e=png&b=1e1e1e)\n\n这个文件的作用是用于向下兼容旧版浏览器，确保旧版浏览器能够读懂新特性。\n\n`index.html`：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51f54a5761f14494a5c12830c47d7028~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1044&h=299&s=49070&e=png&b=1e1e1e)\n\n这个文件的意图就很明显了，如果浏览器支持 ESModule（即现代浏览器），则一般可以支持新语法，因此就可以直接引入新语法文件；但是如果浏览器不支持 ESModule，则可能是旧版本的浏览器，它们可能不支持新特性，这时候就需要引入兼容性代码来填补这些功能的缺失。在这种情况下，一般会引入 polyfills，以及旧版文件，来确保应用在旧版浏览器中的正常运行。\n\nvite 不像 webpack 只生成一个降级之后的文件，而是两个都生成，再根据浏览器的兼容性，动态地确定加载哪个版本的代码。对于现代浏览器来说，直接加载现代版本的代码可以获得更快的加载速度和更好的性能。而对于不支持 ES Module 的旧版浏览器，则加载降级版本的代码以确保兼容性。\n\n以上是对兼容性插件`legacy`的分析，更多插件可参见 [插件 | Vite 官方中文文档 (vitejs.cn)](https://vitejs.cn/vite3-cn/plugins/)\n\n### 快捷命令\n\n```json\n\"scripts\": {\n  \"dev\": \"vite\",\n  \"build\": \"vite build\",\n  \"preview\": \"vite preview\"\n},\n```\n\n## 对比总结\n\n1.  **构建方式：** Webpack 通过构建整个项目的依赖图，将所有资源打包成一个或多个 bundle 文件，每次重启都需要打包。Vite 采用了即时编译的方式，在开发模式下通过浏览器原生支持的 ES Module 特性进行加载，不需要打包。\n1.  **开发体验：** Webpack 需要较多的配置，对复杂的项目来说，需要花费时间和精力来配置各种 loader 和 plugin。Vite 开箱即用，不需要复杂的配置即可快速启动项目，支持各种插件以满足特定需求。\n1.  **热更新：** Webpack 的热更新通常需要借助 webpack-dev-server 等插件，在一些情况下配置起来比较复杂。Vite 内置了基于浏览器原生模块热更新的开发服务器，无需额外配置即可实现快速的热更新。\n\n## 最后\n\n已将学习代码上传至 [github](https://github.com/YangyangU/CodeSpace)，欢迎大家学习指正！\n","slug":"一文搞懂Webpack和Vite","published":1,"updated":"2024-09-09T15:29:10.736Z","_id":"clyww47x6000740v6d3t4bvqt","comments":1,"layout":"post","photos":[],"content":"<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b07f91e750c4751ab4e412a06fb8c9f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=771&h=318&s=214903&e=png&b=fec644\" alt=\"image.png\"></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Webpack 和 Vite 都是前端工程化工具。Webpack 作为老大哥，在前端社区也算站稳了脚跟，它提供了许多配置和插件，让开发者定制化构建项目。随着 Vite 的出现，Webpack 在启动时间和热更新方面的缺陷就慢慢暴露，Vite 逐渐开始替代 Webpack。</p>\n<h2 id=\"Webpack\"><a href=\"#Webpack\" class=\"headerlink\" title=\"Webpack\"></a>Webpack</h2><h3 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h3><p><strong>1. 初始化项目</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn init -y<br></code></pre></td></tr></table></figure>\n\n<p><strong>2. 安装依赖</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn add webpack webpack-cli -D<br></code></pre></td></tr></table></figure>\n\n<p><strong>3. 在项目中创建 src 目录，编写代码</strong></p>\n<p><strong>4. 打包</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn webpack<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><p>Webpack 提供配置项和插件系统，允许我们在<code>webpack.config.js</code>文件中进行各种配置，从而帮助我们定制化构建项目。</p>\n<h4 id=\"mode\"><a href=\"#mode\" class=\"headerlink\" title=\"mode\"></a>mode</h4><p>设置打包的模式，<code>production</code>为生产模式，<code>development</code>为开发模式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>  <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&quot;production&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"entry\"><a href=\"#entry\" class=\"headerlink\" title=\"entry\"></a>entry</h4><p>指定打包入口文件，默认为<code>./src/index.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>  <span class=\"hljs-attr\">entry</span>: <span class=\"hljs-string\">&quot;./src/a.js&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>指定打包入口文件为<code>./src/a.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-attr\">entry</span>: [<span class=\"hljs-string\">&quot;./src/a.js&quot;</span>, <span class=\"hljs-string\">&quot;./src/b.js&quot;</span>];<br></code></pre></td></tr></table></figure>\n\n<p>使用数组可以设置多个入口文件，但是最后始终打包成一个文件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-attr\">entry</span>:&#123;<br>    <span class=\"hljs-attr\">aa</span>:<span class=\"hljs-string\">&#x27;./src/a.js&#x27;</span>,<br>    <span class=\"hljs-attr\">bb</span>:<span class=\"hljs-string\">&#x27;./src/b.js&#x27;</span><br>&#125;,<br></code></pre></td></tr></table></figure>\n\n<p>对象形式也可设置多个入口文件，但是会打包成多个文件。Webpack 会将<code>value</code>文件打包成<code>key.js</code>文件，比如上述例子会将<code>&#39;./src/a.js&#39;</code>文件打包成<code>aa.js</code>文件、<code>&#39;./src/b.js&#39;</code>件打包成<code>bb.js</code>文件。</p>\n<h4 id=\"output\"><a href=\"#output\" class=\"headerlink\" title=\"output\"></a>output</h4><p>对打包后的文件进行配置，默认打包文件地址为<code>./dist/main.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;path&quot;</span>);<br><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>  <span class=\"hljs-attr\">output</span>: &#123;<br>    <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&quot;bundle.js&quot;</span>, <span class=\"hljs-comment\">//打包后的文件名</span><br>    <span class=\"hljs-attr\">clean</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-comment\">//每次打包前清除上次打包的文件</span><br>    <span class=\"hljs-attr\">path</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&quot;hello&quot;</span>), <span class=\"hljs-comment\">//打包后的文件存放路径，必须要绝对路径</span><br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>在<code>filename</code>中 Webpack 提供模版字符串的形式，可以自动生成唯一文件名：</p>\n<ul>\n<li><code>filename: &quot;[name].js&quot;</code> 打包多个文件时匹配对应的文件名,<code>[name]</code>与 entry 中的 key 对应。</li>\n<li><code>filename: &quot;[hash].js&quot;</code> 会随机生成哈希值，一般用于区分版本。</li>\n</ul>\n<p>等等，详情参考官方文档 <a href=\"https://webpack.docschina.org/configuration/output/#template-strings\">Output | template-strings</a></p>\n<h4 id=\"loader\"><a href=\"#loader\" class=\"headerlink\" title=\"loader\"></a>loader</h4><p>Webpack 默认情况下，只会处理 js 文件，如果我们希望它可以处理其他类型的文件，则要为其引入 loader</p>\n<p>以 css 为例，如果我们不进行任何操作</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//直接将css引入到js中</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;./style/index.css&quot;</span>;<br><br><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title function_\">insertAdjacentHTML</span>(<span class=\"hljs-string\">&quot;beforeend&quot;</span>, <span class=\"hljs-string\">&quot;&lt;h1&gt;hello webpack&lt;/h1&gt;&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>直接打包</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b79dfc906c304c919c48740c96fca4f0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=745&h=222&s=21476&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>报错了，Webpack 说读不懂。</p>\n<p>我们需要安装解析 css 文件的 loader：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn add css-loader<br></code></pre></td></tr></table></figure>\n\n<p>配置 loader，<code>rules</code>是一个数组，允许我们配置多个 loader，<code>test</code>属性是一个正则表达式，用于匹配对应 loader 的文件，<code>use</code>属性则是匹配对应 loader。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-attr\">module</span>: &#123;<br>  <span class=\"hljs-attr\">rules</span>: [<br>    &#123;<br>      <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.css$/</span>, <span class=\"hljs-comment\">//匹配文件</span><br>      <span class=\"hljs-attr\">use</span>: <span class=\"hljs-string\">&quot;css-loader&quot;</span>,<br>    &#125;,<br>  ];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>配置完毕，成功打包，但是页面上并没有样式，但是打包文件中是有样式的啊，为什么就没有显示到页面上呢？</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f78ba8c1067840159bffdb596152f8f4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=481&h=61&s=4104&e=png&b=1f1f1f\" alt=\"image.png\"></p>\n<p>因为 loader 遵循职责单一原则，一个 loader 只做一件事情，如果你想在打包的文件中使用上 css，光有解析 loader 还不够，还需要安装另一个 loader：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn add style-loader<br></code></pre></td></tr></table></figure>\n\n<p>然后配置<code>style-loader</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>  <span class=\"hljs-attr\">module</span>: &#123;<br>    <span class=\"hljs-attr\">rules</span>: [<br>      &#123;<br>        <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.css$/</span>, <span class=\"hljs-comment\">//匹配文件</span><br>        <span class=\"hljs-attr\">use</span>: [<span class=\"hljs-string\">&quot;style-loader&quot;</span>, <span class=\"hljs-string\">&quot;css-loader&quot;</span>], <span class=\"hljs-comment\">//从后往前执行,有顺序要求</span><br>      &#125;,<br>    ],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>这里需要注意 ⚠️，如果我们配置多个 loader，则用数组存放，存放的顺序遵循<strong>从右往左</strong>，先执行的放右边，否则会报错。这里先编译 css 再使用，所以顺序为<code>&#39;style-loader&#39;,&#39;css-loader&#39;</code>。</p>\n<h5 id=\"babel-loader\"><a href=\"#babel-loader\" class=\"headerlink\" title=\"babel-loader\"></a>babel-loader</h5><p>在编写 js 代码时，经常需要使用一些 js 中的新特性，而新特性在旧的浏览器中兼容性并不好。但是我们现在希望能够使用新的特性，我们可以采用折中的方案。依然使用新特性编写代码，但是代码编写完成时我们通过一些工具将新代码转换为旧代码。</p>\n<p><a href=\"https://babel.nodejs.cn/\">Babel</a> 就是这样一个工具，可以将新的 js 语法转换为旧的 js，以提高代码的兼容性。我们如果希望在 Webpack 支持 babel，则需要向 Webpack 中引入 babel-loader。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title function_\">onclick</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&quot;hello webpack&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>这里我们使用一个箭头函数，在不做任何处理的情况下进行打包</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a10db0edca94d77872bd99660885a22~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=582&h=61&s=6024&e=png&b=1f1f1f\" alt=\"image.png\"></p>\n<p>打包后发现还是箭头函数。</p>\n<p>于是我们安装<code>babel-loader</code>以及一些配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn add -D babel-loader @babel/core @babel/preset-env<br></code></pre></td></tr></table></figure>\n\n<p>配置</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-attr\">module</span>: &#123;<br>  <span class=\"hljs-attr\">rules</span>: [<br>    &#123;<br>      <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.m?js$/</span>, <span class=\"hljs-comment\">//以.mjs或js后缀的文件</span><br>      <span class=\"hljs-attr\">exclude</span>: <span class=\"hljs-regexp\">/(node_modules|bower_components)/</span>, <span class=\"hljs-comment\">//排除node_modules中的文件</span><br>      <span class=\"hljs-attr\">use</span>: &#123;<br>        <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&quot;babel-loader&quot;</span>,<br>        <span class=\"hljs-attr\">options</span>: &#123;<br>          <span class=\"hljs-attr\">presets</span>: [<span class=\"hljs-string\">&quot;@babel/preset-env&quot;</span>], <span class=\"hljs-comment\">//根据目标浏览器或运行时环境自动选择合适的转换规则</span><br>        &#125;,<br>      &#125;,<br>    &#125;,<br>  ];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>再试试呢：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b1a28dfbd914275971397476bf870c9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=608&h=60&s=6398&e=png&b=1f1f1f\" alt=\"image.png\"></p>\n<p>成功将箭头函数打包成普通函数。</p>\n<h6 id=\"配置兼容性\"><a href=\"#配置兼容性\" class=\"headerlink\" title=\"配置兼容性\"></a>配置兼容性</h6><p>我们可以在<code>package.json</code>文件中配置需要兼容的浏览器，详情见 <a href=\"https://github.com/browserslist/browserslist\">github</a></p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\"><span class=\"hljs-attr\">&quot;browserslist&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><br>  <span class=\"hljs-string\">&quot;defaults&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">//默认</span><br>  <span class=\"hljs-string\">&quot;ie &lt;= 11&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">//ie版本低于11</span><br>  <span class=\"hljs-string\">&quot;last 2 versions&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">//至少存在两个版本</span><br>  <span class=\"hljs-string\">&quot;&gt; 1%&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">//市场占有率大于1%</span><br>  <span class=\"hljs-string\">&quot;iOS 7&quot;</span><span class=\"hljs-punctuation\">,</span><br><span class=\"hljs-punctuation\">]</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"plugin\"><a href=\"#plugin\" class=\"headerlink\" title=\"plugin\"></a>plugin</h4><p>plugin 的作用是 Webpack 扩展功能。loader 可以理解为转换器，用于处理模块之间的转换，plugin 则用于执行更广泛的任务，它可以访问 Webpack 的生命周期，在合适的时机执行插件的功能。</p>\n<p>举个例子 🌰：</p>\n<p>我想在打包目录生成 html 文件，用于访问打包的 js 文件，我们可以手动创建，但是我们不建议直接操作<code>dist</code>打包目录，我们可以通过 plugin 自动生成该文件。</p>\n<p>安装自动生成 html 文件的插件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn add -D html-webpack-plugin<br></code></pre></td></tr></table></figure>\n\n<p>配置 plugin</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-attr\">plugins</span>: [<br>  <span class=\"hljs-comment\">//自动创建html文件</span><br>  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HTMLPlugin</span>(&#123;<br>    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&quot;Hello Webpack&quot;</span>, <span class=\"hljs-comment\">//配置html文件的标题</span><br>    <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">&quot;./src/index.html&quot;</span>, <span class=\"hljs-comment\">//以哪个文件为模版创建</span><br>  &#125;),<br>];<br></code></pre></td></tr></table></figure>\n\n<p>当我们再次打包，就会自动生成包含对应配置的 html 文件。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87bfecda699449a5979753c9c4d6d3bd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=200&h=90&s=3005&e=png&b=252526\" alt=\"image.png\"></p>\n<h3 id=\"服务器环境\"><a href=\"#服务器环境\" class=\"headerlink\" title=\"服务器环境\"></a>服务器环境</h3><p><code>webpack-cli</code>提供了许多命令帮助我们打包运行项目</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn webpack<br></code></pre></td></tr></table></figure>\n\n<p>每次修改源码都需要重新打包，太麻烦了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn webpack --watch<br></code></pre></td></tr></table></figure>\n\n<p>加上<code>--watch</code>后每次修改源码都会被监听到，并且重新打包。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6329df87bb8e4f91a2b344f2d239a561~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=544&h=73&s=11212&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>但是这个命令不能完美还原项目上线的场景，因为它访问的是文件目录，而不是服务器。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/041b8d5d3b9a4785a96f6810536c74fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=704&h=176&s=11852&e=png&b=fefefe\" alt=\"image.png\"></p>\n<p>为此，我们可以安装一个 Webpack 服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn add -D webpack-dev-server<br></code></pre></td></tr></table></figure>\n\n<p>当我们运行以下命令，它能够将项目部署到一个开发服务器上：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn webpack serve --open<br></code></pre></td></tr></table></figure>\n\n<p>当我们访问本地 8080 端口，就能够看到我们的项目。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a39e13a757994cbf8ebd21a9be5870a5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=421&h=149&s=8115&e=png&b=fdfdfd\" alt=\"image.png\"></p>\n<p>⚠️ 需要注意的是：这个服务它只会将我们的项目打包并运行在这个服务器，但是本地看不到这个<code>dist</code>的，所以当我们项目调试完毕，还需要自己手动打包一下。</p>\n<h3 id=\"快捷命令\"><a href=\"#快捷命令\" class=\"headerlink\" title=\"快捷命令\"></a>快捷命令</h3><p>我们一般会将常用的命令配置一下，使用起来更方便：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\"><span class=\"hljs-attr\">&quot;scripts&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span><br>  <span class=\"hljs-attr\">&quot;build&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;webpack&quot;</span><span class=\"hljs-punctuation\">,</span><br>  <span class=\"hljs-attr\">&quot;watch&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;webpack --watch&quot;</span><span class=\"hljs-punctuation\">,</span><br>  <span class=\"hljs-attr\">&quot;dev&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;webpack serve --open&quot;</span><br><span class=\"hljs-punctuation\">&#125;</span><span class=\"hljs-punctuation\">,</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Vite\"><a href=\"#Vite\" class=\"headerlink\" title=\"Vite\"></a>Vite</h2><p>Webpack 是先打包再运行，而 Vite 开发时并不打包，而是直接采用 ES Module 运行项目，部署的时候再打包，开箱即用。</p>\n<h3 id=\"使用步骤-1\"><a href=\"#使用步骤-1\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h3><p><strong>1. 初始化项目</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn init -y<br></code></pre></td></tr></table></figure>\n\n<p><strong>2. 安装 Vite</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn add -D vite<br></code></pre></td></tr></table></figure>\n\n<p><strong>3. Vite 的源码目录就是项目根目录，创建<code>index.html</code>文件，以 ES Module 的方式引入 js 文件</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;module&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;./index.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>4. 在本地<code>5173</code>端口启动一个开发服务器，进行项目调试</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn vite<br></code></pre></td></tr></table></figure>\n\n<p><strong>5. 打包代码</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn vite build<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"快速创建项目\"><a href=\"#快速创建项目\" class=\"headerlink\" title=\"快速创建项目\"></a>快速创建项目</h3><p>参考 <a href=\"https://vitejs.cn/vite3-cn/guide/#scaffolding-your-first-vite-project\">开始 | Vite 官方中文文档 (vitejs.cn)</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn create vite<br></code></pre></td></tr></table></figure>\n\n<p>然后按照提示操作一步步配置即可！</p>\n<p>如果你选的是原生 JS，你就会得到一个这样的完整项目路径：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc878253b972445ca40eee285985308a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=235&h=280&s=11761&e=png&b=252526\" alt=\"image.png\"></p>\n<h3 id=\"配置文件-1\"><a href=\"#配置文件-1\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><p>首先在根目录下创建<code>vite.config.js</code>文件，⚠️ 注意这里的抛出语法与 Webpack 不同，Webpack 使用 CommonJS 语法，而 Vite 使用的是 ES Module 语法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//webpack</span><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//vite</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> = &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里 Vite 还提供了一个可选配置项<code>defineConfig</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123; defineConfig &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vite&quot;</span>;<span class=\"hljs-comment\">//需不需要提示</span><br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title function_\">defineConfig</span>(&#123;<br>    ...<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>它的作用是在我们写配置的时候会不会有提示。</p>\n<p>加了：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8b3281b4ea0411ab6db84977ed8da49~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=506&h=174&s=14896&e=png&b=1f1f1f\" alt=\"image.png\"></p>\n<p>没加：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a649bc2692564ce4a4822396eb14e8f6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=398&h=164&s=8082&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>对比不难发现区别。</p>\n<h4 id=\"Vite-需要配置-loader-吗？\"><a href=\"#Vite-需要配置-loader-吗？\" class=\"headerlink\" title=\"Vite 需要配置 loader 吗？\"></a>Vite 需要配置 loader 吗？</h4><p>试验一下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">h2</span> &#123;<br>  <span class=\"hljs-attribute\">background-color</span>: pink;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;./index.css&quot;</span>;<br><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title function_\">insertAdjacentHTML</span>(<span class=\"hljs-string\">&quot;beforeend&quot;</span>, <span class=\"hljs-string\">&quot;&lt;h2&gt;hello vite&lt;/h2&gt;&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>这里我们在 js 中引入 css 样式，然后<code>yarn vite</code> 运行一下</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d4e62e6bcfd4ac3b2c04c7da18e9198~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=461&h=171&s=7138&e=png&b=fefefe\" alt=\"image.png\"></p>\n<p>结果显而易见，vite 不用配置 loader 就能编译和使用 css。</p>\n<h4 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h4><p>Vite 可以使用插件进行扩展，这得益于 Rollup 优秀的插件接口设计和一部分 Vite 独有的额外选项。详情参见 <a href=\"https://vitejs.cn/vite3-cn/guide/using-plugins.html\">使用插件 | Vite 官方中文文档 (vitejs.cn)</a></p>\n<p>举个例子 🌰：</p>\n<p>要想为传统浏览器提供支持，类似于 Babel，需要引入官方插件<code>@vitejs/plugin-legacy</code>和压缩工具<code>terser</code>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn add -D @vitejs/plugin-legacy terser<br></code></pre></td></tr></table></figure>\n\n<p>然后配置插件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123; defineConfig &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vite&quot;</span>; <span class=\"hljs-comment\">//需不需要提示</span><br><span class=\"hljs-keyword\">import</span> legacy <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@vitejs/plugin-legacy&quot;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title function_\">defineConfig</span>(&#123;<br>  <span class=\"hljs-attr\">plugins</span>: [<br>    <span class=\"hljs-title function_\">legacy</span>(&#123;<br>      <span class=\"hljs-attr\">targets</span>: [<span class=\"hljs-string\">&quot;ie 11&quot;</span>], <span class=\"hljs-comment\">//兼容IE 11</span><br>    &#125;),<br>  ],<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>我们来个箭头函数检验一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&quot;hello vite&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><code>yarn vite build</code>一下</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9c237136b5f417f8d75a4a7a83d562c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=349&h=165&s=10660&e=png&b=262627\" alt=\"image.png\"></p>\n<p>我们可以看到 Vite 给我们生产了三个 js 文件和一个 html 文件，来分析一下：</p>\n<p><code>index.js</code>：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff6d50da1f7c431ca55d249120ebc223~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=468&h=52&s=4671&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>这个文件中的箭头函数并没有转为普通函数；</p>\n<p><code>index-legacy.js</code>：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3153971c059148c0852a3917640edde0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=522&h=48&s=5193&e=png&b=1f1f1f\" alt=\"image.png\"></p>\n<p>这个文件中的箭头函数成功转成了普通函数；</p>\n<p><code>polyfills-legacy.js</code>：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f289559ffa1c4faca4339661c488cbc8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=706&h=123&s=21850&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>这个文件的作用是用于向下兼容旧版浏览器，确保旧版浏览器能够读懂新特性。</p>\n<p><code>index.html</code>：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51f54a5761f14494a5c12830c47d7028~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1044&h=299&s=49070&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>这个文件的意图就很明显了，如果浏览器支持 ESModule（即现代浏览器），则一般可以支持新语法，因此就可以直接引入新语法文件；但是如果浏览器不支持 ESModule，则可能是旧版本的浏览器，它们可能不支持新特性，这时候就需要引入兼容性代码来填补这些功能的缺失。在这种情况下，一般会引入 polyfills，以及旧版文件，来确保应用在旧版浏览器中的正常运行。</p>\n<p>vite 不像 webpack 只生成一个降级之后的文件，而是两个都生成，再根据浏览器的兼容性，动态地确定加载哪个版本的代码。对于现代浏览器来说，直接加载现代版本的代码可以获得更快的加载速度和更好的性能。而对于不支持 ES Module 的旧版浏览器，则加载降级版本的代码以确保兼容性。</p>\n<p>以上是对兼容性插件<code>legacy</code>的分析，更多插件可参见 <a href=\"https://vitejs.cn/vite3-cn/plugins/\">插件 | Vite 官方中文文档 (vitejs.cn)</a></p>\n<h3 id=\"快捷命令-1\"><a href=\"#快捷命令-1\" class=\"headerlink\" title=\"快捷命令\"></a>快捷命令</h3><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\"><span class=\"hljs-attr\">&quot;scripts&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span><br>  <span class=\"hljs-attr\">&quot;dev&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;vite&quot;</span><span class=\"hljs-punctuation\">,</span><br>  <span class=\"hljs-attr\">&quot;build&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;vite build&quot;</span><span class=\"hljs-punctuation\">,</span><br>  <span class=\"hljs-attr\">&quot;preview&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;vite preview&quot;</span><br><span class=\"hljs-punctuation\">&#125;</span><span class=\"hljs-punctuation\">,</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"对比总结\"><a href=\"#对比总结\" class=\"headerlink\" title=\"对比总结\"></a>对比总结</h2><ol>\n<li><strong>构建方式：</strong> Webpack 通过构建整个项目的依赖图，将所有资源打包成一个或多个 bundle 文件，每次重启都需要打包。Vite 采用了即时编译的方式，在开发模式下通过浏览器原生支持的 ES Module 特性进行加载，不需要打包。</li>\n<li><strong>开发体验：</strong> Webpack 需要较多的配置，对复杂的项目来说，需要花费时间和精力来配置各种 loader 和 plugin。Vite 开箱即用，不需要复杂的配置即可快速启动项目，支持各种插件以满足特定需求。</li>\n<li><strong>热更新：</strong> Webpack 的热更新通常需要借助 webpack-dev-server 等插件，在一些情况下配置起来比较复杂。Vite 内置了基于浏览器原生模块热更新的开发服务器，无需额外配置即可实现快速的热更新。</li>\n</ol>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>已将学习代码上传至 <a href=\"https://github.com/YangyangU/CodeSpace\">github</a>，欢迎大家学习指正！</p>\n","excerpt":"","more":"<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b07f91e750c4751ab4e412a06fb8c9f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=771&h=318&s=214903&e=png&b=fec644\" alt=\"image.png\"></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Webpack 和 Vite 都是前端工程化工具。Webpack 作为老大哥，在前端社区也算站稳了脚跟，它提供了许多配置和插件，让开发者定制化构建项目。随着 Vite 的出现，Webpack 在启动时间和热更新方面的缺陷就慢慢暴露，Vite 逐渐开始替代 Webpack。</p>\n<h2 id=\"Webpack\"><a href=\"#Webpack\" class=\"headerlink\" title=\"Webpack\"></a>Webpack</h2><h3 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h3><p><strong>1. 初始化项目</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn init -y<br></code></pre></td></tr></table></figure>\n\n<p><strong>2. 安装依赖</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn add webpack webpack-cli -D<br></code></pre></td></tr></table></figure>\n\n<p><strong>3. 在项目中创建 src 目录，编写代码</strong></p>\n<p><strong>4. 打包</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn webpack<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><p>Webpack 提供配置项和插件系统，允许我们在<code>webpack.config.js</code>文件中进行各种配置，从而帮助我们定制化构建项目。</p>\n<h4 id=\"mode\"><a href=\"#mode\" class=\"headerlink\" title=\"mode\"></a>mode</h4><p>设置打包的模式，<code>production</code>为生产模式，<code>development</code>为开发模式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>  <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">&quot;production&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"entry\"><a href=\"#entry\" class=\"headerlink\" title=\"entry\"></a>entry</h4><p>指定打包入口文件，默认为<code>./src/index.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>  <span class=\"hljs-attr\">entry</span>: <span class=\"hljs-string\">&quot;./src/a.js&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>指定打包入口文件为<code>./src/a.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-attr\">entry</span>: [<span class=\"hljs-string\">&quot;./src/a.js&quot;</span>, <span class=\"hljs-string\">&quot;./src/b.js&quot;</span>];<br></code></pre></td></tr></table></figure>\n\n<p>使用数组可以设置多个入口文件，但是最后始终打包成一个文件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-attr\">entry</span>:&#123;<br>    <span class=\"hljs-attr\">aa</span>:<span class=\"hljs-string\">&#x27;./src/a.js&#x27;</span>,<br>    <span class=\"hljs-attr\">bb</span>:<span class=\"hljs-string\">&#x27;./src/b.js&#x27;</span><br>&#125;,<br></code></pre></td></tr></table></figure>\n\n<p>对象形式也可设置多个入口文件，但是会打包成多个文件。Webpack 会将<code>value</code>文件打包成<code>key.js</code>文件，比如上述例子会将<code>&#39;./src/a.js&#39;</code>文件打包成<code>aa.js</code>文件、<code>&#39;./src/b.js&#39;</code>件打包成<code>bb.js</code>文件。</p>\n<h4 id=\"output\"><a href=\"#output\" class=\"headerlink\" title=\"output\"></a>output</h4><p>对打包后的文件进行配置，默认打包文件地址为<code>./dist/main.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;path&quot;</span>);<br><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>  <span class=\"hljs-attr\">output</span>: &#123;<br>    <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&quot;bundle.js&quot;</span>, <span class=\"hljs-comment\">//打包后的文件名</span><br>    <span class=\"hljs-attr\">clean</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-comment\">//每次打包前清除上次打包的文件</span><br>    <span class=\"hljs-attr\">path</span>: path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&quot;hello&quot;</span>), <span class=\"hljs-comment\">//打包后的文件存放路径，必须要绝对路径</span><br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>在<code>filename</code>中 Webpack 提供模版字符串的形式，可以自动生成唯一文件名：</p>\n<ul>\n<li><code>filename: &quot;[name].js&quot;</code> 打包多个文件时匹配对应的文件名,<code>[name]</code>与 entry 中的 key 对应。</li>\n<li><code>filename: &quot;[hash].js&quot;</code> 会随机生成哈希值，一般用于区分版本。</li>\n</ul>\n<p>等等，详情参考官方文档 <a href=\"https://webpack.docschina.org/configuration/output/#template-strings\">Output | template-strings</a></p>\n<h4 id=\"loader\"><a href=\"#loader\" class=\"headerlink\" title=\"loader\"></a>loader</h4><p>Webpack 默认情况下，只会处理 js 文件，如果我们希望它可以处理其他类型的文件，则要为其引入 loader</p>\n<p>以 css 为例，如果我们不进行任何操作</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//直接将css引入到js中</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;./style/index.css&quot;</span>;<br><br><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title function_\">insertAdjacentHTML</span>(<span class=\"hljs-string\">&quot;beforeend&quot;</span>, <span class=\"hljs-string\">&quot;&lt;h1&gt;hello webpack&lt;/h1&gt;&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>直接打包</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b79dfc906c304c919c48740c96fca4f0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=745&h=222&s=21476&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>报错了，Webpack 说读不懂。</p>\n<p>我们需要安装解析 css 文件的 loader：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn add css-loader<br></code></pre></td></tr></table></figure>\n\n<p>配置 loader，<code>rules</code>是一个数组，允许我们配置多个 loader，<code>test</code>属性是一个正则表达式，用于匹配对应 loader 的文件，<code>use</code>属性则是匹配对应 loader。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-attr\">module</span>: &#123;<br>  <span class=\"hljs-attr\">rules</span>: [<br>    &#123;<br>      <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.css$/</span>, <span class=\"hljs-comment\">//匹配文件</span><br>      <span class=\"hljs-attr\">use</span>: <span class=\"hljs-string\">&quot;css-loader&quot;</span>,<br>    &#125;,<br>  ];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>配置完毕，成功打包，但是页面上并没有样式，但是打包文件中是有样式的啊，为什么就没有显示到页面上呢？</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f78ba8c1067840159bffdb596152f8f4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=481&h=61&s=4104&e=png&b=1f1f1f\" alt=\"image.png\"></p>\n<p>因为 loader 遵循职责单一原则，一个 loader 只做一件事情，如果你想在打包的文件中使用上 css，光有解析 loader 还不够，还需要安装另一个 loader：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn add style-loader<br></code></pre></td></tr></table></figure>\n\n<p>然后配置<code>style-loader</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>  <span class=\"hljs-attr\">module</span>: &#123;<br>    <span class=\"hljs-attr\">rules</span>: [<br>      &#123;<br>        <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.css$/</span>, <span class=\"hljs-comment\">//匹配文件</span><br>        <span class=\"hljs-attr\">use</span>: [<span class=\"hljs-string\">&quot;style-loader&quot;</span>, <span class=\"hljs-string\">&quot;css-loader&quot;</span>], <span class=\"hljs-comment\">//从后往前执行,有顺序要求</span><br>      &#125;,<br>    ],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>这里需要注意 ⚠️，如果我们配置多个 loader，则用数组存放，存放的顺序遵循<strong>从右往左</strong>，先执行的放右边，否则会报错。这里先编译 css 再使用，所以顺序为<code>&#39;style-loader&#39;,&#39;css-loader&#39;</code>。</p>\n<h5 id=\"babel-loader\"><a href=\"#babel-loader\" class=\"headerlink\" title=\"babel-loader\"></a>babel-loader</h5><p>在编写 js 代码时，经常需要使用一些 js 中的新特性，而新特性在旧的浏览器中兼容性并不好。但是我们现在希望能够使用新的特性，我们可以采用折中的方案。依然使用新特性编写代码，但是代码编写完成时我们通过一些工具将新代码转换为旧代码。</p>\n<p><a href=\"https://babel.nodejs.cn/\">Babel</a> 就是这样一个工具，可以将新的 js 语法转换为旧的 js，以提高代码的兼容性。我们如果希望在 Webpack 支持 babel，则需要向 Webpack 中引入 babel-loader。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title function_\">onclick</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&quot;hello webpack&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>这里我们使用一个箭头函数，在不做任何处理的情况下进行打包</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a10db0edca94d77872bd99660885a22~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=582&h=61&s=6024&e=png&b=1f1f1f\" alt=\"image.png\"></p>\n<p>打包后发现还是箭头函数。</p>\n<p>于是我们安装<code>babel-loader</code>以及一些配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn add -D babel-loader @babel/core @babel/preset-env<br></code></pre></td></tr></table></figure>\n\n<p>配置</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-attr\">module</span>: &#123;<br>  <span class=\"hljs-attr\">rules</span>: [<br>    &#123;<br>      <span class=\"hljs-attr\">test</span>: <span class=\"hljs-regexp\">/\\.m?js$/</span>, <span class=\"hljs-comment\">//以.mjs或js后缀的文件</span><br>      <span class=\"hljs-attr\">exclude</span>: <span class=\"hljs-regexp\">/(node_modules|bower_components)/</span>, <span class=\"hljs-comment\">//排除node_modules中的文件</span><br>      <span class=\"hljs-attr\">use</span>: &#123;<br>        <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&quot;babel-loader&quot;</span>,<br>        <span class=\"hljs-attr\">options</span>: &#123;<br>          <span class=\"hljs-attr\">presets</span>: [<span class=\"hljs-string\">&quot;@babel/preset-env&quot;</span>], <span class=\"hljs-comment\">//根据目标浏览器或运行时环境自动选择合适的转换规则</span><br>        &#125;,<br>      &#125;,<br>    &#125;,<br>  ];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>再试试呢：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b1a28dfbd914275971397476bf870c9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=608&h=60&s=6398&e=png&b=1f1f1f\" alt=\"image.png\"></p>\n<p>成功将箭头函数打包成普通函数。</p>\n<h6 id=\"配置兼容性\"><a href=\"#配置兼容性\" class=\"headerlink\" title=\"配置兼容性\"></a>配置兼容性</h6><p>我们可以在<code>package.json</code>文件中配置需要兼容的浏览器，详情见 <a href=\"https://github.com/browserslist/browserslist\">github</a></p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\"><span class=\"hljs-attr\">&quot;browserslist&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><br>  <span class=\"hljs-string\">&quot;defaults&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">//默认</span><br>  <span class=\"hljs-string\">&quot;ie &lt;= 11&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">//ie版本低于11</span><br>  <span class=\"hljs-string\">&quot;last 2 versions&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">//至少存在两个版本</span><br>  <span class=\"hljs-string\">&quot;&gt; 1%&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">//市场占有率大于1%</span><br>  <span class=\"hljs-string\">&quot;iOS 7&quot;</span><span class=\"hljs-punctuation\">,</span><br><span class=\"hljs-punctuation\">]</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"plugin\"><a href=\"#plugin\" class=\"headerlink\" title=\"plugin\"></a>plugin</h4><p>plugin 的作用是 Webpack 扩展功能。loader 可以理解为转换器，用于处理模块之间的转换，plugin 则用于执行更广泛的任务，它可以访问 Webpack 的生命周期，在合适的时机执行插件的功能。</p>\n<p>举个例子 🌰：</p>\n<p>我想在打包目录生成 html 文件，用于访问打包的 js 文件，我们可以手动创建，但是我们不建议直接操作<code>dist</code>打包目录，我们可以通过 plugin 自动生成该文件。</p>\n<p>安装自动生成 html 文件的插件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn add -D html-webpack-plugin<br></code></pre></td></tr></table></figure>\n\n<p>配置 plugin</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-attr\">plugins</span>: [<br>  <span class=\"hljs-comment\">//自动创建html文件</span><br>  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HTMLPlugin</span>(&#123;<br>    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&quot;Hello Webpack&quot;</span>, <span class=\"hljs-comment\">//配置html文件的标题</span><br>    <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">&quot;./src/index.html&quot;</span>, <span class=\"hljs-comment\">//以哪个文件为模版创建</span><br>  &#125;),<br>];<br></code></pre></td></tr></table></figure>\n\n<p>当我们再次打包，就会自动生成包含对应配置的 html 文件。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87bfecda699449a5979753c9c4d6d3bd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=200&h=90&s=3005&e=png&b=252526\" alt=\"image.png\"></p>\n<h3 id=\"服务器环境\"><a href=\"#服务器环境\" class=\"headerlink\" title=\"服务器环境\"></a>服务器环境</h3><p><code>webpack-cli</code>提供了许多命令帮助我们打包运行项目</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn webpack<br></code></pre></td></tr></table></figure>\n\n<p>每次修改源码都需要重新打包，太麻烦了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn webpack --watch<br></code></pre></td></tr></table></figure>\n\n<p>加上<code>--watch</code>后每次修改源码都会被监听到，并且重新打包。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6329df87bb8e4f91a2b344f2d239a561~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=544&h=73&s=11212&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>但是这个命令不能完美还原项目上线的场景，因为它访问的是文件目录，而不是服务器。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/041b8d5d3b9a4785a96f6810536c74fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=704&h=176&s=11852&e=png&b=fefefe\" alt=\"image.png\"></p>\n<p>为此，我们可以安装一个 Webpack 服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn add -D webpack-dev-server<br></code></pre></td></tr></table></figure>\n\n<p>当我们运行以下命令，它能够将项目部署到一个开发服务器上：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn webpack serve --open<br></code></pre></td></tr></table></figure>\n\n<p>当我们访问本地 8080 端口，就能够看到我们的项目。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a39e13a757994cbf8ebd21a9be5870a5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=421&h=149&s=8115&e=png&b=fdfdfd\" alt=\"image.png\"></p>\n<p>⚠️ 需要注意的是：这个服务它只会将我们的项目打包并运行在这个服务器，但是本地看不到这个<code>dist</code>的，所以当我们项目调试完毕，还需要自己手动打包一下。</p>\n<h3 id=\"快捷命令\"><a href=\"#快捷命令\" class=\"headerlink\" title=\"快捷命令\"></a>快捷命令</h3><p>我们一般会将常用的命令配置一下，使用起来更方便：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\"><span class=\"hljs-attr\">&quot;scripts&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span><br>  <span class=\"hljs-attr\">&quot;build&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;webpack&quot;</span><span class=\"hljs-punctuation\">,</span><br>  <span class=\"hljs-attr\">&quot;watch&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;webpack --watch&quot;</span><span class=\"hljs-punctuation\">,</span><br>  <span class=\"hljs-attr\">&quot;dev&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;webpack serve --open&quot;</span><br><span class=\"hljs-punctuation\">&#125;</span><span class=\"hljs-punctuation\">,</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Vite\"><a href=\"#Vite\" class=\"headerlink\" title=\"Vite\"></a>Vite</h2><p>Webpack 是先打包再运行，而 Vite 开发时并不打包，而是直接采用 ES Module 运行项目，部署的时候再打包，开箱即用。</p>\n<h3 id=\"使用步骤-1\"><a href=\"#使用步骤-1\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h3><p><strong>1. 初始化项目</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn init -y<br></code></pre></td></tr></table></figure>\n\n<p><strong>2. 安装 Vite</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn add -D vite<br></code></pre></td></tr></table></figure>\n\n<p><strong>3. Vite 的源码目录就是项目根目录，创建<code>index.html</code>文件，以 ES Module 的方式引入 js 文件</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;module&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;./index.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>4. 在本地<code>5173</code>端口启动一个开发服务器，进行项目调试</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn vite<br></code></pre></td></tr></table></figure>\n\n<p><strong>5. 打包代码</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn vite build<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"快速创建项目\"><a href=\"#快速创建项目\" class=\"headerlink\" title=\"快速创建项目\"></a>快速创建项目</h3><p>参考 <a href=\"https://vitejs.cn/vite3-cn/guide/#scaffolding-your-first-vite-project\">开始 | Vite 官方中文文档 (vitejs.cn)</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn create vite<br></code></pre></td></tr></table></figure>\n\n<p>然后按照提示操作一步步配置即可！</p>\n<p>如果你选的是原生 JS，你就会得到一个这样的完整项目路径：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc878253b972445ca40eee285985308a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=235&h=280&s=11761&e=png&b=252526\" alt=\"image.png\"></p>\n<h3 id=\"配置文件-1\"><a href=\"#配置文件-1\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><p>首先在根目录下创建<code>vite.config.js</code>文件，⚠️ 注意这里的抛出语法与 Webpack 不同，Webpack 使用 CommonJS 语法，而 Vite 使用的是 ES Module 语法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//webpack</span><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//vite</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> = &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里 Vite 还提供了一个可选配置项<code>defineConfig</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123; defineConfig &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vite&quot;</span>;<span class=\"hljs-comment\">//需不需要提示</span><br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title function_\">defineConfig</span>(&#123;<br>    ...<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>它的作用是在我们写配置的时候会不会有提示。</p>\n<p>加了：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8b3281b4ea0411ab6db84977ed8da49~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=506&h=174&s=14896&e=png&b=1f1f1f\" alt=\"image.png\"></p>\n<p>没加：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a649bc2692564ce4a4822396eb14e8f6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=398&h=164&s=8082&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>对比不难发现区别。</p>\n<h4 id=\"Vite-需要配置-loader-吗？\"><a href=\"#Vite-需要配置-loader-吗？\" class=\"headerlink\" title=\"Vite 需要配置 loader 吗？\"></a>Vite 需要配置 loader 吗？</h4><p>试验一下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">h2</span> &#123;<br>  <span class=\"hljs-attribute\">background-color</span>: pink;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;./index.css&quot;</span>;<br><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title function_\">insertAdjacentHTML</span>(<span class=\"hljs-string\">&quot;beforeend&quot;</span>, <span class=\"hljs-string\">&quot;&lt;h2&gt;hello vite&lt;/h2&gt;&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>这里我们在 js 中引入 css 样式，然后<code>yarn vite</code> 运行一下</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d4e62e6bcfd4ac3b2c04c7da18e9198~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=461&h=171&s=7138&e=png&b=fefefe\" alt=\"image.png\"></p>\n<p>结果显而易见，vite 不用配置 loader 就能编译和使用 css。</p>\n<h4 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h4><p>Vite 可以使用插件进行扩展，这得益于 Rollup 优秀的插件接口设计和一部分 Vite 独有的额外选项。详情参见 <a href=\"https://vitejs.cn/vite3-cn/guide/using-plugins.html\">使用插件 | Vite 官方中文文档 (vitejs.cn)</a></p>\n<p>举个例子 🌰：</p>\n<p>要想为传统浏览器提供支持，类似于 Babel，需要引入官方插件<code>@vitejs/plugin-legacy</code>和压缩工具<code>terser</code>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn add -D @vitejs/plugin-legacy terser<br></code></pre></td></tr></table></figure>\n\n<p>然后配置插件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123; defineConfig &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vite&quot;</span>; <span class=\"hljs-comment\">//需不需要提示</span><br><span class=\"hljs-keyword\">import</span> legacy <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@vitejs/plugin-legacy&quot;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title function_\">defineConfig</span>(&#123;<br>  <span class=\"hljs-attr\">plugins</span>: [<br>    <span class=\"hljs-title function_\">legacy</span>(&#123;<br>      <span class=\"hljs-attr\">targets</span>: [<span class=\"hljs-string\">&quot;ie 11&quot;</span>], <span class=\"hljs-comment\">//兼容IE 11</span><br>    &#125;),<br>  ],<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>我们来个箭头函数检验一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&quot;hello vite&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><code>yarn vite build</code>一下</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9c237136b5f417f8d75a4a7a83d562c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=349&h=165&s=10660&e=png&b=262627\" alt=\"image.png\"></p>\n<p>我们可以看到 Vite 给我们生产了三个 js 文件和一个 html 文件，来分析一下：</p>\n<p><code>index.js</code>：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff6d50da1f7c431ca55d249120ebc223~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=468&h=52&s=4671&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>这个文件中的箭头函数并没有转为普通函数；</p>\n<p><code>index-legacy.js</code>：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3153971c059148c0852a3917640edde0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=522&h=48&s=5193&e=png&b=1f1f1f\" alt=\"image.png\"></p>\n<p>这个文件中的箭头函数成功转成了普通函数；</p>\n<p><code>polyfills-legacy.js</code>：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f289559ffa1c4faca4339661c488cbc8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=706&h=123&s=21850&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>这个文件的作用是用于向下兼容旧版浏览器，确保旧版浏览器能够读懂新特性。</p>\n<p><code>index.html</code>：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51f54a5761f14494a5c12830c47d7028~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1044&h=299&s=49070&e=png&b=1e1e1e\" alt=\"image.png\"></p>\n<p>这个文件的意图就很明显了，如果浏览器支持 ESModule（即现代浏览器），则一般可以支持新语法，因此就可以直接引入新语法文件；但是如果浏览器不支持 ESModule，则可能是旧版本的浏览器，它们可能不支持新特性，这时候就需要引入兼容性代码来填补这些功能的缺失。在这种情况下，一般会引入 polyfills，以及旧版文件，来确保应用在旧版浏览器中的正常运行。</p>\n<p>vite 不像 webpack 只生成一个降级之后的文件，而是两个都生成，再根据浏览器的兼容性，动态地确定加载哪个版本的代码。对于现代浏览器来说，直接加载现代版本的代码可以获得更快的加载速度和更好的性能。而对于不支持 ES Module 的旧版浏览器，则加载降级版本的代码以确保兼容性。</p>\n<p>以上是对兼容性插件<code>legacy</code>的分析，更多插件可参见 <a href=\"https://vitejs.cn/vite3-cn/plugins/\">插件 | Vite 官方中文文档 (vitejs.cn)</a></p>\n<h3 id=\"快捷命令-1\"><a href=\"#快捷命令-1\" class=\"headerlink\" title=\"快捷命令\"></a>快捷命令</h3><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\"><span class=\"hljs-attr\">&quot;scripts&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span><br>  <span class=\"hljs-attr\">&quot;dev&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;vite&quot;</span><span class=\"hljs-punctuation\">,</span><br>  <span class=\"hljs-attr\">&quot;build&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;vite build&quot;</span><span class=\"hljs-punctuation\">,</span><br>  <span class=\"hljs-attr\">&quot;preview&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;vite preview&quot;</span><br><span class=\"hljs-punctuation\">&#125;</span><span class=\"hljs-punctuation\">,</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"对比总结\"><a href=\"#对比总结\" class=\"headerlink\" title=\"对比总结\"></a>对比总结</h2><ol>\n<li><strong>构建方式：</strong> Webpack 通过构建整个项目的依赖图，将所有资源打包成一个或多个 bundle 文件，每次重启都需要打包。Vite 采用了即时编译的方式，在开发模式下通过浏览器原生支持的 ES Module 特性进行加载，不需要打包。</li>\n<li><strong>开发体验：</strong> Webpack 需要较多的配置，对复杂的项目来说，需要花费时间和精力来配置各种 loader 和 plugin。Vite 开箱即用，不需要复杂的配置即可快速启动项目，支持各种插件以满足特定需求。</li>\n<li><strong>热更新：</strong> Webpack 的热更新通常需要借助 webpack-dev-server 等插件，在一些情况下配置起来比较复杂。Vite 内置了基于浏览器原生模块热更新的开发服务器，无需额外配置即可实现快速的热更新。</li>\n</ol>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>已将学习代码上传至 <a href=\"https://github.com/YangyangU/CodeSpace\">github</a>，欢迎大家学习指正！</p>\n"},{"title":"一文搞懂 HTTP 缓存","date":"2024-04-22T08:00:00.000Z","index_img":"/img/http.png","banner_img":"/img/default.png","_content":"\n> HTTP 缓存可谓前端工程师必备技能之一，在最近的面试中，也经常被问到，那么为什么要有 HTTP 缓存，以及它是如何工作的，下面咱们展开来好好聊聊。\n\n还不知道什么是 HTTP？可以跳转到我的前一篇文章—— [捋一下 HTTP 发展史 - 掘金 (juejin.cn)](https://juejin.cn/post/7351700046486863881)\n\n## 为什么要有 HTTP 缓存\n\n缓存缓存，顾名思义就是将一些资源保存在本地，后续请求时就可以直接在本地读取，而不用请求服务器。使用 HTTP 缓存是提高性能优化和提升用户体验的关键技术，它主要体现在几个方面：\n\n> 1.  **减少延迟**：当资源被缓存后，用户可以直接从浏览器缓存或更近的网络节点（如 CDN）获取数据，而不必每次都请求原始服务器。网络延迟和数据传输时间都大大缩短了。\n> 1.  **减轻服务器负担**：通过缓存常用资源（如 Logo），服务器不必每次都处理相同的请求。\n> 1.  **节约带宽**：缓存可以显著减少需要通过网络传输的数据量，降低用户和供应商的流量成本。\n> 1.  **改善用户体验**：缓存使得网页、图片等内容的加载更快，从而直接提高了用户的浏览体验。\n> 1.  **离线浏览**：HTTP 缓存在一些场景可以让用户在没有网络连接的情况下，仍然能够访问先前加载过的内容。（如网易云音乐可以离线听之前缓存过的歌）\n> 1.  **负载均衡**：通过在多个地理位置缓存内容，避免所有请求都集中在一个服务器上。可以有效处理高流量和大规模分布的用户。\n\n总之，HTTP 缓存是前端开发者必备一项至关重要的技能，话不多说，开始介绍！\n\n## HTTP 缓存\n\nHTTP 缓存是一种客户端缓存，当浏览器向服务器发送资源请求时，服务器可以在响应头中查看是否包含缓存相关的信息。浏览器依据这些信息缓存响应资源，再次请求时如果命中缓存则直接读取本地缓存资源，而不再发请求。HTTP 缓存分为**强缓存**和**协商缓存**。\n\n### 强缓存\n\n强缓存直接决定了浏览器是否需要向服务器发起请求，只需要设置缓存的过期时间。如果强缓存有效，浏览器将直接从本地缓存中读取资源，不会与服务器进行任何交互。\n\n#### Cache-Control\n\n`Cache-Control`是通用消息头字段，被用于在 HTTP 请求和响应中，通过指定指令来实现缓存机制，通过设置`max-age=xxx`来指定资源在缓存中可以存活的最大时间（单位是秒）。\n\n举个栗子 🌰：\n\n这里我们缓存一个图片资源，过期时间为 86400 秒即一天\n\n```js\nres.writeHead(200, {\n  \"Content-Type\": mime.lookup(ext),\n  \"cache-control\": \"max-age=86400\", //缓存一天\n});\n```\n\n当我们第一次请求时，会正常发请求拿到资源\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba6bdbf76f7f4142adf814f086a56034~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=998&h=281&s=22453&e=png&b=fdfdfd)\n\n但当我们刷新页面再次发请求时发现，此时的履行者变为`memory cache`，大小和时间都变为 0，说明这次的资源并不是从服务器请求回来的，而是来自本地内存缓存。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/760581758f064a0ca785bd599eb88c2b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=981&h=291&s=34416&e=png&b=fdfdfd)\n\n并且我们可以在响应头中查看`Cache-Control`字段和我们设置的过期时间。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ec48160b7fc4e3fb31dee812ba8e9d3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=569&h=401&s=28906&e=png&b=fefdfd)\n\n当然`Cache-Control`不止只允许我们设置`max-age`过期时间，还有其他字段，详情可参考 [Cache-Control - HTTP | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control#%E7%BC%93%E5%AD%98%E8%AF%B7%E6%B1%82%E6%8C%87%E4%BB%A4)\n\n#### Expires\n\n`Expires`响应头是一个具体的日期/时间，告诉浏览器在这个时间点之前不需要重新请求资源。\n\n> ⚠️ 注意：如果响应中有指令为  `max-age`  或  `s-maxage`  的`Cache-Control`标头，则  `Expires`  标头会被忽略。\n\n举个栗子 🌰：\n\n```js\nres.writeHead(200, {\n  \"Content-Type\": mime.lookup(ext),\n  Expires: \"Mon Apr 22 2024 21:03:31 GMT+0800\", //过期时间戳自己选择\n});\n```\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38882c45d14349289b70dfb5937a5fc1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=707&h=405&s=30659&e=png&b=fefefe)\n\n与`Cache-Control`用法相似，就不过多赘述。\n\n### 协商缓存\n\n当强缓存过期或无效时，浏览器就会与服务器进行交互，通过发送带有特定验证头的请求来检查资源是否被修改。如果服务器确认缓存资源仍然是最新的，则返回 304 状态码，浏览器会从本地缓存加载资源。如果资源不是最新的，则返回 200 状态码和新的资源数据。\n\n#### Last-Modified 和 If-Modified-Since\n\n服务器在响应中提供`Last-Modified`日期，表明资源最后修改时间。浏览器在后续请求中使用`If-Modified-Since`头包含这个日期，如果服务器上的资源自那以后未修改，就会返回 304 状态码。\n\n举个栗子 🌰：\n\n```js\nconst stats = fs.statSync(filePath); //获取文件文件修改时的时间戳\nconst timeStamp = req.headers[\"if-modified-since\"]; //获取请求头字段\nlet status = 200; //资源修改\nif (timeStamp && Number(timeStamp) === stats.mtimeMs) {\n  //时间戳不变\n  status = 304; //资源未修改\n}\n\nres.writeHead(status, {\n  \"Content-Type\": mime.lookup(ext),\n  \"last-modified\": stats.mtimeMs, //时间戳\n});\n```\n\n通过对比这次请求头的`if-modified-since`和响应头的`last-modified`判断资源是否修改\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/494eff6380b14035b2c2b10872038d88~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=664&s=50192&e=png&b=fefefe\" alt=\"image.png\" width=\"70%\" />\n\n当资源未修改，返回 304 状态码，从缓存中拿资源。\n\n现在我们试试手动修改资源，再次刷新页面：\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c995a290776440df8a579378f5f45268~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=712&h=667&s=50667&e=png&b=fefefe\" alt=\"image.png\" width=\"70%\" />\n\n资源修改，两次时间戳不同，返回 200 状态码，和新的资源。\n\n#### ETag 和 If-None-Match\n\n`ETag`是资源的唯一标识符，反映资源的内容状态。浏览器存储这个标识并在后续请求中通过`If-None-Match`头发送它。如果`ETag`未改变，服务器返回 304 状态码。\n\n```js\nif (req.headers[\"if-none-match\"] === etag) {\n  res.writeHead(304, {\n    // 未修改，返回304\n    \"Content-Type\": mime.lookup(ext),\n    ETag: etag,\n  });\n  return res.end();\n}\n\nres.writeHead(200, {\n  //修改，返回200\n  \"Content-Type\": mime.lookup(ext),\n  ETag: etag,\n});\nreturn res.end(content);\n```\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76f551ed1d2c4a0b8e8bec1f166665ff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=714&h=644&s=49796&e=png&b=fefefe\" alt=\"image.png\" width=\"70%\" />\n\n两种协商缓存的区别是一个比较时间戳一个比较哈希值。\n\n## 总结\n\n强缓存通过设置过期时间来控制资源的缓存；而协商缓存则是通过与服务器验证资源的状态来决定是否使用缓存。协商缓存可以避免强缓存的不足之处，比如当资源在有效期内但发生了变化时，协商缓存可以保证客户端获取到最新的资源。\n\n最后配一张个人觉得总结十分到位的图（图片地址在文末）\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c58c2a8b007459ebeecb8fd3950a09f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=841&h=534&s=201743&e=png&b=eeeeee)\n\n## 参考\n\n- [HTTP 缓存 - HTTP | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching)\n- [图解 HTTP 缓存 - 掘金 (juejin.cn)](https://juejin.cn/post/6844904153043435533?searchId=20240422101749A6A836A76242BD0217C2)\n- [图片地址](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/10/171fea0fec0b4668~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n## 最后\n\n已将学习代码上传至 [github](https://github.com/YangyangU/CodeSpace)，欢迎大家学习指正！\n","source":"_posts/一文搞懂 HTTP 缓存.md","raw":"---\ntitle: 一文搞懂 HTTP 缓存\ndate: 2024-04-22 16:00:00\ntags: [HTTP]\ncategories: HTTP\nindex_img: /img/http.png\nbanner_img: /img/default.png\n---\n\n> HTTP 缓存可谓前端工程师必备技能之一，在最近的面试中，也经常被问到，那么为什么要有 HTTP 缓存，以及它是如何工作的，下面咱们展开来好好聊聊。\n\n还不知道什么是 HTTP？可以跳转到我的前一篇文章—— [捋一下 HTTP 发展史 - 掘金 (juejin.cn)](https://juejin.cn/post/7351700046486863881)\n\n## 为什么要有 HTTP 缓存\n\n缓存缓存，顾名思义就是将一些资源保存在本地，后续请求时就可以直接在本地读取，而不用请求服务器。使用 HTTP 缓存是提高性能优化和提升用户体验的关键技术，它主要体现在几个方面：\n\n> 1.  **减少延迟**：当资源被缓存后，用户可以直接从浏览器缓存或更近的网络节点（如 CDN）获取数据，而不必每次都请求原始服务器。网络延迟和数据传输时间都大大缩短了。\n> 1.  **减轻服务器负担**：通过缓存常用资源（如 Logo），服务器不必每次都处理相同的请求。\n> 1.  **节约带宽**：缓存可以显著减少需要通过网络传输的数据量，降低用户和供应商的流量成本。\n> 1.  **改善用户体验**：缓存使得网页、图片等内容的加载更快，从而直接提高了用户的浏览体验。\n> 1.  **离线浏览**：HTTP 缓存在一些场景可以让用户在没有网络连接的情况下，仍然能够访问先前加载过的内容。（如网易云音乐可以离线听之前缓存过的歌）\n> 1.  **负载均衡**：通过在多个地理位置缓存内容，避免所有请求都集中在一个服务器上。可以有效处理高流量和大规模分布的用户。\n\n总之，HTTP 缓存是前端开发者必备一项至关重要的技能，话不多说，开始介绍！\n\n## HTTP 缓存\n\nHTTP 缓存是一种客户端缓存，当浏览器向服务器发送资源请求时，服务器可以在响应头中查看是否包含缓存相关的信息。浏览器依据这些信息缓存响应资源，再次请求时如果命中缓存则直接读取本地缓存资源，而不再发请求。HTTP 缓存分为**强缓存**和**协商缓存**。\n\n### 强缓存\n\n强缓存直接决定了浏览器是否需要向服务器发起请求，只需要设置缓存的过期时间。如果强缓存有效，浏览器将直接从本地缓存中读取资源，不会与服务器进行任何交互。\n\n#### Cache-Control\n\n`Cache-Control`是通用消息头字段，被用于在 HTTP 请求和响应中，通过指定指令来实现缓存机制，通过设置`max-age=xxx`来指定资源在缓存中可以存活的最大时间（单位是秒）。\n\n举个栗子 🌰：\n\n这里我们缓存一个图片资源，过期时间为 86400 秒即一天\n\n```js\nres.writeHead(200, {\n  \"Content-Type\": mime.lookup(ext),\n  \"cache-control\": \"max-age=86400\", //缓存一天\n});\n```\n\n当我们第一次请求时，会正常发请求拿到资源\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba6bdbf76f7f4142adf814f086a56034~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=998&h=281&s=22453&e=png&b=fdfdfd)\n\n但当我们刷新页面再次发请求时发现，此时的履行者变为`memory cache`，大小和时间都变为 0，说明这次的资源并不是从服务器请求回来的，而是来自本地内存缓存。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/760581758f064a0ca785bd599eb88c2b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=981&h=291&s=34416&e=png&b=fdfdfd)\n\n并且我们可以在响应头中查看`Cache-Control`字段和我们设置的过期时间。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ec48160b7fc4e3fb31dee812ba8e9d3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=569&h=401&s=28906&e=png&b=fefdfd)\n\n当然`Cache-Control`不止只允许我们设置`max-age`过期时间，还有其他字段，详情可参考 [Cache-Control - HTTP | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control#%E7%BC%93%E5%AD%98%E8%AF%B7%E6%B1%82%E6%8C%87%E4%BB%A4)\n\n#### Expires\n\n`Expires`响应头是一个具体的日期/时间，告诉浏览器在这个时间点之前不需要重新请求资源。\n\n> ⚠️ 注意：如果响应中有指令为  `max-age`  或  `s-maxage`  的`Cache-Control`标头，则  `Expires`  标头会被忽略。\n\n举个栗子 🌰：\n\n```js\nres.writeHead(200, {\n  \"Content-Type\": mime.lookup(ext),\n  Expires: \"Mon Apr 22 2024 21:03:31 GMT+0800\", //过期时间戳自己选择\n});\n```\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38882c45d14349289b70dfb5937a5fc1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=707&h=405&s=30659&e=png&b=fefefe)\n\n与`Cache-Control`用法相似，就不过多赘述。\n\n### 协商缓存\n\n当强缓存过期或无效时，浏览器就会与服务器进行交互，通过发送带有特定验证头的请求来检查资源是否被修改。如果服务器确认缓存资源仍然是最新的，则返回 304 状态码，浏览器会从本地缓存加载资源。如果资源不是最新的，则返回 200 状态码和新的资源数据。\n\n#### Last-Modified 和 If-Modified-Since\n\n服务器在响应中提供`Last-Modified`日期，表明资源最后修改时间。浏览器在后续请求中使用`If-Modified-Since`头包含这个日期，如果服务器上的资源自那以后未修改，就会返回 304 状态码。\n\n举个栗子 🌰：\n\n```js\nconst stats = fs.statSync(filePath); //获取文件文件修改时的时间戳\nconst timeStamp = req.headers[\"if-modified-since\"]; //获取请求头字段\nlet status = 200; //资源修改\nif (timeStamp && Number(timeStamp) === stats.mtimeMs) {\n  //时间戳不变\n  status = 304; //资源未修改\n}\n\nres.writeHead(status, {\n  \"Content-Type\": mime.lookup(ext),\n  \"last-modified\": stats.mtimeMs, //时间戳\n});\n```\n\n通过对比这次请求头的`if-modified-since`和响应头的`last-modified`判断资源是否修改\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/494eff6380b14035b2c2b10872038d88~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=664&s=50192&e=png&b=fefefe\" alt=\"image.png\" width=\"70%\" />\n\n当资源未修改，返回 304 状态码，从缓存中拿资源。\n\n现在我们试试手动修改资源，再次刷新页面：\n\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c995a290776440df8a579378f5f45268~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=712&h=667&s=50667&e=png&b=fefefe\" alt=\"image.png\" width=\"70%\" />\n\n资源修改，两次时间戳不同，返回 200 状态码，和新的资源。\n\n#### ETag 和 If-None-Match\n\n`ETag`是资源的唯一标识符，反映资源的内容状态。浏览器存储这个标识并在后续请求中通过`If-None-Match`头发送它。如果`ETag`未改变，服务器返回 304 状态码。\n\n```js\nif (req.headers[\"if-none-match\"] === etag) {\n  res.writeHead(304, {\n    // 未修改，返回304\n    \"Content-Type\": mime.lookup(ext),\n    ETag: etag,\n  });\n  return res.end();\n}\n\nres.writeHead(200, {\n  //修改，返回200\n  \"Content-Type\": mime.lookup(ext),\n  ETag: etag,\n});\nreturn res.end(content);\n```\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76f551ed1d2c4a0b8e8bec1f166665ff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=714&h=644&s=49796&e=png&b=fefefe\" alt=\"image.png\" width=\"70%\" />\n\n两种协商缓存的区别是一个比较时间戳一个比较哈希值。\n\n## 总结\n\n强缓存通过设置过期时间来控制资源的缓存；而协商缓存则是通过与服务器验证资源的状态来决定是否使用缓存。协商缓存可以避免强缓存的不足之处，比如当资源在有效期内但发生了变化时，协商缓存可以保证客户端获取到最新的资源。\n\n最后配一张个人觉得总结十分到位的图（图片地址在文末）\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c58c2a8b007459ebeecb8fd3950a09f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=841&h=534&s=201743&e=png&b=eeeeee)\n\n## 参考\n\n- [HTTP 缓存 - HTTP | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching)\n- [图解 HTTP 缓存 - 掘金 (juejin.cn)](https://juejin.cn/post/6844904153043435533?searchId=20240422101749A6A836A76242BD0217C2)\n- [图片地址](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/10/171fea0fec0b4668~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n## 最后\n\n已将学习代码上传至 [github](https://github.com/YangyangU/CodeSpace)，欢迎大家学习指正！\n","slug":"一文搞懂 HTTP 缓存","published":1,"updated":"2024-09-09T15:30:54.339Z","_id":"clyww7wpe000k40v67c6k5591","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p>HTTP 缓存可谓前端工程师必备技能之一，在最近的面试中，也经常被问到，那么为什么要有 HTTP 缓存，以及它是如何工作的，下面咱们展开来好好聊聊。</p>\n</blockquote>\n<p>还不知道什么是 HTTP？可以跳转到我的前一篇文章—— <a href=\"https://juejin.cn/post/7351700046486863881\">捋一下 HTTP 发展史 - 掘金 (juejin.cn)</a></p>\n<h2 id=\"为什么要有-HTTP-缓存\"><a href=\"#为什么要有-HTTP-缓存\" class=\"headerlink\" title=\"为什么要有 HTTP 缓存\"></a>为什么要有 HTTP 缓存</h2><p>缓存缓存，顾名思义就是将一些资源保存在本地，后续请求时就可以直接在本地读取，而不用请求服务器。使用 HTTP 缓存是提高性能优化和提升用户体验的关键技术，它主要体现在几个方面：</p>\n<blockquote>\n<ol>\n<li><strong>减少延迟</strong>：当资源被缓存后，用户可以直接从浏览器缓存或更近的网络节点（如 CDN）获取数据，而不必每次都请求原始服务器。网络延迟和数据传输时间都大大缩短了。</li>\n<li><strong>减轻服务器负担</strong>：通过缓存常用资源（如 Logo），服务器不必每次都处理相同的请求。</li>\n<li><strong>节约带宽</strong>：缓存可以显著减少需要通过网络传输的数据量，降低用户和供应商的流量成本。</li>\n<li><strong>改善用户体验</strong>：缓存使得网页、图片等内容的加载更快，从而直接提高了用户的浏览体验。</li>\n<li><strong>离线浏览</strong>：HTTP 缓存在一些场景可以让用户在没有网络连接的情况下，仍然能够访问先前加载过的内容。（如网易云音乐可以离线听之前缓存过的歌）</li>\n<li><strong>负载均衡</strong>：通过在多个地理位置缓存内容，避免所有请求都集中在一个服务器上。可以有效处理高流量和大规模分布的用户。</li>\n</ol>\n</blockquote>\n<p>总之，HTTP 缓存是前端开发者必备一项至关重要的技能，话不多说，开始介绍！</p>\n<h2 id=\"HTTP-缓存\"><a href=\"#HTTP-缓存\" class=\"headerlink\" title=\"HTTP 缓存\"></a>HTTP 缓存</h2><p>HTTP 缓存是一种客户端缓存，当浏览器向服务器发送资源请求时，服务器可以在响应头中查看是否包含缓存相关的信息。浏览器依据这些信息缓存响应资源，再次请求时如果命中缓存则直接读取本地缓存资源，而不再发请求。HTTP 缓存分为<strong>强缓存</strong>和<strong>协商缓存</strong>。</p>\n<h3 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h3><p>强缓存直接决定了浏览器是否需要向服务器发起请求，只需要设置缓存的过期时间。如果强缓存有效，浏览器将直接从本地缓存中读取资源，不会与服务器进行任何交互。</p>\n<h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h4><p><code>Cache-Control</code>是通用消息头字段，被用于在 HTTP 请求和响应中，通过指定指令来实现缓存机制，通过设置<code>max-age=xxx</code>来指定资源在缓存中可以存活的最大时间（单位是秒）。</p>\n<p>举个栗子 🌰：</p>\n<p>这里我们缓存一个图片资源，过期时间为 86400 秒即一天</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">res.<span class=\"hljs-title function_\">writeHead</span>(<span class=\"hljs-number\">200</span>, &#123;<br>  <span class=\"hljs-string\">&quot;Content-Type&quot;</span>: mime.<span class=\"hljs-title function_\">lookup</span>(ext),<br>  <span class=\"hljs-string\">&quot;cache-control&quot;</span>: <span class=\"hljs-string\">&quot;max-age=86400&quot;</span>, <span class=\"hljs-comment\">//缓存一天</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>当我们第一次请求时，会正常发请求拿到资源</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba6bdbf76f7f4142adf814f086a56034~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=998&h=281&s=22453&e=png&b=fdfdfd\" alt=\"image.png\"></p>\n<p>但当我们刷新页面再次发请求时发现，此时的履行者变为<code>memory cache</code>，大小和时间都变为 0，说明这次的资源并不是从服务器请求回来的，而是来自本地内存缓存。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/760581758f064a0ca785bd599eb88c2b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=981&h=291&s=34416&e=png&b=fdfdfd\" alt=\"image.png\"></p>\n<p>并且我们可以在响应头中查看<code>Cache-Control</code>字段和我们设置的过期时间。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ec48160b7fc4e3fb31dee812ba8e9d3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=569&h=401&s=28906&e=png&b=fefdfd\" alt=\"image.png\"></p>\n<p>当然<code>Cache-Control</code>不止只允许我们设置<code>max-age</code>过期时间，还有其他字段，详情可参考 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control#%E7%BC%93%E5%AD%98%E8%AF%B7%E6%B1%82%E6%8C%87%E4%BB%A4\">Cache-Control - HTTP | MDN (mozilla.org)</a></p>\n<h4 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h4><p><code>Expires</code>响应头是一个具体的日期&#x2F;时间，告诉浏览器在这个时间点之前不需要重新请求资源。</p>\n<blockquote>\n<p>⚠️ 注意：如果响应中有指令为  <code>max-age</code>  或  <code>s-maxage</code>  的<code>Cache-Control</code>标头，则  <code>Expires</code>  标头会被忽略。</p>\n</blockquote>\n<p>举个栗子 🌰：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">res.<span class=\"hljs-title function_\">writeHead</span>(<span class=\"hljs-number\">200</span>, &#123;<br>  <span class=\"hljs-string\">&quot;Content-Type&quot;</span>: mime.<span class=\"hljs-title function_\">lookup</span>(ext),<br>  <span class=\"hljs-title class_\">Expires</span>: <span class=\"hljs-string\">&quot;Mon Apr 22 2024 21:03:31 GMT+0800&quot;</span>, <span class=\"hljs-comment\">//过期时间戳自己选择</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38882c45d14349289b70dfb5937a5fc1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=707&h=405&s=30659&e=png&b=fefefe\" alt=\"image.png\"></p>\n<p>与<code>Cache-Control</code>用法相似，就不过多赘述。</p>\n<h3 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h3><p>当强缓存过期或无效时，浏览器就会与服务器进行交互，通过发送带有特定验证头的请求来检查资源是否被修改。如果服务器确认缓存资源仍然是最新的，则返回 304 状态码，浏览器会从本地缓存加载资源。如果资源不是最新的，则返回 200 状态码和新的资源数据。</p>\n<h4 id=\"Last-Modified-和-If-Modified-Since\"><a href=\"#Last-Modified-和-If-Modified-Since\" class=\"headerlink\" title=\"Last-Modified 和 If-Modified-Since\"></a>Last-Modified 和 If-Modified-Since</h4><p>服务器在响应中提供<code>Last-Modified</code>日期，表明资源最后修改时间。浏览器在后续请求中使用<code>If-Modified-Since</code>头包含这个日期，如果服务器上的资源自那以后未修改，就会返回 304 状态码。</p>\n<p>举个栗子 🌰：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> stats = fs.<span class=\"hljs-title function_\">statSync</span>(filePath); <span class=\"hljs-comment\">//获取文件文件修改时的时间戳</span><br><span class=\"hljs-keyword\">const</span> timeStamp = req.<span class=\"hljs-property\">headers</span>[<span class=\"hljs-string\">&quot;if-modified-since&quot;</span>]; <span class=\"hljs-comment\">//获取请求头字段</span><br><span class=\"hljs-keyword\">let</span> status = <span class=\"hljs-number\">200</span>; <span class=\"hljs-comment\">//资源修改</span><br><span class=\"hljs-keyword\">if</span> (timeStamp &amp;&amp; <span class=\"hljs-title class_\">Number</span>(timeStamp) === stats.<span class=\"hljs-property\">mtimeMs</span>) &#123;<br>  <span class=\"hljs-comment\">//时间戳不变</span><br>  status = <span class=\"hljs-number\">304</span>; <span class=\"hljs-comment\">//资源未修改</span><br>&#125;<br><br>res.<span class=\"hljs-title function_\">writeHead</span>(status, &#123;<br>  <span class=\"hljs-string\">&quot;Content-Type&quot;</span>: mime.<span class=\"hljs-title function_\">lookup</span>(ext),<br>  <span class=\"hljs-string\">&quot;last-modified&quot;</span>: stats.<span class=\"hljs-property\">mtimeMs</span>, <span class=\"hljs-comment\">//时间戳</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>通过对比这次请求头的<code>if-modified-since</code>和响应头的<code>last-modified</code>判断资源是否修改</p>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/494eff6380b14035b2c2b10872038d88~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=664&s=50192&e=png&b=fefefe\" alt=\"image.png\" width=\"70%\" />\n\n<p>当资源未修改，返回 304 状态码，从缓存中拿资源。</p>\n<p>现在我们试试手动修改资源，再次刷新页面：</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c995a290776440df8a579378f5f45268~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=712&h=667&s=50667&e=png&b=fefefe\" alt=\"image.png\" width=\"70%\" />\n\n<p>资源修改，两次时间戳不同，返回 200 状态码，和新的资源。</p>\n<h4 id=\"ETag-和-If-None-Match\"><a href=\"#ETag-和-If-None-Match\" class=\"headerlink\" title=\"ETag 和 If-None-Match\"></a>ETag 和 If-None-Match</h4><p><code>ETag</code>是资源的唯一标识符，反映资源的内容状态。浏览器存储这个标识并在后续请求中通过<code>If-None-Match</code>头发送它。如果<code>ETag</code>未改变，服务器返回 304 状态码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">if</span> (req.<span class=\"hljs-property\">headers</span>[<span class=\"hljs-string\">&quot;if-none-match&quot;</span>] === etag) &#123;<br>  res.<span class=\"hljs-title function_\">writeHead</span>(<span class=\"hljs-number\">304</span>, &#123;<br>    <span class=\"hljs-comment\">// 未修改，返回304</span><br>    <span class=\"hljs-string\">&quot;Content-Type&quot;</span>: mime.<span class=\"hljs-title function_\">lookup</span>(ext),<br>    <span class=\"hljs-title class_\">ETag</span>: etag,<br>  &#125;);<br>  <span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-title function_\">end</span>();<br>&#125;<br><br>res.<span class=\"hljs-title function_\">writeHead</span>(<span class=\"hljs-number\">200</span>, &#123;<br>  <span class=\"hljs-comment\">//修改，返回200</span><br>  <span class=\"hljs-string\">&quot;Content-Type&quot;</span>: mime.<span class=\"hljs-title function_\">lookup</span>(ext),<br>  <span class=\"hljs-title class_\">ETag</span>: etag,<br>&#125;);<br><span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-title function_\">end</span>(content);<br></code></pre></td></tr></table></figure>\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76f551ed1d2c4a0b8e8bec1f166665ff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=714&h=644&s=49796&e=png&b=fefefe\" alt=\"image.png\" width=\"70%\" />\n\n<p>两种协商缓存的区别是一个比较时间戳一个比较哈希值。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>强缓存通过设置过期时间来控制资源的缓存；而协商缓存则是通过与服务器验证资源的状态来决定是否使用缓存。协商缓存可以避免强缓存的不足之处，比如当资源在有效期内但发生了变化时，协商缓存可以保证客户端获取到最新的资源。</p>\n<p>最后配一张个人觉得总结十分到位的图（图片地址在文末）</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c58c2a8b007459ebeecb8fd3950a09f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=841&h=534&s=201743&e=png&b=eeeeee\" alt=\"image.png\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching\">HTTP 缓存 - HTTP | MDN (mozilla.org)</a></li>\n<li><a href=\"https://juejin.cn/post/6844904153043435533?searchId=20240422101749A6A836A76242BD0217C2\">图解 HTTP 缓存 - 掘金 (juejin.cn)</a></li>\n<li><a href=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/10/171fea0fec0b4668~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\">图片地址</a></li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>已将学习代码上传至 <a href=\"https://github.com/YangyangU/CodeSpace\">github</a>，欢迎大家学习指正！</p>\n","excerpt":"","more":"<blockquote>\n<p>HTTP 缓存可谓前端工程师必备技能之一，在最近的面试中，也经常被问到，那么为什么要有 HTTP 缓存，以及它是如何工作的，下面咱们展开来好好聊聊。</p>\n</blockquote>\n<p>还不知道什么是 HTTP？可以跳转到我的前一篇文章—— <a href=\"https://juejin.cn/post/7351700046486863881\">捋一下 HTTP 发展史 - 掘金 (juejin.cn)</a></p>\n<h2 id=\"为什么要有-HTTP-缓存\"><a href=\"#为什么要有-HTTP-缓存\" class=\"headerlink\" title=\"为什么要有 HTTP 缓存\"></a>为什么要有 HTTP 缓存</h2><p>缓存缓存，顾名思义就是将一些资源保存在本地，后续请求时就可以直接在本地读取，而不用请求服务器。使用 HTTP 缓存是提高性能优化和提升用户体验的关键技术，它主要体现在几个方面：</p>\n<blockquote>\n<ol>\n<li><strong>减少延迟</strong>：当资源被缓存后，用户可以直接从浏览器缓存或更近的网络节点（如 CDN）获取数据，而不必每次都请求原始服务器。网络延迟和数据传输时间都大大缩短了。</li>\n<li><strong>减轻服务器负担</strong>：通过缓存常用资源（如 Logo），服务器不必每次都处理相同的请求。</li>\n<li><strong>节约带宽</strong>：缓存可以显著减少需要通过网络传输的数据量，降低用户和供应商的流量成本。</li>\n<li><strong>改善用户体验</strong>：缓存使得网页、图片等内容的加载更快，从而直接提高了用户的浏览体验。</li>\n<li><strong>离线浏览</strong>：HTTP 缓存在一些场景可以让用户在没有网络连接的情况下，仍然能够访问先前加载过的内容。（如网易云音乐可以离线听之前缓存过的歌）</li>\n<li><strong>负载均衡</strong>：通过在多个地理位置缓存内容，避免所有请求都集中在一个服务器上。可以有效处理高流量和大规模分布的用户。</li>\n</ol>\n</blockquote>\n<p>总之，HTTP 缓存是前端开发者必备一项至关重要的技能，话不多说，开始介绍！</p>\n<h2 id=\"HTTP-缓存\"><a href=\"#HTTP-缓存\" class=\"headerlink\" title=\"HTTP 缓存\"></a>HTTP 缓存</h2><p>HTTP 缓存是一种客户端缓存，当浏览器向服务器发送资源请求时，服务器可以在响应头中查看是否包含缓存相关的信息。浏览器依据这些信息缓存响应资源，再次请求时如果命中缓存则直接读取本地缓存资源，而不再发请求。HTTP 缓存分为<strong>强缓存</strong>和<strong>协商缓存</strong>。</p>\n<h3 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h3><p>强缓存直接决定了浏览器是否需要向服务器发起请求，只需要设置缓存的过期时间。如果强缓存有效，浏览器将直接从本地缓存中读取资源，不会与服务器进行任何交互。</p>\n<h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h4><p><code>Cache-Control</code>是通用消息头字段，被用于在 HTTP 请求和响应中，通过指定指令来实现缓存机制，通过设置<code>max-age=xxx</code>来指定资源在缓存中可以存活的最大时间（单位是秒）。</p>\n<p>举个栗子 🌰：</p>\n<p>这里我们缓存一个图片资源，过期时间为 86400 秒即一天</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">res.<span class=\"hljs-title function_\">writeHead</span>(<span class=\"hljs-number\">200</span>, &#123;<br>  <span class=\"hljs-string\">&quot;Content-Type&quot;</span>: mime.<span class=\"hljs-title function_\">lookup</span>(ext),<br>  <span class=\"hljs-string\">&quot;cache-control&quot;</span>: <span class=\"hljs-string\">&quot;max-age=86400&quot;</span>, <span class=\"hljs-comment\">//缓存一天</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>当我们第一次请求时，会正常发请求拿到资源</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba6bdbf76f7f4142adf814f086a56034~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=998&h=281&s=22453&e=png&b=fdfdfd\" alt=\"image.png\"></p>\n<p>但当我们刷新页面再次发请求时发现，此时的履行者变为<code>memory cache</code>，大小和时间都变为 0，说明这次的资源并不是从服务器请求回来的，而是来自本地内存缓存。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/760581758f064a0ca785bd599eb88c2b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=981&h=291&s=34416&e=png&b=fdfdfd\" alt=\"image.png\"></p>\n<p>并且我们可以在响应头中查看<code>Cache-Control</code>字段和我们设置的过期时间。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ec48160b7fc4e3fb31dee812ba8e9d3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=569&h=401&s=28906&e=png&b=fefdfd\" alt=\"image.png\"></p>\n<p>当然<code>Cache-Control</code>不止只允许我们设置<code>max-age</code>过期时间，还有其他字段，详情可参考 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control#%E7%BC%93%E5%AD%98%E8%AF%B7%E6%B1%82%E6%8C%87%E4%BB%A4\">Cache-Control - HTTP | MDN (mozilla.org)</a></p>\n<h4 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h4><p><code>Expires</code>响应头是一个具体的日期&#x2F;时间，告诉浏览器在这个时间点之前不需要重新请求资源。</p>\n<blockquote>\n<p>⚠️ 注意：如果响应中有指令为  <code>max-age</code>  或  <code>s-maxage</code>  的<code>Cache-Control</code>标头，则  <code>Expires</code>  标头会被忽略。</p>\n</blockquote>\n<p>举个栗子 🌰：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">res.<span class=\"hljs-title function_\">writeHead</span>(<span class=\"hljs-number\">200</span>, &#123;<br>  <span class=\"hljs-string\">&quot;Content-Type&quot;</span>: mime.<span class=\"hljs-title function_\">lookup</span>(ext),<br>  <span class=\"hljs-title class_\">Expires</span>: <span class=\"hljs-string\">&quot;Mon Apr 22 2024 21:03:31 GMT+0800&quot;</span>, <span class=\"hljs-comment\">//过期时间戳自己选择</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38882c45d14349289b70dfb5937a5fc1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=707&h=405&s=30659&e=png&b=fefefe\" alt=\"image.png\"></p>\n<p>与<code>Cache-Control</code>用法相似，就不过多赘述。</p>\n<h3 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h3><p>当强缓存过期或无效时，浏览器就会与服务器进行交互，通过发送带有特定验证头的请求来检查资源是否被修改。如果服务器确认缓存资源仍然是最新的，则返回 304 状态码，浏览器会从本地缓存加载资源。如果资源不是最新的，则返回 200 状态码和新的资源数据。</p>\n<h4 id=\"Last-Modified-和-If-Modified-Since\"><a href=\"#Last-Modified-和-If-Modified-Since\" class=\"headerlink\" title=\"Last-Modified 和 If-Modified-Since\"></a>Last-Modified 和 If-Modified-Since</h4><p>服务器在响应中提供<code>Last-Modified</code>日期，表明资源最后修改时间。浏览器在后续请求中使用<code>If-Modified-Since</code>头包含这个日期，如果服务器上的资源自那以后未修改，就会返回 304 状态码。</p>\n<p>举个栗子 🌰：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> stats = fs.<span class=\"hljs-title function_\">statSync</span>(filePath); <span class=\"hljs-comment\">//获取文件文件修改时的时间戳</span><br><span class=\"hljs-keyword\">const</span> timeStamp = req.<span class=\"hljs-property\">headers</span>[<span class=\"hljs-string\">&quot;if-modified-since&quot;</span>]; <span class=\"hljs-comment\">//获取请求头字段</span><br><span class=\"hljs-keyword\">let</span> status = <span class=\"hljs-number\">200</span>; <span class=\"hljs-comment\">//资源修改</span><br><span class=\"hljs-keyword\">if</span> (timeStamp &amp;&amp; <span class=\"hljs-title class_\">Number</span>(timeStamp) === stats.<span class=\"hljs-property\">mtimeMs</span>) &#123;<br>  <span class=\"hljs-comment\">//时间戳不变</span><br>  status = <span class=\"hljs-number\">304</span>; <span class=\"hljs-comment\">//资源未修改</span><br>&#125;<br><br>res.<span class=\"hljs-title function_\">writeHead</span>(status, &#123;<br>  <span class=\"hljs-string\">&quot;Content-Type&quot;</span>: mime.<span class=\"hljs-title function_\">lookup</span>(ext),<br>  <span class=\"hljs-string\">&quot;last-modified&quot;</span>: stats.<span class=\"hljs-property\">mtimeMs</span>, <span class=\"hljs-comment\">//时间戳</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>通过对比这次请求头的<code>if-modified-since</code>和响应头的<code>last-modified</code>判断资源是否修改</p>\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/494eff6380b14035b2c2b10872038d88~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=664&s=50192&e=png&b=fefefe\" alt=\"image.png\" width=\"70%\" />\n\n<p>当资源未修改，返回 304 状态码，从缓存中拿资源。</p>\n<p>现在我们试试手动修改资源，再次刷新页面：</p>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c995a290776440df8a579378f5f45268~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=712&h=667&s=50667&e=png&b=fefefe\" alt=\"image.png\" width=\"70%\" />\n\n<p>资源修改，两次时间戳不同，返回 200 状态码，和新的资源。</p>\n<h4 id=\"ETag-和-If-None-Match\"><a href=\"#ETag-和-If-None-Match\" class=\"headerlink\" title=\"ETag 和 If-None-Match\"></a>ETag 和 If-None-Match</h4><p><code>ETag</code>是资源的唯一标识符，反映资源的内容状态。浏览器存储这个标识并在后续请求中通过<code>If-None-Match</code>头发送它。如果<code>ETag</code>未改变，服务器返回 304 状态码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">if</span> (req.<span class=\"hljs-property\">headers</span>[<span class=\"hljs-string\">&quot;if-none-match&quot;</span>] === etag) &#123;<br>  res.<span class=\"hljs-title function_\">writeHead</span>(<span class=\"hljs-number\">304</span>, &#123;<br>    <span class=\"hljs-comment\">// 未修改，返回304</span><br>    <span class=\"hljs-string\">&quot;Content-Type&quot;</span>: mime.<span class=\"hljs-title function_\">lookup</span>(ext),<br>    <span class=\"hljs-title class_\">ETag</span>: etag,<br>  &#125;);<br>  <span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-title function_\">end</span>();<br>&#125;<br><br>res.<span class=\"hljs-title function_\">writeHead</span>(<span class=\"hljs-number\">200</span>, &#123;<br>  <span class=\"hljs-comment\">//修改，返回200</span><br>  <span class=\"hljs-string\">&quot;Content-Type&quot;</span>: mime.<span class=\"hljs-title function_\">lookup</span>(ext),<br>  <span class=\"hljs-title class_\">ETag</span>: etag,<br>&#125;);<br><span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-title function_\">end</span>(content);<br></code></pre></td></tr></table></figure>\n\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76f551ed1d2c4a0b8e8bec1f166665ff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=714&h=644&s=49796&e=png&b=fefefe\" alt=\"image.png\" width=\"70%\" />\n\n<p>两种协商缓存的区别是一个比较时间戳一个比较哈希值。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>强缓存通过设置过期时间来控制资源的缓存；而协商缓存则是通过与服务器验证资源的状态来决定是否使用缓存。协商缓存可以避免强缓存的不足之处，比如当资源在有效期内但发生了变化时，协商缓存可以保证客户端获取到最新的资源。</p>\n<p>最后配一张个人觉得总结十分到位的图（图片地址在文末）</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c58c2a8b007459ebeecb8fd3950a09f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=841&h=534&s=201743&e=png&b=eeeeee\" alt=\"image.png\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching\">HTTP 缓存 - HTTP | MDN (mozilla.org)</a></li>\n<li><a href=\"https://juejin.cn/post/6844904153043435533?searchId=20240422101749A6A836A76242BD0217C2\">图解 HTTP 缓存 - 掘金 (juejin.cn)</a></li>\n<li><a href=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/10/171fea0fec0b4668~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp\">图片地址</a></li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>已将学习代码上传至 <a href=\"https://github.com/YangyangU/CodeSpace\">github</a>，欢迎大家学习指正！</p>\n"},{"title":"React 对比 Vue 如何做路由鉴权？","date":"2024-09-09T08:00:00.000Z","index_img":"/img/路由鉴权.jpg","banner_img":"/img/default.png","_content":"\n\n## 前言\n\n学过 Vue 的小伙伴肯定知道，在 Vue 中，路由守卫可以帮助我们一站式进行路由鉴权。我们只需要在全局前置路由守卫 (`beforeEach`) 钩子函数中判断逻辑即可，方便快捷。\n\n但是在 React 中，如何实现类似的功能呢？本文将对比 Vue 和 React 路由鉴权的方式，带你了解如何在 React 中配置路由并实现路由鉴权。\n\n## 在Vue中如何实现\n\n以 Vue3 为例\n\n### 配置路由\n\n这里我们简单配置了三个路由，首页、关于和登录页面，除了登录页外都需要登录。\n\n```js\n// router/index.js\nimport { createRouter, createWebHistory } from 'vue-router';\nimport Home from '@/views/Home.vue';\nimport About from '@/views/About.vue';\nimport Login from '@/views/Login.vue';\n\nconst routes = [\n    {\n        path: '/',\n        name: 'Home',\n        meta: {\n            title: '首页',\n            needLogin: true,\n        },\n        component: Home,\n    },\n    {\n        path: '/about',\n        name: 'About',\n        meta: {\n            title: '关于',\n            needLogin: true,\n        },\n        component: About,\n    },\n    {\n        path: '/login',\n        name: 'Login',\n        meta: {\n            title: '登录',\n        },\n        component: Login,\n    },\n];\n\nconst router = createRouter({\n    history: createWebHistory(),\n    routes,\n});\n\nexport default router;\n```\n\n这里我们在路由中添加了一个`meta`属性，它一般用来存储路由的元信息，什么意思，就是我们可以通过这个对象来判断某个路由是否需要登录权限、页面标题、特定布局等等信息。\n\n这里我们设置 `meta.needLogin` 来标识某个路由是否需要登录权限，通过 `meta.title` 来设置页面标题，然后在路由守卫中动态更改 `document.title`即可。\n\n### 路由守卫\n\n为什么路由守卫能做？\n\n路由守卫是 Vue Router 中用于控制路由导航行为的功能。它允许在用户从一个路由导航到另一个路由之前、期间或之后执行自定义逻辑。\n\n而**全局前置路由守卫**是在每次路由导航开始前都会被调用。\n\n这样我们只需在路由跳转前，即全局前置路由守卫中去判断要去的路由是否需要登陆，并且判断用户是否登录即可！！\n\n```js\n// main.js\nimport { createApp } from 'vue';\nimport App from './App.vue';\nimport router from './router';\n\nconst app = createApp(App);\n\nrouter.beforeEach((to, from, next) => {\n    const token = localStorage.getItem('my-token'); //用户登陆自动生成的token\n\n    if (to.meta.title) {\n        document.title = to.meta.title; //设置路由标题\n    }\n\n    if (to.meta.needLogin && !token) { // 如果需要登录但是未登录，跳转到登录页面\n        next('/login');\n    } else { //否则放行\n        next();\n    }\n});\n\napp.use(router).mount('#app');\n```\n\n在 Vue 中，实现路由拦截鉴权的核心是使用 Vue Router 提供的 `beforeEach` 全局前置守卫。在这个守卫函数中，我们可以根据路由的 `meta.needLogin` 属性，判断是否需要进行登录验证。如果用户未登录且访问了需要登录的页面，则重定向至登录页。\n\n\n## 在React中怎么实现\n\nVue 中很容易实现，问题来了，React 中怎么做？\n\n这里，我们使用 React Router 6的最新的路由配置写法，跟 Vue 简直不要太像\n\n### 配置路由\n\n首先第一步同样是配置路由\n\n```js\n// router/index.js\nimport { createBrowserRouter } from 'react-router-dom';\n\nimport Layout from '@/components/Layout';\nimport Home from '@/pages/Home';\nimport About from '@/pages/About';\nimport Login from '@/pages/Login';\n\nexport const routes = [\n    {\n        path: 'home',\n        index: true,\n        meta: {\n            title: '首页',\n            needLogin: true,\n        },\n        element: <Home />,\n    },\n    {\n        path: 'about',\n        meta: {\n            title: '关于',\n            needLogin: true,\n        },\n        element: <About />,\n    },\n    {\n        path: '/login',\n        element: <Login />,\n    },\n];\n\nconst router = createBrowserRouter(routes);\n\nexport default router;\n```\n\n这里路由对象写法跟 Vue Router 不能说很像，只能说一模一样了，道理都一样，设置`meta`属性，将需要登录的路由，设置`needLogin`为`true`。\n\n### 1. 组件内部直接判断\n\n跟 Vue 的区别来了，React 可没有路由守卫这一说法，但是道理都一样，我们只需在路由跳转页面展示前一刻判断是否需要登录以及用户是否登录。\n\n但是React怎么实现在跳转前判断逻辑呢？\n\n第一种方法，也是最好想的方法，直接在组件内部的 `useEffect` 钩子中进行判断，条件不满足重定向去登录即可。\n\n我们知道`useEffect`在函数组件中充当特定的生命周期，就能在组件渲染前进行逻辑判断\n\n以 Home 页面为例\n\n```js\nimport React, { useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\n\nconst Home = () => {\n  const navigate = useNavigate();\n  const token = localStorage.getItem('my-token');\n\n  useEffect(() => {\n    if (!token) {\n      navigate('/login');\n    }\n  }, [navigate, token]);\n\n  return <div>Home Page</div>;\n};\n\nexport default Home;\n```\n\n这里我们使用`useEffect`钩子，当页面初次加载或依赖项更新的时候就会重新执行，能够达到我们目的。\n\n我们直接在组件加载前判断用户是否登录，哪里需要登录就在哪里判断，甚至省去了路由配置中的`meta`属性。\n\n⚠️但是这种方法太笨了，每个需要登录的页面都需要单独写一套这样的代码，很明显可以复用。于是便有了下面这个方法。\n\n### 2. 高阶组件\n\n高阶组件本质上是一个函数，它接受一个组件作为输入，然后返回一个新的组件。我们可以在这个新组件渲染之前，即在父组件中操作，进行鉴权逻辑判断以实现类似 Vue 前置路由守卫的功能。\n\n```tsx\n// router/Auth.jsx\nimport React from 'react';\nimport { Navigate, useLocation } from 'react-router-dom';\nimport { routes, RouterWithTabAuthObject } from './';\n\n// 获取当前路由的元数据\nconst getRouteMeta = (path, routes) => {\n    for (const route of routes) {\n        if (route.path === path) return route;\n        if (route.children) {\n            const childRoute = getRouteMeta(path, route.children);\n            if (childRoute) return childRoute;\n        }\n    }\n    return undefined;\n};\n\nconst Auth = (props) => {\n    const location = useLocation();\n    const token = localStorage.getItem('my-token');\n\n    const currentRoute = getRouteMeta(location.pathname, routes);\n\n    // 设置页面标题\n    if (currentRoute?.meta?.title) {\n        document.title = currentRoute.meta.title;\n    }\n\n    // 如果需要登录但没有 token，重定向到登录页\n    if (currentRoute?.meta?.needLogin && !token) {\n        return <Navigate to=\"/login\" replace />;\n    }\n    \n    return <>{props.children}</>;\n};\n\nexport default Auth;\n```\n\n这里逻辑其实跟前置路由守卫是一致，只不过Vue帮你做了封装，显得代码没有那么多，比较简单。\n\n我们来归纳一下，`beforeEach`可以直接通过`to.meta`直接拿到元数据，但是 React 需要判断当前`loaction`和`routes`路由对象进行查找才能找到对应的路由对象，即此处的`getRouteMeta`方法，如果有`children`还需要递归查找，其实 Vue 底层也是这样实现的。\n\n然后通过条件判断和重定向实现鉴权，最后如果不需要重定向，正常渲染 `props.children`，即子组件。\n\n#### 全局注册\n\n`Auth`组件已经完成，还需要做一步操作，我们需要用这个高阶将所有路由包裹起来，才能发挥作用。\n\n```jsx\nimport { Layout } from 'antd';\nimport { Outlet } from 'react-router-dom';\nimport Aside from '@/components/Aside';\nimport Header from '@/components/Header';\nimport Auth from '@/router/Auth';\n\nconst View = () => {\n    return (\n        <Auth>\n            <Layout>\n                <Aside />\n                    <Header />\n                    <Content>\n                        <Outlet />\n                    </Content>\n            </Layout>\n        </Auth>\n    );\n};\n\nexport default View;\n```\n\n这里我一般习惯于将`Auth`包裹`<Layout>`组件，如果你没用到`Layout`，包裹`App`也是可以的。\n\n## 总结\n\n- 在`Vue`中，实现路由拦截鉴权的核心就是使用 `beforeEach` 全局前置守卫。\n\n- 在`React`中，暂且不考虑第一种组件内部判断的话，实现路由拦截鉴权就是将**每个**路由组件使用**高阶组件**进行包裹，在这个高阶组件里面进行权限相关逻辑的判断。\n\n总而言之，其实不管是 Vue 还是 React 两者的核心思想相同，都是在用户访问受保护页面前，检查其登录状态，并根据检查结果决定是否允许访问，如何找到这的时间点才是关键！\n","source":"_posts/React对比Vue如何做路由鉴权.md","raw":"---\ntitle: React 对比 Vue 如何做路由鉴权？\ndate: 2024-09-9 16:00:00\ntags: [React, Vue]\ncategories: React\nindex_img: /img/路由鉴权.jpg\nbanner_img: /img/default.png\n---\n\n\n## 前言\n\n学过 Vue 的小伙伴肯定知道，在 Vue 中，路由守卫可以帮助我们一站式进行路由鉴权。我们只需要在全局前置路由守卫 (`beforeEach`) 钩子函数中判断逻辑即可，方便快捷。\n\n但是在 React 中，如何实现类似的功能呢？本文将对比 Vue 和 React 路由鉴权的方式，带你了解如何在 React 中配置路由并实现路由鉴权。\n\n## 在Vue中如何实现\n\n以 Vue3 为例\n\n### 配置路由\n\n这里我们简单配置了三个路由，首页、关于和登录页面，除了登录页外都需要登录。\n\n```js\n// router/index.js\nimport { createRouter, createWebHistory } from 'vue-router';\nimport Home from '@/views/Home.vue';\nimport About from '@/views/About.vue';\nimport Login from '@/views/Login.vue';\n\nconst routes = [\n    {\n        path: '/',\n        name: 'Home',\n        meta: {\n            title: '首页',\n            needLogin: true,\n        },\n        component: Home,\n    },\n    {\n        path: '/about',\n        name: 'About',\n        meta: {\n            title: '关于',\n            needLogin: true,\n        },\n        component: About,\n    },\n    {\n        path: '/login',\n        name: 'Login',\n        meta: {\n            title: '登录',\n        },\n        component: Login,\n    },\n];\n\nconst router = createRouter({\n    history: createWebHistory(),\n    routes,\n});\n\nexport default router;\n```\n\n这里我们在路由中添加了一个`meta`属性，它一般用来存储路由的元信息，什么意思，就是我们可以通过这个对象来判断某个路由是否需要登录权限、页面标题、特定布局等等信息。\n\n这里我们设置 `meta.needLogin` 来标识某个路由是否需要登录权限，通过 `meta.title` 来设置页面标题，然后在路由守卫中动态更改 `document.title`即可。\n\n### 路由守卫\n\n为什么路由守卫能做？\n\n路由守卫是 Vue Router 中用于控制路由导航行为的功能。它允许在用户从一个路由导航到另一个路由之前、期间或之后执行自定义逻辑。\n\n而**全局前置路由守卫**是在每次路由导航开始前都会被调用。\n\n这样我们只需在路由跳转前，即全局前置路由守卫中去判断要去的路由是否需要登陆，并且判断用户是否登录即可！！\n\n```js\n// main.js\nimport { createApp } from 'vue';\nimport App from './App.vue';\nimport router from './router';\n\nconst app = createApp(App);\n\nrouter.beforeEach((to, from, next) => {\n    const token = localStorage.getItem('my-token'); //用户登陆自动生成的token\n\n    if (to.meta.title) {\n        document.title = to.meta.title; //设置路由标题\n    }\n\n    if (to.meta.needLogin && !token) { // 如果需要登录但是未登录，跳转到登录页面\n        next('/login');\n    } else { //否则放行\n        next();\n    }\n});\n\napp.use(router).mount('#app');\n```\n\n在 Vue 中，实现路由拦截鉴权的核心是使用 Vue Router 提供的 `beforeEach` 全局前置守卫。在这个守卫函数中，我们可以根据路由的 `meta.needLogin` 属性，判断是否需要进行登录验证。如果用户未登录且访问了需要登录的页面，则重定向至登录页。\n\n\n## 在React中怎么实现\n\nVue 中很容易实现，问题来了，React 中怎么做？\n\n这里，我们使用 React Router 6的最新的路由配置写法，跟 Vue 简直不要太像\n\n### 配置路由\n\n首先第一步同样是配置路由\n\n```js\n// router/index.js\nimport { createBrowserRouter } from 'react-router-dom';\n\nimport Layout from '@/components/Layout';\nimport Home from '@/pages/Home';\nimport About from '@/pages/About';\nimport Login from '@/pages/Login';\n\nexport const routes = [\n    {\n        path: 'home',\n        index: true,\n        meta: {\n            title: '首页',\n            needLogin: true,\n        },\n        element: <Home />,\n    },\n    {\n        path: 'about',\n        meta: {\n            title: '关于',\n            needLogin: true,\n        },\n        element: <About />,\n    },\n    {\n        path: '/login',\n        element: <Login />,\n    },\n];\n\nconst router = createBrowserRouter(routes);\n\nexport default router;\n```\n\n这里路由对象写法跟 Vue Router 不能说很像，只能说一模一样了，道理都一样，设置`meta`属性，将需要登录的路由，设置`needLogin`为`true`。\n\n### 1. 组件内部直接判断\n\n跟 Vue 的区别来了，React 可没有路由守卫这一说法，但是道理都一样，我们只需在路由跳转页面展示前一刻判断是否需要登录以及用户是否登录。\n\n但是React怎么实现在跳转前判断逻辑呢？\n\n第一种方法，也是最好想的方法，直接在组件内部的 `useEffect` 钩子中进行判断，条件不满足重定向去登录即可。\n\n我们知道`useEffect`在函数组件中充当特定的生命周期，就能在组件渲染前进行逻辑判断\n\n以 Home 页面为例\n\n```js\nimport React, { useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\n\nconst Home = () => {\n  const navigate = useNavigate();\n  const token = localStorage.getItem('my-token');\n\n  useEffect(() => {\n    if (!token) {\n      navigate('/login');\n    }\n  }, [navigate, token]);\n\n  return <div>Home Page</div>;\n};\n\nexport default Home;\n```\n\n这里我们使用`useEffect`钩子，当页面初次加载或依赖项更新的时候就会重新执行，能够达到我们目的。\n\n我们直接在组件加载前判断用户是否登录，哪里需要登录就在哪里判断，甚至省去了路由配置中的`meta`属性。\n\n⚠️但是这种方法太笨了，每个需要登录的页面都需要单独写一套这样的代码，很明显可以复用。于是便有了下面这个方法。\n\n### 2. 高阶组件\n\n高阶组件本质上是一个函数，它接受一个组件作为输入，然后返回一个新的组件。我们可以在这个新组件渲染之前，即在父组件中操作，进行鉴权逻辑判断以实现类似 Vue 前置路由守卫的功能。\n\n```tsx\n// router/Auth.jsx\nimport React from 'react';\nimport { Navigate, useLocation } from 'react-router-dom';\nimport { routes, RouterWithTabAuthObject } from './';\n\n// 获取当前路由的元数据\nconst getRouteMeta = (path, routes) => {\n    for (const route of routes) {\n        if (route.path === path) return route;\n        if (route.children) {\n            const childRoute = getRouteMeta(path, route.children);\n            if (childRoute) return childRoute;\n        }\n    }\n    return undefined;\n};\n\nconst Auth = (props) => {\n    const location = useLocation();\n    const token = localStorage.getItem('my-token');\n\n    const currentRoute = getRouteMeta(location.pathname, routes);\n\n    // 设置页面标题\n    if (currentRoute?.meta?.title) {\n        document.title = currentRoute.meta.title;\n    }\n\n    // 如果需要登录但没有 token，重定向到登录页\n    if (currentRoute?.meta?.needLogin && !token) {\n        return <Navigate to=\"/login\" replace />;\n    }\n    \n    return <>{props.children}</>;\n};\n\nexport default Auth;\n```\n\n这里逻辑其实跟前置路由守卫是一致，只不过Vue帮你做了封装，显得代码没有那么多，比较简单。\n\n我们来归纳一下，`beforeEach`可以直接通过`to.meta`直接拿到元数据，但是 React 需要判断当前`loaction`和`routes`路由对象进行查找才能找到对应的路由对象，即此处的`getRouteMeta`方法，如果有`children`还需要递归查找，其实 Vue 底层也是这样实现的。\n\n然后通过条件判断和重定向实现鉴权，最后如果不需要重定向，正常渲染 `props.children`，即子组件。\n\n#### 全局注册\n\n`Auth`组件已经完成，还需要做一步操作，我们需要用这个高阶将所有路由包裹起来，才能发挥作用。\n\n```jsx\nimport { Layout } from 'antd';\nimport { Outlet } from 'react-router-dom';\nimport Aside from '@/components/Aside';\nimport Header from '@/components/Header';\nimport Auth from '@/router/Auth';\n\nconst View = () => {\n    return (\n        <Auth>\n            <Layout>\n                <Aside />\n                    <Header />\n                    <Content>\n                        <Outlet />\n                    </Content>\n            </Layout>\n        </Auth>\n    );\n};\n\nexport default View;\n```\n\n这里我一般习惯于将`Auth`包裹`<Layout>`组件，如果你没用到`Layout`，包裹`App`也是可以的。\n\n## 总结\n\n- 在`Vue`中，实现路由拦截鉴权的核心就是使用 `beforeEach` 全局前置守卫。\n\n- 在`React`中，暂且不考虑第一种组件内部判断的话，实现路由拦截鉴权就是将**每个**路由组件使用**高阶组件**进行包裹，在这个高阶组件里面进行权限相关逻辑的判断。\n\n总而言之，其实不管是 Vue 还是 React 两者的核心思想相同，都是在用户访问受保护页面前，检查其登录状态，并根据检查结果决定是否允许访问，如何找到这的时间点才是关键！\n","slug":"React对比Vue如何做路由鉴权","published":1,"updated":"2024-09-09T15:18:34.145Z","_id":"cm0v577p700000ov6hcoehiv1","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>学过 Vue 的小伙伴肯定知道，在 Vue 中，路由守卫可以帮助我们一站式进行路由鉴权。我们只需要在全局前置路由守卫 (<code>beforeEach</code>) 钩子函数中判断逻辑即可，方便快捷。</p>\n<p>但是在 React 中，如何实现类似的功能呢？本文将对比 Vue 和 React 路由鉴权的方式，带你了解如何在 React 中配置路由并实现路由鉴权。</p>\n<h2 id=\"在Vue中如何实现\"><a href=\"#在Vue中如何实现\" class=\"headerlink\" title=\"在Vue中如何实现\"></a>在Vue中如何实现</h2><p>以 Vue3 为例</p>\n<h3 id=\"配置路由\"><a href=\"#配置路由\" class=\"headerlink\" title=\"配置路由\"></a>配置路由</h3><p>这里我们简单配置了三个路由，首页、关于和登录页面，除了登录页外都需要登录。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// router/index.js</span><br><span class=\"hljs-keyword\">import</span> &#123; createRouter, createWebHistory &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vue-router&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Home</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@/views/Home.vue&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">About</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@/views/About.vue&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Login</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@/views/Login.vue&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> routes = [<br>    &#123;<br>        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/&#x27;</span>,<br>        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;Home&#x27;</span>,<br>        <span class=\"hljs-attr\">meta</span>: &#123;<br>            <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;首页&#x27;</span>,<br>            <span class=\"hljs-attr\">needLogin</span>: <span class=\"hljs-literal\">true</span>,<br>        &#125;,<br>        <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">Home</span>,<br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/about&#x27;</span>,<br>        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;About&#x27;</span>,<br>        <span class=\"hljs-attr\">meta</span>: &#123;<br>            <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;关于&#x27;</span>,<br>            <span class=\"hljs-attr\">needLogin</span>: <span class=\"hljs-literal\">true</span>,<br>        &#125;,<br>        <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">About</span>,<br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/login&#x27;</span>,<br>        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;Login&#x27;</span>,<br>        <span class=\"hljs-attr\">meta</span>: &#123;<br>            <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;登录&#x27;</span>,<br>        &#125;,<br>        <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">Login</span>,<br>    &#125;,<br>];<br><br><span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-title function_\">createRouter</span>(&#123;<br>    <span class=\"hljs-attr\">history</span>: <span class=\"hljs-title function_\">createWebHistory</span>(),<br>    routes,<br>&#125;);<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> router;<br></code></pre></td></tr></table></figure>\n\n<p>这里我们在路由中添加了一个<code>meta</code>属性，它一般用来存储路由的元信息，什么意思，就是我们可以通过这个对象来判断某个路由是否需要登录权限、页面标题、特定布局等等信息。</p>\n<p>这里我们设置 <code>meta.needLogin</code> 来标识某个路由是否需要登录权限，通过 <code>meta.title</code> 来设置页面标题，然后在路由守卫中动态更改 <code>document.title</code>即可。</p>\n<h3 id=\"路由守卫\"><a href=\"#路由守卫\" class=\"headerlink\" title=\"路由守卫\"></a>路由守卫</h3><p>为什么路由守卫能做？</p>\n<p>路由守卫是 Vue Router 中用于控制路由导航行为的功能。它允许在用户从一个路由导航到另一个路由之前、期间或之后执行自定义逻辑。</p>\n<p>而<strong>全局前置路由守卫</strong>是在每次路由导航开始前都会被调用。</p>\n<p>这样我们只需在路由跳转前，即全局前置路由守卫中去判断要去的路由是否需要登陆，并且判断用户是否登录即可！！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// main.js</span><br><span class=\"hljs-keyword\">import</span> &#123; createApp &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vue&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">App</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./App.vue&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> router <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./router&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-title function_\">createApp</span>(<span class=\"hljs-title class_\">App</span>);<br><br>router.<span class=\"hljs-title function_\">beforeEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">to, <span class=\"hljs-keyword\">from</span>, next</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> token = <span class=\"hljs-variable language_\">localStorage</span>.<span class=\"hljs-title function_\">getItem</span>(<span class=\"hljs-string\">&#x27;my-token&#x27;</span>); <span class=\"hljs-comment\">//用户登陆自动生成的token</span><br><br>    <span class=\"hljs-keyword\">if</span> (to.<span class=\"hljs-property\">meta</span>.<span class=\"hljs-property\">title</span>) &#123;<br>        <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">title</span> = to.<span class=\"hljs-property\">meta</span>.<span class=\"hljs-property\">title</span>; <span class=\"hljs-comment\">//设置路由标题</span><br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> (to.<span class=\"hljs-property\">meta</span>.<span class=\"hljs-property\">needLogin</span> &amp;&amp; !token) &#123; <span class=\"hljs-comment\">// 如果需要登录但是未登录，跳转到登录页面</span><br>        <span class=\"hljs-title function_\">next</span>(<span class=\"hljs-string\">&#x27;/login&#x27;</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123; <span class=\"hljs-comment\">//否则放行</span><br>        <span class=\"hljs-title function_\">next</span>();<br>    &#125;<br>&#125;);<br><br>app.<span class=\"hljs-title function_\">use</span>(router).<span class=\"hljs-title function_\">mount</span>(<span class=\"hljs-string\">&#x27;#app&#x27;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>在 Vue 中，实现路由拦截鉴权的核心是使用 Vue Router 提供的 <code>beforeEach</code> 全局前置守卫。在这个守卫函数中，我们可以根据路由的 <code>meta.needLogin</code> 属性，判断是否需要进行登录验证。如果用户未登录且访问了需要登录的页面，则重定向至登录页。</p>\n<h2 id=\"在React中怎么实现\"><a href=\"#在React中怎么实现\" class=\"headerlink\" title=\"在React中怎么实现\"></a>在React中怎么实现</h2><p>Vue 中很容易实现，问题来了，React 中怎么做？</p>\n<p>这里，我们使用 React Router 6的最新的路由配置写法，跟 Vue 简直不要太像</p>\n<h3 id=\"配置路由-1\"><a href=\"#配置路由-1\" class=\"headerlink\" title=\"配置路由\"></a>配置路由</h3><p>首先第一步同样是配置路由</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// router/index.js</span><br><span class=\"hljs-keyword\">import</span> &#123; createBrowserRouter &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-router-dom&#x27;</span>;<br><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Layout</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@/components/Layout&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Home</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@/pages/Home&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">About</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@/pages/About&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Login</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@/pages/Login&#x27;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> routes = [<br>    &#123;<br>        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;home&#x27;</span>,<br>        <span class=\"hljs-attr\">index</span>: <span class=\"hljs-literal\">true</span>,<br>        <span class=\"hljs-attr\">meta</span>: &#123;<br>            <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;首页&#x27;</span>,<br>            <span class=\"hljs-attr\">needLogin</span>: <span class=\"hljs-literal\">true</span>,<br>        &#125;,<br>        <span class=\"hljs-attr\">element</span>: <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Home</span> /&gt;</span></span>,<br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;about&#x27;</span>,<br>        <span class=\"hljs-attr\">meta</span>: &#123;<br>            <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;关于&#x27;</span>,<br>            <span class=\"hljs-attr\">needLogin</span>: <span class=\"hljs-literal\">true</span>,<br>        &#125;,<br>        <span class=\"hljs-attr\">element</span>: <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">About</span> /&gt;</span></span>,<br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/login&#x27;</span>,<br>        <span class=\"hljs-attr\">element</span>: <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Login</span> /&gt;</span></span>,<br>    &#125;,<br>];<br><br><span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-title function_\">createBrowserRouter</span>(routes);<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> router;<br></code></pre></td></tr></table></figure>\n\n<p>这里路由对象写法跟 Vue Router 不能说很像，只能说一模一样了，道理都一样，设置<code>meta</code>属性，将需要登录的路由，设置<code>needLogin</code>为<code>true</code>。</p>\n<h3 id=\"1-组件内部直接判断\"><a href=\"#1-组件内部直接判断\" class=\"headerlink\" title=\"1. 组件内部直接判断\"></a>1. 组件内部直接判断</h3><p>跟 Vue 的区别来了，React 可没有路由守卫这一说法，但是道理都一样，我们只需在路由跳转页面展示前一刻判断是否需要登录以及用户是否登录。</p>\n<p>但是React怎么实现在跳转前判断逻辑呢？</p>\n<p>第一种方法，也是最好想的方法，直接在组件内部的 <code>useEffect</code> 钩子中进行判断，条件不满足重定向去登录即可。</p>\n<p>我们知道<code>useEffect</code>在函数组件中充当特定的生命周期，就能在组件渲染前进行逻辑判断</p>\n<p>以 Home 页面为例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, &#123; useEffect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; useNavigate &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-router-dom&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Home</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> navigate = <span class=\"hljs-title function_\">useNavigate</span>();<br>  <span class=\"hljs-keyword\">const</span> token = <span class=\"hljs-variable language_\">localStorage</span>.<span class=\"hljs-title function_\">getItem</span>(<span class=\"hljs-string\">&#x27;my-token&#x27;</span>);<br><br>  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (!token) &#123;<br>      <span class=\"hljs-title function_\">navigate</span>(<span class=\"hljs-string\">&#x27;/login&#x27;</span>);<br>    &#125;<br>  &#125;, [navigate, token]);<br><br>  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Home Page<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Home</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这里我们使用<code>useEffect</code>钩子，当页面初次加载或依赖项更新的时候就会重新执行，能够达到我们目的。</p>\n<p>我们直接在组件加载前判断用户是否登录，哪里需要登录就在哪里判断，甚至省去了路由配置中的<code>meta</code>属性。</p>\n<p>⚠️但是这种方法太笨了，每个需要登录的页面都需要单独写一套这样的代码，很明显可以复用。于是便有了下面这个方法。</p>\n<h3 id=\"2-高阶组件\"><a href=\"#2-高阶组件\" class=\"headerlink\" title=\"2. 高阶组件\"></a>2. 高阶组件</h3><p>高阶组件本质上是一个函数，它接受一个组件作为输入，然后返回一个新的组件。我们可以在这个新组件渲染之前，即在父组件中操作，进行鉴权逻辑判断以实现类似 Vue 前置路由守卫的功能。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tsx\"><span class=\"hljs-comment\">// router/Auth.jsx</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Navigate</span>, useLocation &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-router-dom&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; routes, <span class=\"hljs-title class_\">RouterWithTabAuthObject</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./&#x27;</span>;<br><br><span class=\"hljs-comment\">// 获取当前路由的元数据</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">getRouteMeta</span> = (<span class=\"hljs-params\">path, routes</span>) =&gt; &#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> route <span class=\"hljs-keyword\">of</span> routes) &#123;<br>        <span class=\"hljs-keyword\">if</span> (route.<span class=\"hljs-property\">path</span> === path) <span class=\"hljs-keyword\">return</span> route;<br>        <span class=\"hljs-keyword\">if</span> (route.<span class=\"hljs-property\">children</span>) &#123;<br>            <span class=\"hljs-keyword\">const</span> childRoute = <span class=\"hljs-title function_\">getRouteMeta</span>(path, route.<span class=\"hljs-property\">children</span>);<br>            <span class=\"hljs-keyword\">if</span> (childRoute) <span class=\"hljs-keyword\">return</span> childRoute;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">undefined</span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Auth</span> = (<span class=\"hljs-params\">props</span>) =&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> location = <span class=\"hljs-title function_\">useLocation</span>();<br>    <span class=\"hljs-keyword\">const</span> token = <span class=\"hljs-variable language_\">localStorage</span>.<span class=\"hljs-title function_\">getItem</span>(<span class=\"hljs-string\">&#x27;my-token&#x27;</span>);<br><br>    <span class=\"hljs-keyword\">const</span> currentRoute = <span class=\"hljs-title function_\">getRouteMeta</span>(location.<span class=\"hljs-property\">pathname</span>, routes);<br><br>    <span class=\"hljs-comment\">// 设置页面标题</span><br>    <span class=\"hljs-keyword\">if</span> (currentRoute?.<span class=\"hljs-property\">meta</span>?.<span class=\"hljs-property\">title</span>) &#123;<br>        <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">title</span> = currentRoute.<span class=\"hljs-property\">meta</span>.<span class=\"hljs-property\">title</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 如果需要登录但没有 token，重定向到登录页</span><br>    <span class=\"hljs-keyword\">if</span> (currentRoute?.<span class=\"hljs-property\">meta</span>?.<span class=\"hljs-property\">needLogin</span> &amp;&amp; !token) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Navigate</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">&quot;/login&quot;</span> <span class=\"hljs-attr\">replace</span> /&gt;</span></span>;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span>&#123;props.children&#125;<span class=\"hljs-tag\">&lt;/&gt;</span></span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Auth</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这里逻辑其实跟前置路由守卫是一致，只不过Vue帮你做了封装，显得代码没有那么多，比较简单。</p>\n<p>我们来归纳一下，<code>beforeEach</code>可以直接通过<code>to.meta</code>直接拿到元数据，但是 React 需要判断当前<code>loaction</code>和<code>routes</code>路由对象进行查找才能找到对应的路由对象，即此处的<code>getRouteMeta</code>方法，如果有<code>children</code>还需要递归查找，其实 Vue 底层也是这样实现的。</p>\n<p>然后通过条件判断和重定向实现鉴权，最后如果不需要重定向，正常渲染 <code>props.children</code>，即子组件。</p>\n<h4 id=\"全局注册\"><a href=\"#全局注册\" class=\"headerlink\" title=\"全局注册\"></a>全局注册</h4><p><code>Auth</code>组件已经完成，还需要做一步操作，我们需要用这个高阶将所有路由包裹起来，才能发挥作用。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Layout</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;antd&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Outlet</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-router-dom&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Aside</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@/components/Aside&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Header</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@/components/Header&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Auth</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@/router/Auth&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">View</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>    <span class=\"hljs-keyword\">return</span> (<br>        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Auth</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Layout</span>&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Aside</span> /&gt;</span></span><br><span class=\"language-xml\">                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Header</span> /&gt;</span></span><br><span class=\"language-xml\">                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Content</span>&gt;</span></span><br><span class=\"language-xml\">                        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Outlet</span> /&gt;</span></span><br><span class=\"language-xml\">                    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Content</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Layout</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Auth</span>&gt;</span></span><br>    );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">View</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这里我一般习惯于将<code>Auth</code>包裹<code>&lt;Layout&gt;</code>组件，如果你没用到<code>Layout</code>，包裹<code>App</code>也是可以的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><p>在<code>Vue</code>中，实现路由拦截鉴权的核心就是使用 <code>beforeEach</code> 全局前置守卫。</p>\n</li>\n<li><p>在<code>React</code>中，暂且不考虑第一种组件内部判断的话，实现路由拦截鉴权就是将<strong>每个</strong>路由组件使用<strong>高阶组件</strong>进行包裹，在这个高阶组件里面进行权限相关逻辑的判断。</p>\n</li>\n</ul>\n<p>总而言之，其实不管是 Vue 还是 React 两者的核心思想相同，都是在用户访问受保护页面前，检查其登录状态，并根据检查结果决定是否允许访问，如何找到这的时间点才是关键！</p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>学过 Vue 的小伙伴肯定知道，在 Vue 中，路由守卫可以帮助我们一站式进行路由鉴权。我们只需要在全局前置路由守卫 (<code>beforeEach</code>) 钩子函数中判断逻辑即可，方便快捷。</p>\n<p>但是在 React 中，如何实现类似的功能呢？本文将对比 Vue 和 React 路由鉴权的方式，带你了解如何在 React 中配置路由并实现路由鉴权。</p>\n<h2 id=\"在Vue中如何实现\"><a href=\"#在Vue中如何实现\" class=\"headerlink\" title=\"在Vue中如何实现\"></a>在Vue中如何实现</h2><p>以 Vue3 为例</p>\n<h3 id=\"配置路由\"><a href=\"#配置路由\" class=\"headerlink\" title=\"配置路由\"></a>配置路由</h3><p>这里我们简单配置了三个路由，首页、关于和登录页面，除了登录页外都需要登录。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// router/index.js</span><br><span class=\"hljs-keyword\">import</span> &#123; createRouter, createWebHistory &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vue-router&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Home</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@/views/Home.vue&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">About</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@/views/About.vue&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Login</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@/views/Login.vue&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> routes = [<br>    &#123;<br>        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/&#x27;</span>,<br>        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;Home&#x27;</span>,<br>        <span class=\"hljs-attr\">meta</span>: &#123;<br>            <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;首页&#x27;</span>,<br>            <span class=\"hljs-attr\">needLogin</span>: <span class=\"hljs-literal\">true</span>,<br>        &#125;,<br>        <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">Home</span>,<br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/about&#x27;</span>,<br>        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;About&#x27;</span>,<br>        <span class=\"hljs-attr\">meta</span>: &#123;<br>            <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;关于&#x27;</span>,<br>            <span class=\"hljs-attr\">needLogin</span>: <span class=\"hljs-literal\">true</span>,<br>        &#125;,<br>        <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">About</span>,<br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/login&#x27;</span>,<br>        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;Login&#x27;</span>,<br>        <span class=\"hljs-attr\">meta</span>: &#123;<br>            <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;登录&#x27;</span>,<br>        &#125;,<br>        <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">Login</span>,<br>    &#125;,<br>];<br><br><span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-title function_\">createRouter</span>(&#123;<br>    <span class=\"hljs-attr\">history</span>: <span class=\"hljs-title function_\">createWebHistory</span>(),<br>    routes,<br>&#125;);<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> router;<br></code></pre></td></tr></table></figure>\n\n<p>这里我们在路由中添加了一个<code>meta</code>属性，它一般用来存储路由的元信息，什么意思，就是我们可以通过这个对象来判断某个路由是否需要登录权限、页面标题、特定布局等等信息。</p>\n<p>这里我们设置 <code>meta.needLogin</code> 来标识某个路由是否需要登录权限，通过 <code>meta.title</code> 来设置页面标题，然后在路由守卫中动态更改 <code>document.title</code>即可。</p>\n<h3 id=\"路由守卫\"><a href=\"#路由守卫\" class=\"headerlink\" title=\"路由守卫\"></a>路由守卫</h3><p>为什么路由守卫能做？</p>\n<p>路由守卫是 Vue Router 中用于控制路由导航行为的功能。它允许在用户从一个路由导航到另一个路由之前、期间或之后执行自定义逻辑。</p>\n<p>而<strong>全局前置路由守卫</strong>是在每次路由导航开始前都会被调用。</p>\n<p>这样我们只需在路由跳转前，即全局前置路由守卫中去判断要去的路由是否需要登陆，并且判断用户是否登录即可！！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// main.js</span><br><span class=\"hljs-keyword\">import</span> &#123; createApp &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vue&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">App</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./App.vue&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> router <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./router&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-title function_\">createApp</span>(<span class=\"hljs-title class_\">App</span>);<br><br>router.<span class=\"hljs-title function_\">beforeEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">to, <span class=\"hljs-keyword\">from</span>, next</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> token = <span class=\"hljs-variable language_\">localStorage</span>.<span class=\"hljs-title function_\">getItem</span>(<span class=\"hljs-string\">&#x27;my-token&#x27;</span>); <span class=\"hljs-comment\">//用户登陆自动生成的token</span><br><br>    <span class=\"hljs-keyword\">if</span> (to.<span class=\"hljs-property\">meta</span>.<span class=\"hljs-property\">title</span>) &#123;<br>        <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">title</span> = to.<span class=\"hljs-property\">meta</span>.<span class=\"hljs-property\">title</span>; <span class=\"hljs-comment\">//设置路由标题</span><br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> (to.<span class=\"hljs-property\">meta</span>.<span class=\"hljs-property\">needLogin</span> &amp;&amp; !token) &#123; <span class=\"hljs-comment\">// 如果需要登录但是未登录，跳转到登录页面</span><br>        <span class=\"hljs-title function_\">next</span>(<span class=\"hljs-string\">&#x27;/login&#x27;</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123; <span class=\"hljs-comment\">//否则放行</span><br>        <span class=\"hljs-title function_\">next</span>();<br>    &#125;<br>&#125;);<br><br>app.<span class=\"hljs-title function_\">use</span>(router).<span class=\"hljs-title function_\">mount</span>(<span class=\"hljs-string\">&#x27;#app&#x27;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>在 Vue 中，实现路由拦截鉴权的核心是使用 Vue Router 提供的 <code>beforeEach</code> 全局前置守卫。在这个守卫函数中，我们可以根据路由的 <code>meta.needLogin</code> 属性，判断是否需要进行登录验证。如果用户未登录且访问了需要登录的页面，则重定向至登录页。</p>\n<h2 id=\"在React中怎么实现\"><a href=\"#在React中怎么实现\" class=\"headerlink\" title=\"在React中怎么实现\"></a>在React中怎么实现</h2><p>Vue 中很容易实现，问题来了，React 中怎么做？</p>\n<p>这里，我们使用 React Router 6的最新的路由配置写法，跟 Vue 简直不要太像</p>\n<h3 id=\"配置路由-1\"><a href=\"#配置路由-1\" class=\"headerlink\" title=\"配置路由\"></a>配置路由</h3><p>首先第一步同样是配置路由</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// router/index.js</span><br><span class=\"hljs-keyword\">import</span> &#123; createBrowserRouter &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-router-dom&#x27;</span>;<br><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Layout</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@/components/Layout&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Home</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@/pages/Home&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">About</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@/pages/About&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Login</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@/pages/Login&#x27;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> routes = [<br>    &#123;<br>        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;home&#x27;</span>,<br>        <span class=\"hljs-attr\">index</span>: <span class=\"hljs-literal\">true</span>,<br>        <span class=\"hljs-attr\">meta</span>: &#123;<br>            <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;首页&#x27;</span>,<br>            <span class=\"hljs-attr\">needLogin</span>: <span class=\"hljs-literal\">true</span>,<br>        &#125;,<br>        <span class=\"hljs-attr\">element</span>: <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Home</span> /&gt;</span></span>,<br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;about&#x27;</span>,<br>        <span class=\"hljs-attr\">meta</span>: &#123;<br>            <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;关于&#x27;</span>,<br>            <span class=\"hljs-attr\">needLogin</span>: <span class=\"hljs-literal\">true</span>,<br>        &#125;,<br>        <span class=\"hljs-attr\">element</span>: <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">About</span> /&gt;</span></span>,<br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/login&#x27;</span>,<br>        <span class=\"hljs-attr\">element</span>: <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Login</span> /&gt;</span></span>,<br>    &#125;,<br>];<br><br><span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-title function_\">createBrowserRouter</span>(routes);<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> router;<br></code></pre></td></tr></table></figure>\n\n<p>这里路由对象写法跟 Vue Router 不能说很像，只能说一模一样了，道理都一样，设置<code>meta</code>属性，将需要登录的路由，设置<code>needLogin</code>为<code>true</code>。</p>\n<h3 id=\"1-组件内部直接判断\"><a href=\"#1-组件内部直接判断\" class=\"headerlink\" title=\"1. 组件内部直接判断\"></a>1. 组件内部直接判断</h3><p>跟 Vue 的区别来了，React 可没有路由守卫这一说法，但是道理都一样，我们只需在路由跳转页面展示前一刻判断是否需要登录以及用户是否登录。</p>\n<p>但是React怎么实现在跳转前判断逻辑呢？</p>\n<p>第一种方法，也是最好想的方法，直接在组件内部的 <code>useEffect</code> 钩子中进行判断，条件不满足重定向去登录即可。</p>\n<p>我们知道<code>useEffect</code>在函数组件中充当特定的生命周期，就能在组件渲染前进行逻辑判断</p>\n<p>以 Home 页面为例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, &#123; useEffect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; useNavigate &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-router-dom&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Home</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> navigate = <span class=\"hljs-title function_\">useNavigate</span>();<br>  <span class=\"hljs-keyword\">const</span> token = <span class=\"hljs-variable language_\">localStorage</span>.<span class=\"hljs-title function_\">getItem</span>(<span class=\"hljs-string\">&#x27;my-token&#x27;</span>);<br><br>  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (!token) &#123;<br>      <span class=\"hljs-title function_\">navigate</span>(<span class=\"hljs-string\">&#x27;/login&#x27;</span>);<br>    &#125;<br>  &#125;, [navigate, token]);<br><br>  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Home Page<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Home</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这里我们使用<code>useEffect</code>钩子，当页面初次加载或依赖项更新的时候就会重新执行，能够达到我们目的。</p>\n<p>我们直接在组件加载前判断用户是否登录，哪里需要登录就在哪里判断，甚至省去了路由配置中的<code>meta</code>属性。</p>\n<p>⚠️但是这种方法太笨了，每个需要登录的页面都需要单独写一套这样的代码，很明显可以复用。于是便有了下面这个方法。</p>\n<h3 id=\"2-高阶组件\"><a href=\"#2-高阶组件\" class=\"headerlink\" title=\"2. 高阶组件\"></a>2. 高阶组件</h3><p>高阶组件本质上是一个函数，它接受一个组件作为输入，然后返回一个新的组件。我们可以在这个新组件渲染之前，即在父组件中操作，进行鉴权逻辑判断以实现类似 Vue 前置路由守卫的功能。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tsx\"><span class=\"hljs-comment\">// router/Auth.jsx</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Navigate</span>, useLocation &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-router-dom&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; routes, <span class=\"hljs-title class_\">RouterWithTabAuthObject</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./&#x27;</span>;<br><br><span class=\"hljs-comment\">// 获取当前路由的元数据</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">getRouteMeta</span> = (<span class=\"hljs-params\">path, routes</span>) =&gt; &#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> route <span class=\"hljs-keyword\">of</span> routes) &#123;<br>        <span class=\"hljs-keyword\">if</span> (route.<span class=\"hljs-property\">path</span> === path) <span class=\"hljs-keyword\">return</span> route;<br>        <span class=\"hljs-keyword\">if</span> (route.<span class=\"hljs-property\">children</span>) &#123;<br>            <span class=\"hljs-keyword\">const</span> childRoute = <span class=\"hljs-title function_\">getRouteMeta</span>(path, route.<span class=\"hljs-property\">children</span>);<br>            <span class=\"hljs-keyword\">if</span> (childRoute) <span class=\"hljs-keyword\">return</span> childRoute;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">undefined</span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Auth</span> = (<span class=\"hljs-params\">props</span>) =&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> location = <span class=\"hljs-title function_\">useLocation</span>();<br>    <span class=\"hljs-keyword\">const</span> token = <span class=\"hljs-variable language_\">localStorage</span>.<span class=\"hljs-title function_\">getItem</span>(<span class=\"hljs-string\">&#x27;my-token&#x27;</span>);<br><br>    <span class=\"hljs-keyword\">const</span> currentRoute = <span class=\"hljs-title function_\">getRouteMeta</span>(location.<span class=\"hljs-property\">pathname</span>, routes);<br><br>    <span class=\"hljs-comment\">// 设置页面标题</span><br>    <span class=\"hljs-keyword\">if</span> (currentRoute?.<span class=\"hljs-property\">meta</span>?.<span class=\"hljs-property\">title</span>) &#123;<br>        <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">title</span> = currentRoute.<span class=\"hljs-property\">meta</span>.<span class=\"hljs-property\">title</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 如果需要登录但没有 token，重定向到登录页</span><br>    <span class=\"hljs-keyword\">if</span> (currentRoute?.<span class=\"hljs-property\">meta</span>?.<span class=\"hljs-property\">needLogin</span> &amp;&amp; !token) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Navigate</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">&quot;/login&quot;</span> <span class=\"hljs-attr\">replace</span> /&gt;</span></span>;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span>&#123;props.children&#125;<span class=\"hljs-tag\">&lt;/&gt;</span></span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Auth</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这里逻辑其实跟前置路由守卫是一致，只不过Vue帮你做了封装，显得代码没有那么多，比较简单。</p>\n<p>我们来归纳一下，<code>beforeEach</code>可以直接通过<code>to.meta</code>直接拿到元数据，但是 React 需要判断当前<code>loaction</code>和<code>routes</code>路由对象进行查找才能找到对应的路由对象，即此处的<code>getRouteMeta</code>方法，如果有<code>children</code>还需要递归查找，其实 Vue 底层也是这样实现的。</p>\n<p>然后通过条件判断和重定向实现鉴权，最后如果不需要重定向，正常渲染 <code>props.children</code>，即子组件。</p>\n<h4 id=\"全局注册\"><a href=\"#全局注册\" class=\"headerlink\" title=\"全局注册\"></a>全局注册</h4><p><code>Auth</code>组件已经完成，还需要做一步操作，我们需要用这个高阶将所有路由包裹起来，才能发挥作用。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Layout</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;antd&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Outlet</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-router-dom&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Aside</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@/components/Aside&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Header</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@/components/Header&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Auth</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@/router/Auth&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">View</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>    <span class=\"hljs-keyword\">return</span> (<br>        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Auth</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Layout</span>&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Aside</span> /&gt;</span></span><br><span class=\"language-xml\">                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Header</span> /&gt;</span></span><br><span class=\"language-xml\">                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Content</span>&gt;</span></span><br><span class=\"language-xml\">                        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Outlet</span> /&gt;</span></span><br><span class=\"language-xml\">                    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Content</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Layout</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Auth</span>&gt;</span></span><br>    );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">View</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这里我一般习惯于将<code>Auth</code>包裹<code>&lt;Layout&gt;</code>组件，如果你没用到<code>Layout</code>，包裹<code>App</code>也是可以的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><p>在<code>Vue</code>中，实现路由拦截鉴权的核心就是使用 <code>beforeEach</code> 全局前置守卫。</p>\n</li>\n<li><p>在<code>React</code>中，暂且不考虑第一种组件内部判断的话，实现路由拦截鉴权就是将<strong>每个</strong>路由组件使用<strong>高阶组件</strong>进行包裹，在这个高阶组件里面进行权限相关逻辑的判断。</p>\n</li>\n</ul>\n<p>总而言之，其实不管是 Vue 还是 React 两者的核心思想相同，都是在用户访问受保护页面前，检查其登录状态，并根据检查结果决定是否允许访问，如何找到这的时间点才是关键！</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clywvguj90000z0v63aky8kck","category_id":"clywvgujf0001z0v65y446g6x","_id":"clywvgujh0004z0v63tl84a80"},{"post_id":"clywvnjz7000318v66lyl5r4g","category_id":"clyr5bjsc0003hcv685ih7kuk","_id":"clywvnjz9000518v68jnzcfa3"},{"post_id":"clywvnv1q000618v64uykds4d","category_id":"clyr5bjsc0003hcv685ih7kuk","_id":"clywvp7is000a18v6admo8ikb"},{"post_id":"clywvs6t2000i18v689c949f9","category_id":"clywvrgp4000e18v65jx7fn4k","_id":"clywvs6t3000k18v67882gckk"},{"post_id":"clywvswxp0003cwv68y240h6j","category_id":"clywvgujf0001z0v65y446g6x","_id":"clywvswxr0005cwv65fsb6zd4"},{"post_id":"clywvtn580006cwv6234za1sd","category_id":"clyr5bjsc0003hcv685ih7kuk","_id":"clywvuh5i0008cwv60b1e403w"},{"post_id":"clywvvey60009cwv654cs7jql","category_id":"clywvwf7y000acwv60xu15h7h","_id":"clywvwf7y000dcwv6avtv68y0"},{"post_id":"clyww044t000fcwv609u7ar1q","category_id":"clywvwf7y000acwv60xu15h7h","_id":"clyww0hrk000jcwv62qczbc83"},{"post_id":"clyww1il3000040v653arhv7b","category_id":"clyww2n6y000340v62qh6b46d","_id":"clyww2n6z000640v6eyym8iee"},{"post_id":"clyww47x6000740v6d3t4bvqt","category_id":"clyww789y000i40v6ehcmg5kl","_id":"clyww789y000j40v6eg359loj"},{"post_id":"clyww7wpe000k40v67c6k5591","category_id":"clyww98s5000n40v68wq93tu0","_id":"clyww98s6000q40v63pzzd4mo"},{"post_id":"cm0v577p700000ov6hcoehiv1","category_id":"clywvwf7y000acwv60xu15h7h","_id":"cm0v5b14g00020ov62g2x5vul"}],"PostTag":[{"post_id":"clywvguj90000z0v63aky8kck","tag_id":"clywvgujh0002z0v6g8t19zue","_id":"clywvgujh0003z0v68ujb3h3e"},{"post_id":"clywvnjz7000318v66lyl5r4g","tag_id":"clyr5bjsd0004hcv6hmaidee9","_id":"clywvnjz9000418v6bn2q4xst"},{"post_id":"clywvnv1q000618v64uykds4d","tag_id":"clyr5bjsd0004hcv6hmaidee9","_id":"clywvp7is000918v69ahy7vt4"},{"post_id":"clywvs6t2000i18v689c949f9","tag_id":"clywvrgp4000f18v6a4su7f7z","_id":"clywvs6t3000j18v6cxif4a2i"},{"post_id":"clywvswxp0003cwv68y240h6j","tag_id":"clywvgujh0002z0v6g8t19zue","_id":"clywvswxr0004cwv671jg686c"},{"post_id":"clywvtn580006cwv6234za1sd","tag_id":"clyr5bjsd0004hcv6hmaidee9","_id":"clywvuh5i0007cwv6d4ao72xk"},{"post_id":"clywvvey60009cwv654cs7jql","tag_id":"clywvwf7y000bcwv6c611ecis","_id":"clywvwf7y000ccwv675ku0fnw"},{"post_id":"clyww044t000fcwv609u7ar1q","tag_id":"clywvwf7y000bcwv6c611ecis","_id":"clyww0hrj000icwv64u5958az"},{"post_id":"clyww1il3000040v653arhv7b","tag_id":"clyww2n6y000440v6hn18ehj0","_id":"clyww2n6y000540v68a2ifgkb"},{"post_id":"clyww47x6000740v6d3t4bvqt","tag_id":"clyww5tg5000b40v6cokt6fcv","_id":"clyww5tg7000e40v631cebr5e"},{"post_id":"clyww47x6000740v6d3t4bvqt","tag_id":"clyww5tg6000c40v625rs7xe0","_id":"clyww5tg7000f40v6bhzdd723"},{"post_id":"clyww7wpe000k40v67c6k5591","tag_id":"clyww98s6000o40v6hyogfp25","_id":"clyww98s6000p40v629x1ebmy"},{"post_id":"cm0v577p700000ov6hcoehiv1","tag_id":"clywvwf7y000bcwv6c611ecis","_id":"cm0v5b14g00030ov67tgi9r77"},{"post_id":"cm0v577p700000ov6hcoehiv1","tag_id":"cm0v5b14f00010ov6e1zibnt2","_id":"cm0v5b14g00040ov6drrycmfm"}],"Tag":[{"name":"TypeScript","_id":"clyr5bjsd0004hcv6hmaidee9"},{"name":"JavaScript","_id":"clywvgujh0002z0v6g8t19zue"},{"name":"Git","_id":"clywvrgp4000f18v6a4su7f7z"},{"name":"React","_id":"clywvwf7y000bcwv6c611ecis"},{"name":"性能优化","_id":"clyww2n6y000440v6hn18ehj0"},{"name":"Webpack","_id":"clyww5tg5000b40v6cokt6fcv"},{"name":"Vite","_id":"clyww5tg6000c40v625rs7xe0"},{"name":"HTTP","_id":"clyww98s6000o40v6hyogfp25"},{"name":"Vue","_id":"cm0v5b14f00010ov6e1zibnt2"}]}}